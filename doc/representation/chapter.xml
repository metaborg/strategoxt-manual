<chapter id="program-representation">
  <title>Program Representation</title>

  <para>

    Program transformation systems need some kind of representation
    for program that can be manipulated.  Programmers write programs
    as texts using text editors.  Some programming environments
    provide more graphical (visual) interfaces for programmers to
    specify certain domain-specific ingredients (e.g., user interface
    components). But ultimately, such environments have a textual
    interface for specifying the details. Even if programs are written
    in a `structured format' such as XML, the representation used by
    programmers generally is text. So a program transformation system
    needs to manipulate programs in text format.

  </para>

  <para>

    However, for all but the most trivial transformations, a
    structured rather than a textual representation is needed.  To
    bridge the gap between textual and structured representation,
    parsers and unparsers are needed. Since the theory of formal
    languages, context-free and regular grammars, and parser
    construction are standard fair (see for example [ASU86]), we will
    not treat those subjects here. The purpose of this chapter is to
    introduce the terminology and formalisms used in the rest of this
    book. This includes formal syntax definition with the syntax
    definition formalism SDF, parsing, representation of trees as
    ATerms, mapping of parse trees to abstract syntax trees, and
    pretty-printing using the target-independent Box language.  We
    illustrate these concepts with a syntax definition for a subset of
    the Tiger language.

  </para>

<section>
  <title>Grammars as Contracts</title>

  <para>
        
    Syntax definitions formalize the interface between the textual
    representation used by programmers and the structured
    representation used by transformation systems. A syntax definition
    (or grammar) formally declares the syntax of a programming
    language and the mapping from a textual to a tree representation,
    and back. That is, from a syntax definition one can automatically
    derive the implementation of parsers, signatures, and
    pretty-printers.  If multiple transformation components are in
    play, syntax definitions can also define the interface between
    these components. In other words, grammars form the contracts for
    transformation components [JV00.gcse].

  </para>

  <para>
        
    <xref linkend="Fig:GrammarsAsContracts"/> illustrates these ideas.
    To transform a program, it is first parsed and represented as a
    tree (triangle). The tree is transformed by a tree transformation
    component which results in a transformed tree. This tree is then
    rendered as text by a pretty-printer.  The contract between
    parser, transformer, and pretty-printer is embedded in the parse
    table, signature, and pretty-print table, which are all generated
    from the same syntax definition.

  </para>

  <figure id="Fig:GrammarsAsContracts">
    <title>
      Syntax definitions define the interfaces between transformation
      components.
    </title>
    <pngobject fileref="representation/xmpl/transf-cycle.png" align="center"/>
  </figure>

</section>

<section>
 <title>Syntax Definition</title>

 <para>

   A syntax definition is a formal description of the syntax of a
   programming language. In Stratego/XT we mostly use the syntax
   definition formalism SDF [HHKR89,Vis97.thesis] to describe
   syntax. The syntax of SDF itself and information about the SDF
   programming environment can be found in Chapter [SDF].

 </para>

 <section>
  <title>Context-free Grammars</title>

  <para>

    Context-free grammars were introduced by Chomsky [Cho56] to
    describe the <emphasis>generation</emphasis> of grammatically
    correct sentences in a language.  A context-free grammar is a set
    of <emphasis>rewrite rules</emphasis>, or
    <emphasis>productions</emphasis> of the form
    <code>A0 -> A1 ... An</code>. A grammar describes a language by
    <emphasis>generating</emphasis> its sentences. A string is
    generated by starting with the start non-terminal and repeatedly
    replacing non-terminal symbols according to the productions until
    a string of terminal symbols is reached.

  </para>

  <para>

    A context-free grammar can also be used to
    <emphasis>recognize</emphasis> sentences in the language. In that
    process, a string of terminal symbols is rewritten to the start
    non-terminal, by repeatedly applying grammar productions
    backwards, i.e., reducing a substring matching the right-hand side
    of a production to the non-terminal on the left-hand side. SDF
    productions are specified as <code>A1 ... An -> A0</code>, to
    emphasize the recognition aspect of grammars. (Another motivation
    for this reversal is to emphasize the equivalence of context-free
    productions with function type declarations <code>f : t1 * ... *
    tn -> t0</code>.)

  </para>

  <para>

    As an example, consider the syntax definition for a small language
    of arithmetic expressions in <xref
    linkend="Fig:Expressions-NoCons.sdf"/>.  Using this definition,
    and provided that <code>a</code> and <code>n</code> are
    identifiers (<code>Id</code>) and <code>1</code> is an
    <code>IntConst</code>, a string such as <code>(a+n)*1</code> can
    be recognized as an expression by reducing it to <code>Exp</code>,
    as shown by the reduction sequence in the <link
    linkend="Fig:Expressions-NoCons.sdf">right-hand side of the
    figure</link>.

  </para>

  <figure id="Fig:Expressions-NoCons.sdf">
    <title>
      Context-free productions and a reduction sequence
      according to the productions.
    </title>
    <nexttoeachother>
      <entry align="center">
        <showfile root="." file="xmpl/Expressions-NoCons.sdf"/>
      </entry>
      <entry align="center">
        <showfile root="." file="xmpl/Expressions-NoCons.red"/>
      </entry>
    </nexttoeachother>
  </figure>

 </section>

 <section>
  <title>Parse Trees</title>

  <para>

    Recognition of a string only leads to its grammatical category,
    not to any other information.  A context-free grammar not only
    describes a mapping from strings to sorts, but actually assigns
    structure to strings.  A context-free grammar can be considered as
    a declaration of a set of trees of one level deep. For example,
    the following trees correspond to productions from the syntax
    definition in <xref linkend="Fig:Expressions-NoCons.sdf"/>:

    <informalfigure pgwide="1">
       <pngobject fileref="representation/xmpl/Plus.png" align="center"/>
    </informalfigure>

    <informalfigure pgwide="0">
       <pngobject fileref="representation/xmpl/PlusTimes.png" align="right"/>
    </informalfigure>

    Such one-level trees can be composed into larger trees by fusing
    trees such that the symbol at a leaf of one tree matches with the
    root symbol of another, as is illustrated in the fusion of the
    plus and times productions on the right.  The fusion process can
    continue as long as the tree has non-terminal leaves. A tree
    composed in this fashion is a parse tree if all leaves are
    terminal symbols. <xref linkend="Fig:ParseTree"/> shows a parse
    tree for the expression <code>(a+n)*1</code>. This illustrates the
    direct correspondence between a string and its grammatical
    structure. The string underlying a parse tree can be obtained by
    concatening the symbols at its leaves.

  </para>

  <figure id="Fig:ParseTree">
    <title>
      Parse tree
    </title>
    <pngobject fileref="representation/xmpl/test1-ntt.png" align="center"/>
  </figure>

  <para>

    Parse trees can be derived from the reduction sequence induced by
    the productions of a grammar. Each rewrite step is associated with
    a production, and thus with a tree fragment. Instead of replacing
    a symbol with the non-terminal symbol of the production, it is
    replaced with the tree fragment for the production fused with the
    trees representing the symbols being reduced. Thus, each node of a
    parse tree corresponds to a rewrite step in the reduction of its
    underlying string. This is illustrated by comparing the reduction
    sequence in <xref linkend="Fig:Expressions-NoCons.sdf"/> with the
    tree in <xref linkend="Fig:ParseTree"/>

  </para>

  <para>

    The recognition of strings described by a syntax definition, and
    the corresponding construction of parse trees can be done
    automatically by a parser, which can be generated from the
    productions of a syntax definition. We will not be concerned with
    the implementation of parsers in this book. The implementation of
    a parser and parser generator for SDF is explained in
    [Vis97.thesis].

  </para>

 </section>

 <section>
  <title>Abstract Syntax Trees</title>

  <para>

    Parse trees contain all the details of a program including
    literals, whitespace, and comments.  This is usually not necessary
    for performing transformations.  A parse tree is reduced to an
    <emphasis>abstract syntax tree</emphasis> by eliminating
    irrelevant information such as literal symbols and layout.
    Furthermore, instead of using sort names as node labels,
    <emphasis>constructors</emphasis> encode the production from which
    a node is derived. For this purpose, the productions in a syntax
    definition are extended with <emphasis>constructor
    annotations</emphasis>.  <xref linkend="Fig:test1-acub"/> shows
    the extension of the syntax definition from <xref
    linkend="Fig:Expressions-NoCons.sdf"/> with constructor
    annotations and the abstract syntax tree for the string
    <code>(a+n)*1</code>. Note that some identifiers are used as sort
    names <emphasis>and</emphasis> and as constructors. This does not
    lead to a conflict since sort names and constructors are derived
    from separate name spaces.

  </para>

  <figure id="Fig:test1-acub">
    <title>
      Context-free productions with constructor annotations and an
      abstract syntax tree.
    </title>
    <nexttoeachother>
      <entry><showfile root="." file="xmpl/Expressions-Cons.sdf"/></entry>
      <entry><pngobject fileref="representation/xmpl/test1-acub.png" align="center"/></entry>
    </nexttoeachother>
  </figure>

 </section>

 <section>
  <title>Disambiguation</title>

  <para>

    Syntax definitions in the style of <xref
    linkend="Fig:test1-acub"/> are <emphasis>ambiguous</emphasis>,
    i.e., there is more than one way to map strings to trees. For
    example, the string <code>a+b*c</code> has two possible
    derivations, as shown in <xref linkend="Fig:ambiguities"/>.

  </para>

  <figure id="Fig:ambiguities">
    <title>
      Parses for the string <code>a+b*c</code>
    </title>
    <nexttoeachother>
      <entry>
        <pngobject fileref="representation/xmpl/test5-acub.png" align="center"/>
      </entry>
      <entry>
        <pngobject fileref="representation/xmpl/test4-acub.png" align="center"/>
      </entry>
    </nexttoeachother>
  </figure>

  <para>

    In plain context-free grammars such ambiguities are solved by
    introducing additional non-terminals and productions. This results
    in much more complex parse trees and increases the distance
    between parse trees and abstract syntax trees. In order to support
    natural syntax definitions, SDF provides several declarative
    disambiguation mechanisms. Associativity declarations
    (<code>left</code>, <code>right</code>, <code>non-assoc</code>),
    disambiguate combinations of a binary operator with itself and
    with other operators. Thus, the left associativity of
    <code>+</code> entails that <code>a+b+c</code> is parsed as
    <code>(a+b)+c</code>. Priority declarations (<code>></code>)
    declare the relative priority of productions. A production with
    lower priority cannot be a direct subtree of a production with
    higher priority. Thus <code>a+b*c</code> is parsed as
    <code>a+(b*c)</code> since the other parse <code>(a+b)*c</code>
    has a conflict between the <code>*</code> and <code>+</code>
    productions.

  </para>

  <figure id="Fig:Expressions.sdf">
    <title>
      Syntax definition with associativity and priority declarations.
    </title>
    <showfile root="." file="xmpl/Expressions.sdf"/>
  </figure>

 </section>

 <section>
  <title>Regular Expressions</title>

  <para>
       
     Programming languages usually contain all kinds of list
     constructs. Specification of lists with plain context-free
     grammars requires several productions for each list construct.
     SDF provides a bunch of regular expression operators abbreviating
     common patterns. The operators <code>A*</code> and
     <code>A+</code> denote lists of zero (one) or more
     <code>A</code>s.  The <code>{A lit}*</code> and <code>{A
     lit}+</code> operators denote lists of zero (one) or more
     <code>A</code>s separated by <code>lit</code>.

  </para>

  <para>
        
     <xref linkend="Fig:RegularExpressions"/> illustrates the use of
     these operators in the extension of the expression language with
     statements and function declarations. Lists are used in numerous
     places, such as for the sequential composition of statements
     (<code>Seq</code>), the declarations in a let binding, and the
     formal and actual arguments of a function (<code>FunDec</code>
     and <code>Call</code>). An example function definition in this
     language is:
<screen>
function fact(n, x) =
  if n > 0 then fact(n - 1, n * x) else x
</screen>

  </para>

  <figure id="Fig:RegularExpressions">
    <title>
      Syntax definition with regular expressions.
    </title>
    <showfile root="." file="xmpl/Statements.sdf"/>
  </figure>

 </section>

 <section>
   <title>Lexical Syntax</title>

  <para>

    So far we have looked at syntax of expressions and statements, but
    not at the definition of lexical items such as identifiers and
    constants. In most syntax definition formalisms these are defined
    separately to generate a scanner which divides a string into
    tokens before the parser recognizes the context-free structure.

  </para>

  <para>
        
    In SDF the definition of lexical and context-free syntax are
    integrated in the same formalism, and are specified using the same
    means, i.e., context-free productions, regular expressions,
    etc. Productions for lexical items are introduced using the
    keywords <code>lexical syntax</code>. The only difference between
    lexical and context-free syntax is that layout (whitespace,
    comments) can occur between the strings corresponding to sorts in
    the left-hand of a context-free production, or, conversely,
    <emphasis>no</emphasis> layout is allowed between the tokens of a
    lexeme. The occurrence of layout is indicated by injecting
    <code>LAYOUT?</code>, i.e., optional layout, between every two
    symbols of a context-free production. To avoid cluttering syntax
    definitions, this is done automatically by the SDF parser
    generator.

  </para>

  <para>
        
    In order to define the syntax at the level of characters, SDF
    provides character classes <code>[...]</code>, which generate one
    character from the set. Letters and digits can be written as
    themselves, all other characters should be escaped using a slash,
    e.g. <code>\_</code>. Characters can also be indicated by their
    decimal ASCII\footnote{These codes could also be interpreted in a
    different character encoding.} code, e.g., <code>\13</code> for
    linefeed. Some often used non-printable characters have more
    mnemonic names, e.g., <code>\n</code> for newline, <code>\ </code>
    for space and <code>\t</code> for tab.

  </para>

  <para>
        
    The definition of lexical syntax with a context-free grammar,
    gives rise to ambiguities that cannot be resolved with the
    associativity and priority mechanisms shown earlier. SDF provides
    two additional disambiguation mechanism for this purpose. A follow
    restriction \texttt{A -/- cc1 . ... . ccn} indicates that a string
    of sort A cannot be followed by a string in <code>cc1
    ... ccn</code>, where the <code>cc</code> are character
    classes. Follow restrictions can be used to encode longest match
    disambiguation. A reject production <code>A1 ... An -> A0
    {reject}</code> forbids an <code>A0</code> if it can also be
    parsed as <code>A1 ... An</code>. Reject productions are typically
    used to specify reserved words, by rejecting them as identifiers.

  </para>

  <para>
        
    These concepts are illustrated in <xref
    linkend="Fig:LexicalSyntax"/>, which defines the lexical syntax of
    identifiers, integer constants, and C-style comments. Note how
    follow restrictions are used for longest match disambiguation of
    identifiers, integer constants, and layout. Since an identifier
    cannot be followed by a letter, the <code>a</code> in
    <code>ab</code> cannot be recognized as an identifier by itself,
    only the entire string <code>ab</code>.  Restrictions are also
    used to define that a sole asterisk within a C style comment
    should not be followed by a slash (which would end the comment). A
    reject production is used to forbid the use of keywords as
    identifiers.

  </para>

  <figure id="Fig:LexicalSyntax">
    <title>
      Definition of lexical syntax.
    </title>
    <showfile root="." file="xmpl/Lexical.sdf"/>
  </figure>

 </section>

 <section>
  <title>Modules</title>

  <para>

    To enable reuse of parts of a syntax definition, SDF is a
    <emphasis>modular</emphasis> formalism. Modules can import other
    modules.

  </para>

  <para>

    (** TODO: discuss renaming imports **)

  </para>

 </section>

</section>

<section>
 <title>Trees are Terms</title>

 <para>

   <informalfigure pgwide="0">
     <pngobject fileref="representation/xmpl/test1-acub.png" align="right"/>
   </informalfigure>

   So far we have presented parse trees and abstract syntax trees as
   graphical structures.  This representation corresponds closely to
   the representation of trees in computer memory. However, drawing
   pictures is not a very effective way of specifying tree
   transformations, nor is manipulating tree structures using data
   structure access functions in a general purpose language. There is
   a one-to-one correspondence between trees and first-order prefix
   terms.  A term is a constructor, i.e., an identifier, applied to
   zero or more terms, where strings and integer constants are
   considered as special cases of constructors. Thus, the term
   <code>Times(Plus(Var("a"), Var("n")), Int("1"))</code> corresponds
   to the abstract syntax tree on the right.

 </para>

 <para>

   The Annotated Term Format [BJKO00], or <emphasis>ATerms</emphasis>
   for short is a standard format for the representation of structured
   data for exchange between programs. It is essentially the prefix
   term format sketched above with a few additional features. An ATerm
   is one of:

   <itemizedlist>

     <listitem>
       <para>
         Constant constructor: <code>Nil</code> or <code>Nil()</code>
       </para>
     </listitem>

     <listitem>
       <para>
         Integer constant, e.g., <code>1</code>
       </para>
     </listitem>

     <listitem>
       <para>
        Real constant, e.g., <code>0.1</code>
       </para>
     </listitem>

     <listitem>
       <para>
        String constant, e.g., <code>"foo"</code>
       </para>
     </listitem>

     <listitem>
       <para>
        Constructor application to n terms, e.g.,
        <code>Plus(Var("a"),Int(1))</code>
       </para>
     </listitem>

     <listitem>
       <para>
        A list of terms, e.g., <code>[A,B,C]</code>
       </para>
     </listitem>

     <listitem>
       <para>
        A tuple of terms, e.g., <code>(A,B,C)</code>
       </para>
     </listitem>

   </itemizedlist>

   In addition, any ATerm can be annotated with a list of terms using
   the notation <code>t{a1,...,an}</code>. The purpose of annotations
   is to attach semantic information to terms without changing its
   basic structure.  A precise syntax definition of ATerms can be
   found in <xref linkend="ref-aterms"/>

  </para>

 <section>
  <title>ATerm Library</title>

  <para>
        
    The ATerm Format is an external representation for terms that can
    be used to exchange structured data between programs.  In order to
    use a term, a program needs to parse ATerms and transform them
    into some internal representation. To export a term after
    processing it, a program should transform the internal
    representation into the standard format.  There are libraries
    supporting these operation for a number of languages, including C,
    Java, and Haskell.

  </para>

  <para>
       
    The implementation of the Stratego transformation language is
    based on the C implementation of the library. The library provides
    term input and output, and an API for constructing and inspecting
    terms. Garbage collection is based on B\"ohms conservative garbage
    collection algorithm.

  </para>

  <para>
        
    An important feature of the implementation is that terms are
    represented using maximal sharing. This means that any term in use
    in a program is represented only once. In other words, two
    occurrences of the same term will be represented by pointers to
    the same location. <xref linkend="Fig:Sharing"/> illustrates the
    difference between a pure tree representation and a tree, or more
    accurately, a <emphasis>directed acyclic graph</emphasis>, with
    maximal sharing. That is, any sub-term is represented exactly once
    in memory, with each occurrence pointing to the same memory
    location. This representation entails that term equality is a
    constant operation, since it consists of comparing pointers. It
    should be noted that annotations create different terms, that is,
    two terms, one with and the other without annotations that are
    otherwise, modulo annotations, the same, are not equal.

  </para>

  <figure id="Fig:Sharing">
    <title>
      Tree and dag for the string <code>(a + b) * c + (a + b)</code>
    </title>
    <nexttoeachother>
      <entry>
        <pngobject fileref="representation/xmpl/sharing-acub.png" align="center"/>
      </entry>
      <entry>
        <pngobject fileref="representation/xmpl/sharing-scub.png" align="center"/>
      </entry>
    </nexttoeachother>
  </figure>

  <para>

    Maximal sharing can make a big difference [BJKO00] in the amount
    of memory needed for representing programs.  When exporting a term
    using the textual exchange format, this compression is
    lost. Therefore, the ATerm Library also provides a binary exchange
    format that preserves maximal sharing.

  </para>

  <para>
        
    See <xref linkend="ref-aterms"/> for more information on ATerms.

  </para>

 </section>

 <section>
  <title>Signatures</title>

  <para>

    The abstract syntax of a programming language or data format can
    be described by means of an <emphasis>algebraic
    signature</emphasis>.  A signature declares for each constructor
    its arity <code>m</code>, the sorts of its arguments <code>S1 *
    ... * Sm</code>, and the sort of the resulting term
    <code>S0</code> by means of a constructor declaration <code>c:S1 *
    ... * Sm -> S0</code>.  A term can be validated against a
    signature by a <emphasis>format checker</emphasis>.

  </para>

  <para>

    Signatures can be derived automatically from syntax definitions.
    For each production <code>A1...An -> A0 {cons(c)}</code> in a
    syntax definition, the corresponding constructor declaration is
    <code>c:S1 * ... * Sm -> S0</code>, where the <code>Si</code> are
    the sorts corresponding to the symbols <code>Aj</code> after
    leaving out literals and layout sorts.  <xref
    linkend="Fig:Signatures"/> shows the signatures of statement and
    expression constructors for the example language from this
    chapter.  The modules have been derived automatically from the
    syntax definitions in <xref linkend="Fig:Expressions.sdf"/> and
    <xref linkend="Fig:RegularExpressions"/>.

  </para>

  <figure id="Fig:Signatures">
    <title>
      Signature for statement and expression constructors,
      automatically derived from a syntax definition.
    </title>
    <showfile root="." file="xmpl/Statements.str"/>
  </figure>

 </section>

</section>

<section>
  <title>Pretty-Printing</title>

  <para>

    After transformation, an abstract syntax tree should be turned
    into text again to be useful as a program. Mapping a tree into
    text can be seen as the inverse as parsing, and is thus called
    <emphasis>unparsing</emphasis>. When an unparser makes an attempt
    at producing human readable, instead of just compiler parsable,
    program text, an unparser is called a
    <emphasis>pretty-printer</emphasis>. We use the pretty-printing
    model as provided by the <link
    linkend="generic-pretty-printing">Generic Pretty-Printing package
    GPP</link>. In this model a tree is unparsed to a Box expression,
    which contains text with markup for pretty-printing. A Box
    expression can be interpreted by different back-ends to produce
    text for different displaying devices, such as plain ASCII text,
    HTML, and LaTeX.

  </para>

 <section>
  <title>Unparsing</title>

  <para>
        
    Unparsing is the inverse of parsing composed with abstract syntax
    tree composition. That is, an unparser turns an abstract syntax
    tree into a string, such that if the resulting string is parsed
    again, it produces the same abstract syntax tree.

  </para>

  <para>

    An unparser can be organized in two phases. In the first phase,
    each node in an abstract syntax tree is replaced with the concrete
    syntax tree of the corresponding grammar production.  In the
    second phase, the strings at the leaves of the tree are
    concatenated into a string.  <xref linkend="Fig:Unparsing"/>
    illustrates this process. The replacement of abstract syntax tree
    nodes by concrete syntax patterns should be done according to the
    productions of the syntax definition. An unparsing table is an
    abstraction of a syntax definition definining the inverse mapping
    from constructors to concrete syntax patterns. An entry <code>c --
    s1 ... sn</code> defines a mapping for constructor <code>c</code>
    to the sequence <code>s1 ... sn</code>, where each
    <code>s_i</code> is either a literal string or a parameter
    <code><code>_</code>i</code> referring to the <code>i</code>th
    argument of the constructor. <xref linkend="Fig:UnparsingTable"/>
    shows an unparsing table for some expression and statement
    constructors. Applying an unparsing mapping to an abstract syntax
    tree results in a tree structure with strings at the leafs, as
    illustrated in <xref linkend="Fig:Unparsing"/>.

  </para>

  <figure id="Fig:Unparsing">
    <title>
      Unparsing an abstract syntax tree.
    </title>
    <nexttoeachother>
      <entry>
         <pngobject fileref="representation/xmpl/test6-acub.png" align="center"/>
      </entry>
      <entry>
        <pngobject fileref="representation/xmpl/test6-unparse.png" align="center"/>
      </entry>
    </nexttoeachother>
    <screen>f(a + 10) - 3</screen>
  </figure>

  <figure id="Fig:UnparsingTable">
    <title>
      Unparsing table
    </title>
    <showfile root="." file="xmpl/Statements-condensed.pp"/>
  </figure>

 </section>

 <section>
   <title>Pretty-Printing</title>

  <para> 

    Although the unparse of an abstract syntax tree is a text that can
    be parsed by a compiler, it is not necessarily a
    <emphasis>readable</emphasis> text. A
    <emphasis>pretty-printer</emphasis> is an unparser attempting to
    produce readable program text.  A pretty-printer can be obtained
    by annotating the entries in an unparsing table with markup
    instructing a typesetting process. <xref
    linkend="Fig:PrettyPrinting"/> illustrates this process.

  </para>

  <para>
        
    Box is a target independent formatting language, providing
    combinators for declaring the two-dimensional positioning of boxes
    of text. Typical combinators are <code>H[b_1...b_n]</code>, which
    combines the <code>b_i</code> boxes horizontally, and
    <code>V[b_1...b_n]</code>, which combines the
    <code>b_i</code> boxes vertically.  <xref
    linkend="Fig:PrettyPrintTable"/> shows a pretty-print table with
    Box markup. A more complete overview of the Box language and the
    GPP tools can be found in <xref
    linkend="generic-pretty-printing"/>.

  </para>

  <figure id="Fig:PrettyPrinting">
    <title>
      Pretty-printing with Box markup
    </title>
    <nexttoeachother>
      <entry>
        <pngobject fileref="representation/xmpl/test6-acub.png" align="center"/>
      </entry>
      <entry>
        <pngobject fileref="representation/xmpl/test6-abox-tree.png" align="center"/>
      </entry>
    </nexttoeachother>
    <screen>f(a + 10) - 3</screen>
  </figure>

  <figure id="Fig:PrettyPrintTable">
    <title>
      Pretty-print table with Box markup
    </title>
    <showfile root="." file="xmpl/Statements-pretty-condensed.pp"/>
  </figure>

  <figure>
    <title>
      Pretty-printing of if-then-else statement
    </title>
    <showfile root="." file="xmpl/test7.acub.edited"/>
    <pngobject fileref="representation/xmpl/test7-acub.png" align="center"/>
    <pngobject fileref="representation/xmpl/test7-abox-tree.png" align="center"/>
    <showfile root="." file="xmpl/test7.acub.txt"/>
  </figure>

 </section>

 <section>
   <title>Disambiguation</title>

  <para>
       
    Note: correct pretty-printing of an abstract syntax tree requires
    that it contains nodes representing parentheses in the right
    places. Otherwise, reparsing a pretty-printed string might get a
    different interpretation. The <link
    linkend="ref-sdf2parenthesize"><code>sdf2parenthesize</code></link>
    tool generates from an SDF definition a Stratego program that
    places parentheses at the necessary places in the tree.

  </para>

 </section>

</section>

<section>
  <title>Tools</title>

  <para>

    The Stratego/XT collection provides various tools for parsing and
    pretty-printing programs based on the syntax definition formalism
    SDF2. (In fact the various tools originate from different
    sub-packages, which does not correspond to the aggregation
    presented here.) In this section an overview of the main tools is
    given with their typical command-line arguments and a reference to
    the tool documentation.

  </para>

 <section>
  <title>Syntax Definition and Parsing</title>

  <formalpara>
    <title><link linkend="ref-pack-sdf"><code>
       pack-sdf -i m.sdf -o m.def -I dir
    </code></link></title>

    <para>

      An SDF syntax definition consists of a set of
      modules. <code>pack-sdf</code> collects all modules imported by
      module <code>m</code> in file <code>m.sdf</code> and creates a
      combined syntax definition in file <code>m.def</code>. Modules
      are looked for in the current directory and any of the include
      directories indicated with the <code>-I dir</code> arguments.

    </para>

  </formalpara>

  <formalpara>
    <title><link linkend="ref-sdf2table"><code>
      sdf2table -i m.def -o m.tbl -m M
    </code></link></title>

    <para>
      
      <code>Sdf2table</code> is the parser generator for SDF. It takes
      a complete syntax definition <code>m.def</code> (as produced by
      <code>pack-sdf</code>), and produces a parse table
      <code>m.tbl</code> in ATerm format. By default a parse table is
      generated for module <code>Main</code>; this can be overridden
      using the <code>-m</code> option.

    </para>

  </formalpara>

  <formalpara>
    <title><link linkend="ref-sglr"><code>
      sglr -p m.tbl -i file.m -o file.asfix -2
    </code></link></title>

    <para>
    
      <code>sglr</code> is the parser for SDF. It takes as arguments a
      parse table <code>m.tbl</code> and an input file
      <code>file.m</code>, presumably in the language described by
      <code>m.def</code>. The parser produces a parse tree in the
      AsFix format. If option <code>-2</code> is produced, the tree is
      in the specific AsFix2 format, which is what Stratego/XT tools
      use.  The AsFix2 format is a complete and faithful
      representation of the derivation constructed by the parser. It
      includes all details of the input file, including whitespace,
      comments, and is self documenting as it uses the complete
      productions of the syntax definition to encode node labels.

  </para>

  </formalpara>

  <formalpara>
    <title><link linkend="ref-asfix-yield"><code>
       asfix-yield -i file.asfix -o file.txt
    </code></link></title>

    <para>

      <code>asfix-yield</code> is an unparser for AsFix files, i.e.,
      it produces the exact text from which the parse tree was
      derived.

    </para>

  </formalpara>

  <formalpara>
    <title><link linkend="ref-implode-asfix"><code>
       implode-asfix -i file.asfix -o file.trm
    </code></link></title>

    <para>

      <code>implode-asfix</code> transforms an AsFix parse tree to an
      abstract syntax tree.

    </para>

  </formalpara>

  <formalpara>
    <title><link linkend="ref-sglri"><code>
       sglri -p m.tbl -i file.m -o file.asfix
    </code></link></title>

    <para>

      <code>Sglri</code> is a convenience composition of
      <code>sglr</code> and <code>implode-asfix</code>.

    </para>

  </formalpara>

 </section>

 <section>
   <title>Signatures</title>

  <formalpara>
    <title><link linkend="ref-sdf2rtg"><code>
       sdf2rtg -i m.def -o m.rtg -m M
    </code></link></title>

    <para>

      <code>sdf2rtg</code> derives from an SDF syntax definition
      <code>m.def</code> a regular tree grammar for the module
      <code>M</code> and all modules it imports.

    </para>

  </formalpara>

  <formalpara>
    <title><link linkend="ref-rtg2sig"><code>
       rtg2sig -i m.def -o m.rtg
    </code></link></title>

    <para>

      <code>rtg2sig</code> generates from a regular tree grammar a
      Stratego signature.

    </para>

  </formalpara>

 </section>

 <section>
   <title>Pretty-Printing and Term Visualization</title>

  <formalpara>
    <title><link linkend="ref-ppgen"><code>
      ppgen -i m.def -o m.pp
    </code></link></title>

    <para>

      <code>Ppgen</code> generates from an SDF syntax definition a
      pretty-print table with an entry for each context-free syntax
      production with a constructor annotation. Typically it is
      necessary to edit the pretty-print table to add appropriate Box
      markup to the entries. The result should be saved under a
      different name to avoid overwriting it.

    </para>

  </formalpara>

  <formalpara>
    <title><link linkend="ref-ast2abox"><code>
      ast2abox -p m.pp -i file.ast -o file.abox
    </code></link></title>

    <para>

      <code>ast2abox</code> maps an abstract syntax tree
      <code>file.ast</code> to an abstract syntax representation
      <code>file.abox</code> of a Box term based on a pretty-print
      table <code>m.pp</code>.

    </para>

  </formalpara>

  <formalpara>
    <title><link linkend="ref-abox2text"><code>
      abox2text -i file.abox -o file.txt
    </code></link></title>

    <para>
      <code>abox2text</code> formats a Box term as ASCII text.
    </para>

  </formalpara>

  <formalpara>
    <title><link linkend="ref-pp-aterm"><code>
      pp-aterm -i file1.trm -o file2.trm
    </code></link></title>

    <para>
      <code>pp-aterm</code> formats an ATerm as an ATerm in text
      format, adding newlines and indentation to make the structure of
      the term understandable. This is a useful tool to inspect terms
      while debugging transformations.
    </para>

  </formalpara>

  <formalpara>
    <title><code>
      term-to-dot -i file.trm -o file.dot (--tree | --graph)
    </code></title>

    <para>

      <code>Term-to-dot</code> is another visualization tool for terms
      that creates a <code>dot</code> graph representation, which can
      be visualized using the <code>dot</code> tool from the graphviz
      graph layout package. <code>Term-to-dot</code> can produce an
      expanded tree view (<code>--tree</code>), or a directed acyclic
      graph view (<code>--graph</code>) preserving the maximal sharing
      in the term. This tool was used to produce the tree
      visualizations in this chapter.

      This tool is not part of the Stratego/XT distribution, but
      included in the Stratego/XT Utilities package.
    </para>

  </formalpara>

 </section>

</section>

</chapter>
