<chapter>
  <title>Program Representation (*)</title>

  <para>

    Program transformation systems need some kind of representation
    for program that can be manipulated.  Programmers write programs
    as texts using text editors.  Some programming environments
    provide more graphical (visual) interfaces for programmers to
    specify certain domain-specific ingredients (e.g., user interface
    components). But ultimately, such environments have a textual
    interface for specifying the details. Even if programs are written
    in a `structured format' such as XML, the representation used by
    programmers generally is text. So a program transformation system
    needs to manipulate programs in text format.

  </para>

  <para>

    However, for all but the most trivial transformations, a
    structured rather than a textual representation is needed.  To
    bridge the gap between textual and structured representation,
    parsers and unparsers are needed. Since the theory of formal
    languages, context-free and regular grammars, and parser
    construction are standard fair (see for example [ASU86]), we will
    not treat those subjects here. The purpose of this chapter is to
    introduce the terminology and formalisms used in the rest of this
    book. This includes formal syntax definition with the syntax
    definition formalism SDF, parsing, representation of trees as
    ATerms, mapping of parse trees to abstract syntax trees, and
    pretty-printing using the target-independent Box language.  We
    illustrate these concepts with a syntax definition for a subset of
    the Tiger language.

  </para>

<section>
  <title>Grammars as Contracts</title>

  <figure id="Fig:GrammarsAsContracts">
    <title>
      Syntax definitions define the interfaces between transformation
      components.
    </title>
    <graphic fileref="representation/xmpl/transf-cycle.png" align="center"/>
  </figure>

  <para>
        
    Syntax definitions formalize the interface between the textual
    representation used by programmers and the structured
    representation used by transformation systems. A syntax definition
    (or grammar) formally declares the syntax of a programming
    language and the mapping from a textual to a tree representation,
    and back. That is, from a syntax definition one can automatically
    derive the implementation of parsers, signatures, and
    pretty-printers.  If multiple transformation components are in
    play, syntax definitions can also define the interface between
    these components. In other words, grammars form the grammars as
    contracts for transformation components [JV00.gcse].

  </para>

  <para>
        
     <xref linkend="Fig:GrammarsAsContracts"/> illustrates these
     ideas.  To transform a program, it is first parsed and
     represented as a tree (triangle). The tree is transformed by a
     tree transformation component which results in a transformed
     tree. This tree is then rendered as text by a pretty-printer.
     The contract between parser, transformer, and pretty-printer is
     embedded in the parse table, signature, and pretty-print table,
     which are all generated from the same syntax definition.

  </para>

</section>

<section>
 <title>Syntax Definition</title>

 <para>

   A syntax definition is a formal description of the syntax of a
   programming language. In this book we will use the syntax
   definition formalism SDF [HHKR89,Vis97.thesis] to describe
   syntax. The syntax of SDF itself and information about the SDF
   programming environment can be found in Chapter [SDF].

 </para>

 <section>
  <title>Context-free Grammars</title>

  <para>

  <figure id="Fig:Expressions-NoCons.sdf">
    <title>
      Context-free productions and a reduction sequence
      according to the productions.
    </title>
    <showfile root="." file="xmpl/Expressions-NoCons.sdf"/>
    <showfile root="." file="xmpl/Expressions-NoCons.red"/>
  </figure>


  </para>

  <para>

        Context-free grammars were introduced by Chomsky~\cite{Cho56}
        to describe the \emph{generation} of grammatically correct
        sentences in a language.  A context-free grammar is a set of
        \emph{rewrite rules}, or \emph{productions} of the form
        $A_0\verb|->|A_1...A_n$. A grammar describes a language by
        \emph{generating} its sentences. A string is generated by
        starting with the start non-terminal and repeatedly replacing
        non-terminal symbols according to the productions until a
        string of terminal symbols is reached.

  </para>

  <para>

        A context-free grammar can also be used to \emph{recognize}
        sentences in the language. In that process, a string of
        terminal symbols is rewritten to the start non-terminal, by
        repeatedly applying grammar productions backwards, i.e.,
        reducing a substring matching the right-hand side of a
        production to the non-terminal on the left-hand side. SDF
        productions are specified as $A_1...A_n\verb|->|A_0$, to
        emphasize the recognition aspect of grammars.\footnote{Another
        motivation for this reversal is to emphasize the equivalence
        of context-free productions with function type declarations $f
        : \tau_1 * ... * \tau_n \to \tau_0$.}

  </para>

  <para>
        As an example, consider the syntax definition for a small
        language of arithmetic expressions in
        Figure~\ref{Fig:Expressions-NoCons.sdf}.  Using this
        definition, and provided that \verb|a| and \verb|n| are
        identifiers (\verb|Id|) and \verb|1| is an \verb|IntConst|, a
        string such as \verb|(a+n)*1| can be recognized as an
        expression by reducing it to \verb|Exp|, as shown by the
        reduction sequence in
        Figure~\ref{Fig:Expressions-NoCons.sdf}.

  </para>

 </section>

 <section>
   <title>Parse Trees</title>

  <para>

        Recognition of a string only leads to its grammatical
        category, not to any other information.  A context-free
        grammar not only describes a mapping from strings to sorts,
        but actually assigns structure to strings.  A context-free
        grammar can be considered as a declaration of a set of trees
        of one level deep. For example, the following trees correspond
        to productions from the syntax definition in
        Figure~\ref{Fig:Expressions-NoCons.sdf}:

  </para>

  <para>


    <graphic fileref="representation/xmpl/Plus.png" align="center"/>

  </para>

  <para>

    <graphic fileref="representation/xmpl/PlusTimes.png" align="center"/>

  </para>

  <para>

        Such one-level trees can be composed into larger trees by
        fusing trees such that the symbol at a leaf of one tree
        matches with the root symbol of another, as is illustrated in
        the fusion of the plus and times productions on the left. The
        fusion process can continue as long as the tree has
        non-terminal leaves. A tree composed in this fashion is a
        parse tree if all leaves are terminal
        symbols. Figure~\ref{Fig:ParseTree} shows a parse tree for the
        expression \verb|(a+n)*1|. This illustrates the direct
        correspondence between a string and its grammatical
        structure. The string underlying a parse tree can be obtained
        by concatening the symbols at its leaves.


  </para>

  <para>

  <figure id="Fig:ParseTree">
    <title>
      Parse tree
    </title>
    <graphic fileref="representation/xmpl/test1-ntt.png" align="center"/>
  </figure>

  </para>

  <para>

        Parse trees can be derived from the reduction sequence induced
        by the productions of a grammar. Each rewrite step is
        associated with a production, and thus with a tree
        fragment. Instead of replacing a symbol with the non-terminal
        symbol of the production, it is replaced with the tree
        fragment for the production fused with the trees representing
        the symbols being reduced. Thus, each node of a parse tree
        corresponds to a rewrite step in the reduction of its
        underlying string. This is illustrated by comparing the
        reduction sequence in
        Figure~\ref{Fig:Expressions-NoCons.sdf} with the tree in
        Figure~\ref{Fig:ParseTree}.


  </para>

  <para>

    The recognition of strings described by a syntax definition, and
    the corresponding construction of parse trees can be done
    automatically by a parser, which can be generated from the
    productions of a syntax definition. We will not be concerned with
    the implementation of parsers in this book. The implementation of
    a parser and parser generator for SDF is explained
    in~\cite{Vis97.thesis}.

  </para>

 </section>

 <section>
   <title>Abstract Syntax Trees</title>

  <para>

        Parse trees contain all the details of a program including
        literals, whitespace, and comments.  This is usually not
        necessary for performing transformations.  A parse tree is
        reduced to an \emph{abstract syntax tree} by eliminating
        irrelevant information such as literal symbols and layout.
        Furthermore, instead of using sort names as node labels,
        \emph{constructors} encode the production from which a node is
        derived. For this purpose, the productions in a syntax
        definition are extended with \emph{constructor annotations}.
        Figure~\ref{Fig:test1-acub} shows the extension of the syntax
        definition from Figure~\ref{Fig:Expressions-NoCons.sdf} with
        constructor annotations and the abstract syntax tree for the
        string \verb|(a+n)*1|. Note that some identifiers are used as
        sort names \emph{and} and as constructors. This does not lead
        to a conflict since sort names and constructors are derived
        from separate name spaces.


  </para>

  <para>

  <figure id="Fig:test1-acub">
    <title>
      Context-free productions with constructor annotations and an
      abstract syntax tree.
    </title>
    <showfile root="." file="xmpl/Expressions-Cons.sdf"/>
    <graphic fileref="representation/xmpl/test1-acub.png" align="center"/>
  </figure>

  </para>

 </section>

 <section>
   <title>Disambiguation</title>

  <para>

        Syntax definitions in the style of Figure~\ref{Fig:test1-acub}
        are \emph{ambiguous}, i.e., there is more than one way to map
        strings to trees. For example, the string \verb|a+b*c| has two
        possible derivations, as shown in Figure~\ref{Fig:ambiguities}.

  </para>

  <para>


  <figure id="Fig:ambiguities">
    <title>
      Parses for the string <code>a+b*c</code>
    </title>
    <graphic fileref="representation/xmpl/test5-acub.png" align="center"/>
    <graphic fileref="representation/xmpl/test4-acub.png" align="center"/>
  </figure>

  </para>

  <para>

  <figure id="Fig:Expressions.sdf">
    <title>
      Syntax definition with associativity and priority declarations.
    </title>
    <showfile root="." file="xmpl/Expressions.sdf"/>
  </figure>

  </para>

  <para>

        In plain context-free grammars such ambiguities are solved by
        introducing additional non-terminals and productions. This
        results in much more complex parse trees and increases the
        distance between parse trees and abstract syntax trees. In
        order to support natural syntax definitions, SDF provides
        several declarative disambiguation mechanisms. Associativity
        declarations (\verb|left|, \verb|right|, \verb|non-assoc|),
        disambiguate combinations of a binary operator with itself and
        with other operators. Thus, the left associativity of \verb|+|
        entails that \verb|a+b+c| is parsed as
        \verb|(a+b)+c|. Priority declarations (\verb|>|) declare the
        relative priority of productions. A production with lower
        priority cannot be a direct subtree of a production with
        higher priority. Thus \verb|a+b*c| is parsed as \verb|a+(b*c)|
        since the other parse \verb|(a+b)*c| has a conflict between
        the \verb|*| and \verb|+| productions.

  </para>

 </section>


 <section>
   <title>Regular Expressions</title>

  <para>
       Programming languages usually contain all kinds of list
        constructs. Specification of lists with plain context-free
        grammars requires several productions for each list construct.
        SDF provides a bunch of regular expression operators
        abbreviating common patterns. The operators \verb|A*| and
        \verb|A+| denote lists of zero (one) or more \verb|A|s.  The
        \verb|{A lit}*| and \verb|{A lit}+| operators denote lists of
        zero (one) or more \verb|A|s separated by \verb|lit|.

  </para>

  <para>
        Figure~\ref{Fig:RegularExpressions} illustrates the use of
        these operators in the extension of the expression language
        with statements and function declarations. Lists are used in
        numerous places, such as for the sequential composition of
        statements (\verb|Seq|), the declarations in a let binding,
        and the formal and actual arguments of a function
        (\verb|FunDec| and \verb|Call|). An example function
        definition in this language is:
<screen>
   function fact(n, x)
              = if n > 0 then fact(n - 1, n * x) else x
</screen>

  </para>

  <figure id="Fig:RegularExpressions">
    <title>
      Syntax definition with regular expressions.
    </title>
    <showfile root="." file="xmpl/Statements.sdf"/>
  </figure>

 </section>

 <section>
   <title>Lexical Syntax</title>

  <figure id="Fig:LexicalSyntax">
    <title>
      Definition of lexical syntax.
    </title>
    <showfile root="." file="xmpl/Lexical.sdf"/>
  </figure>

  <para>

        So far we have looked at syntax of expressions and statements,
        but not at the definition of lexical items such as identifiers
        and constants. In most syntax definition formalisms these are
        defined separately to generate a scanner which divides a
        string into tokens before the parser recognizes the
        context-free structure.

  </para>

  <para>
        In SDF the definition of lexical and context-free syntax are
        integrated in the same formalism, and are specified using the
        same means, i.e., context-free productions, regular
        expressions, etc. Productions for lexical items are introduced
        using the keywords \texttt{lexical syntax}. The only
        difference between lexical and context-free syntax is that
        layout (whitespace, comments) can occur between the strings
        corresponding to sorts in the left-hand of a context-free
        production, or, conversely, \emph{no} layout is allowed
        between the tokens of a lexeme. The occurrence of layout is
        indicated by injecting \verb|LAYOUT?|, i.e., optional layout,
        between every two symbols of a context-free production. To
        avoid cluttering syntax definitions, this is done
        automatically by the SDF parser generator.

  </para>

  <para>
        In order to define the syntax at the level of characters, SDF
        provides character classes \verb|[...]|, which generate one
        character from the set. Letters and digits can be written as
        themselves, all other characters should be escaped using a
        slash, e.g. \verb|\_|. Characters can also be indicated by
        their decimal ASCII\footnote{These codes could also be
        interpreted in a different character encoding.} code, e.g.,
        \verb|\13| for linefeed. Some often used non-printable
        characters have more mnemonic names, e.g., \verb|\n| for
        newline, \verb|\ | for space and \verb|\t| for tab.

  </para>

  <para>
        The definition of lexical syntax with a context-free grammar,
        gives rise to ambiguities that cannot be resolved with the
        associativity and priority mechanisms shown earlier. SDF
        provides two additional disambiguation mechanism for this
        purpose. A follow restriction
\texttt{A -/- cc1 . ... . ccn}
        indicates that a string of sort A cannot be followed by a
        string in \verb|cc1 ... ccn|, where the \verb|cc| are
        character classes. Follow restrictions can be used to encode
        longest match disambiguation. A reject production
\verb|A1 ... An -> A0 {reject}|
        forbids an \verb|A0| if it can also be parsed as
\verb|A1 ... An|. Reject productions are typically used to specify
        reserved words, by rejecting them as identifiers.


  </para>

  <para>
        These concepts are illustrated in
        Figure~\ref{Fig:LexicalSyntax}, which defines the lexical
        syntax of identifiers, integer constants, and C-style
        comments. Note how follow restrictions are used for longest
        match disambiguation of identifiers, integer constants, and
        layout. Since an identifier cannot be followed by a letter,
        the \verb|a| in \verb|ab| cannot be recognized as an
        identifier by itself, only the entire string \verb|ab|.
        Restrictions are also used to define that a sole asterisk
        within a C style comment should not be followed by a slash
        (which would end the comment). A reject production is used to
        forbid the use of keywords as identifiers.

  </para>

 </section>

 <section>
   <title>Modules</title>

  <para>
        To enable reuse of parts of a syntax definition, SDF is
        a \emph{modular} formalism. Modules can import other modules.

        (** TODO: discuss renaming imports **)

  </para>

 </section>


</section>

<section>
  <title>Trees are Terms</title>

    <graphic fileref="representation/xmpl/test1-acub.png" align="center"/>
 
 <para>

   So far we have presented parse trees and abstract syntax trees as
   graphical structures.  This representation corresponds closely to
   the representation of trees in computer memory. However, drawing
   pictures is not a very effective way of specifying tree
   transformations, nor is manipulating tree structures using data
   structure access functions in a general purpose language. There is
   a one-to-one correspondence between trees and first-order prefix
   terms.  A term is a constructor, i.e., an identifier, applied to
   zero or more terms, where strings and integer constants are
   considered as special cases of constructors. Thus, the term %
   \texttt{\input{xmpl/test1.acub}} \texttt{Times(Plus(Var("a"),
   Var("n")), Int("1"))} corresponds to the abstract syntax tree
   above.


 </para>

  <para>

    The Annotated Term Format~\cite{BJKO00}, or \emph{ATerm Format}
    for short is a standard format for the representation of
    structured data for exchange between programs. It is essentially
    the prefix term format sketched above with a few additional
    features. An ATerm is one of:

\begin{itemize}

        \item Constant constructor: \verb|Nil| or \verb|Nil()|

        \item Integer constant, e.g., \verb|1|

        \item Real constant, e.g., \verb|0.1|

        \item String constant, e.g., \verb|"foo"|

        \item Constructor application to $n$ terms, e.g.,
                \verb|Plus(Var("a"),Int(1))|

        \item A list of terms, e.g., \verb|[A,B,C]|

        \item A tuple of terms, e.g., \verb|(A,B,C)|

\end{itemize}
        In addition, any ATerm can be annotated with a list of terms
        using the notation
        $t\texttt{\{}a_1\texttt{,}...\texttt{,}a_n\texttt{\}}$.  The
        purpose of annotations is to attach semantic information to
        terms without changing its basic structure.  The full syntax
        of ATerms can be found in Chapter~\ref{Chap:ATerm}

        (** TODO: give more precise definition of ATerm format **)

  </para>

 

 <section>
   <title>ATerm Library</title>

  <figure id="Fig:Sharing">
    <title>
      Tree and dag for the string <code>(a + b) * c + (a + b)</code>
    </title>
    <graphic fileref="representation/xmpl/sharing-acub.png" align="center"/>
    <graphic fileref="representation/xmpl/sharing-scub.png" align="center"/>
  </figure>

  <para>
        The ATerm Format is an external representation for terms that
        can be used to exchange structured data between programs.  In
        order to use a term, a program needs to parse ATerms and
        transform them into some internal representation. To export a
        term after processing it, a program should transform the
        internal representation into the standard format.  There are
        libraries supporting these operation for a number of
        languages, including C, Java, and Haskell.

  </para>

  <para>
       The implementation of the Stratego transformation language,
        which will be used in the rest of this book, is based on the C
        implementation of the library. The library provides term input
        and output, and an API for constructing and inspecting
        terms. Garbage collection is based on B\"ohms conservative
        garbage collection algorithm.

  </para>

  <para>
        An important feature of the implementation is that terms are
        represented using maximal sharing. This means that any term in
        use in a program is represented only once. In other words, two
        occurrences of the same term will be represented by pointers
        to the same location. Figure~\ref{Fig:Sharing} illustrates the
        difference between a pure tree representation and a tree, or
        more accurately, a \emph{directed acyclic graph}, with maximal
        sharing. That is, any sub-term is represented exactly once in
        memory, with each occurrence pointing to the same memory
        location. This representation entails that term equality is a
        constant operation, since it consists of comparing
        pointers. It should be noted that annotations create different
        terms, that is, two terms, one with and the other without
        annotations that are otherwise, module annotations, the same,
        are not equal.

  </para>

  <para>

        Maximal sharing can make a big difference~\cite{BJKO00} in
        the amount of memory needed for representing programs.  When
        exporting a term using the textual exchange format, this
        compression is lost. Therefore, the ATerm Library also
        provides a binary exchange format that preserves maximal
        sharing.

  </para>

  <para>
        See Chapter XXX for more information on ATerms

  </para>

 </section>

 <section>
   <title>Signatures</title>

  <para>

     The abstract syntax of a programming language or data format can
     be described by means of an \emph{algebraic signature}.  A
     signature declares for each constructor its arity $m$, the sorts
     of its arguments $S_1\verb|*|...\verb|*|S_m$, and the sort of the
     resulting term $S_0$ by means of a constructor declaration
     $c:S_1\verb|*|...\verb|*|S_m\to{}S_0$.  A term can be validated
     against a signature by a \emph{format checker}.

  </para>

  <para>
        Signatures can be derived automatically from syntax
        definitions.  For each production
        $A_1...A_n\to{}A_0\{\verb|cons|(c)\}$ in a syntax definition,
        the corresponding constructor declaration is
        $c:S_1\verb|*|...\verb|*|S_m\to{}S_0$, where the $S_i$ are the
        sorts corresponding to the symbols $A_j$ after leaving out
        literals and layout sorts.  Figure~\ref{Fig:Signatures} shows
        the signatures of statement and expression constructors for
        the example language from this chapter.  The modules have been
        derived automatically from the syntax definitions in
        Figures~\ref{Fig:Expressions.sdf}
        and~\ref{Fig:RegularExpressions}.

  </para>

  <figure id="Fig:Signatures">
    <title>
      Signature for statement and expression constructors,
      automatically derived from a syntax definition.
    </title>
    <showfile root="." file="xmpl/Statements.str"/>
  </figure>

 </section>

</section>

<section>
  <title>Pretty-Printing</title>

  <para>

        After transformation, an abstract syntax tree should be turned
        into text again to be useful as a program. Mapping a tree into
        text can be seen as the inverse as parsing, and is thus called
        \emph{unparsing}. When an unparser makes an attempt at
        producing human readable, instead of just compiler parsable,
        program text, an unparser is called a
        \emph{pretty-printer}. We use the pretty-printing model as
        provided by the Generic Pretty-Printing package
        GPP~\cite{GPP}. In this model a tree is unparsed to a Box
        expression, which contains text with markup for
        pretty-printing. A Box expression can be interpreted by
        different back-ends to produce text for different displaying
        devices, such as plain ASCII text, HTML, and LaTeX.

  </para>

 <section>
   <title>Unparsing</title>

  <para>
        Unparsing is the inverse of parsing composed with abstract
        syntax tree composition. That is, an unparser turns an
        abstract syntax tree into a string, such that if the resulting
        string is parsed again, it produces the same abstract syntax
        tree.

  </para>

  <para>

        An unparser can be organized in two phases. In the first
        phase, each node in an abstract syntax tree is replaced with
        the concrete syntax tree of the corresponding grammar
        production.  In the second phase, the strings at the leaves of
        the tree are concatenated into a string.
        Figure~\ref{Fig:Unparsing} illustrates this process. The
        replacement of abstract syntax tree nodes by concrete syntax
        patterns should be done according to the productions of the
        syntax definition. An unparsing table is an abstraction of a
        syntax definition definining the inverse mapping from
        constructors to concrete syntax patterns. An entry
%
        $c\verb| -- |s_1...s_n$
%
        defines a mapping for constructor $c$ to the sequence
        $s_1...s_n$, where each $s_i$ is either a literal string or a
        parameter $\verb|_|i$ referring to the $i$th argument of the
        constructor. Figure~\ref{Fig:UnparsingTable} shows an
        unparsing table for some expression and statement
        constructors. Applying an unparsing mapping to an abstract
        syntax tree results in a tree structure with strings at the
        leafs, as illustrated in Figure~\ref{Fig:Unparsing}.

  </para>

  <para>

  <figure id="Fig:Unparsing">
    <title>
      Unparsing an abstract syntax tree.
    </title>
    <graphic fileref="representation/xmpl/test6-acub.png" align="center"/>
    <graphic fileref="representation/xmpl/test6-unparse.png" align="center"/>
    <screen>f(a + 10) - 3</screen>
  </figure>

  <figure id="Fig:UnparsingTable">
    <title>
      Unparsing table
    </title>
    <showfile root="." file="xmpl/Statements-condensed.pp"/>
  </figure>

<!--
        \begin{figure}[t]
        \begin{boxedminipage}{\hsize}
        \begin{center}
        \inputepsUnboxedSize[c]{2.7cm}{xmpl/test6-acub}
        $\Rightarrow$
        \inputepsUnboxedSize[c]{3.5cm}{xmpl/test6-unparse}
        $\Rightarrow$
        {\small\verb| f(a + 10) - 3|}
        \end{center}
        \end{boxedminipage}
        \caption{Unparsing an abstract syntax tree}
        \label{Fig:Unparsing}
        \ \\
        \inputsource{xmpl/Statements-condensed.pp}
        \caption{Unparsing table}
        \label{Fig:UnparsingTable}
        \end{figure}
-->

  </para>

 </section>

 <section>
   <title>Pretty-Printing</title>

  <para>       Although the unparse of an abstract syntax tree is a text that
        can be parsed by a compiler, it is not necessarily a
        \emph{readable} text. A \emph{pretty-printer} is an unparser
        attempting to produce readable program text.  A pretty-printer
        can be obtained by annotating the entries in an unparsing
        table with markup instructing a typesetting
        process. Figure~\ref{Fig:PrettyPrinting} illustrates this
        process.

  </para>

  <para>
        Box is a target independent formatting language, providing
        combinators for declaring the two-dimensional positioning of
        boxes of text. Typical combinators are
        $\verb|H[|b_1...b_n\verb|]|$, which combines the $b_i$ boxes
        horizontally, and $\verb|V[|b_1...b_n\verb|]|$, which combines
        the $b_i$ boxes vertically.  Figure~\ref{Fig:PrettyPrintTable}
        shows a pretty-print table with Box markup. A more complete
        overview of the Box language and the GPP tools can be found in
        Chapter~\ref{Chap:Box}.

  </para>

  <para>


  <figure id="Fig:PrettyPrinting">
    <title>
      Pretty-printing with Box markup
    </title>
    <graphic fileref="representation/xmpl/test6-acub.png" align="center"/>
    <graphic fileref="representation/xmpl/test6-abox-tree.png" align="center"/>
    <screen>f(a + 10) - 3</screen>
  </figure>

  <figure id="Fig:PrettyPrintTable">
    <title>
      Pretty-print table with Box markup
    </title>
    <showfile root="." file="xmpl/Statements-pretty-condensed.pp"/>
  </figure>

<!--

       \begin{figure}[t]
        \begin{boxedminipage}{\hsize}
        \begin{center}
        \inputepsUnboxedSize[c]{2.7cm}{xmpl/test6-acub}
        $\Rightarrow$
        \inputepsUnboxedSize[c]{4cm}{xmpl/test6-abox-tree}
        $\Rightarrow$
        {\small\verb| f(a + 10) - 3|}
        \end{center}
        \end{boxedminipage}
        \caption{Pretty-printing with Box markup}
        \label{Fig:PrettyPrinting}
        \ \\
        \inputsource{xmpl/Statements-pretty-condensed.pp}
        \caption{Pretty-print table with Box markup}
        \label{Fig:PrettyPrintTable}
        \end{figure}
-->

  </para>

  <para>

  <figure>
    <title>
      Pretty-printing of if-then-else statement
    </title>
    <showfile root="." file="xmpl/test7.acub.edited"/>
    <graphic fileref="representation/xmpl/test7-acub.png" align="center"/>
    <graphic fileref="representation/xmpl/test7-abox-tree.png" align="center"/>
    <showfile root="." file="xmpl/test7.acub.txt"/>
  </figure>


<!--
        \begin{figure}[p]
        \begin{center}
        \inputsourceSize{10.1cm}{xmpl/test7.acub.edited}
        \\
        \inputepsSize{10.1cm}{xmpl/test7-acub}
        \\
        $\Downarrow$
        \\
        \inputepsSize{10.1cm}{xmpl/test7-abox-tree}
        \\
        $\Downarrow$
        \\
        \inputsourceSize{3.2cm}{xmpl/test7.acub.txt}
        \end{center}
        \caption{Pretty-printing of if-then-else statement}
        \end{figure}
-->

  </para>

 </section>

 <section>
   <title>Disambiguation</title>

  <para>
        Note: correct pretty-printing of an abstract syntax tree
        requires that it contains nodes representing parentheses in
        the right places. Otherwise, reparsing a pretty-printed string
        might get a different interpretation.


  </para>

 </section>

</section>

<section>
  <title>Tools</title>

  <para>

       The Stratego/XT bundle\footnote{In fact the various tools
        originate from different sub-packages, which does not
        correspond to the aggregation presented here.} provides
        various tools for parsing and pretty-printing programs based
        on the syntax definition formalism SDF2. In this section an
        overview of the main tools is given with their typical
        command-line arguments. More specific information can be
        obtained from the online documentation of the tools.

  </para>

 <section>
   <title>Syntax Definition and Parsing</title>

  <para>
pack-sdf -i m.sdf -o m.adef -I dir]

        \ \\ An SDF syntax definition consists of a set of
        modules. \texttt{Pack-sdf} collects all modules imported by
        module \texttt{m} in file \texttt{m.sdf} and creates a
        combined syntax definition in file \texttt{m.adef}. Modules
        are looked for in the current directory and any of the include
        directories indicated with the \texttt{-I dir} arguments.  The
        output of \texttt{pack-sdf} is in AsFix format (see below).
        To get a textual representation use \texttt{asfix-yield}.

  </para>

  <para>

sdf2table -i m.def -o m.tbl -m M]

        \ \\ \texttt{Sdf2table} is the parser generator for SDF. It
        takes a complete syntax definition \texttt{m.def} (as produced
        by \texttt{pack-sdf}), and produces a parse table
        \texttt{m.tbl} in ATerm format. By default a parse table is
        generated for module \texttt{Main}; this can be overridden
        using the \texttt{-m} option.

  </para>

  <para>
sglr -p m.tbl -i file.m -o file.asfix -2]

        \ \\ \texttt{Sglr} is the parser for SDF. It takes as
        arguments a parse table \texttt{m.tbl} and an input file
        \texttt{file.m}, presumably in the language described by
        \texttt{m.def}. The parser produces a parse tree in the AsFix
        format. If option \texttt{-2} is produced, the tree is in the
        specific AsFix2 format, which is what Stratego/XT tools use.
        The AsFix2 format is a complete and faithful representation of
        the derivation constructed by the parser. It includes all
        details of the input file, including whitespace, comments, and
        is self documenting as it uses the complete productions of the
        syntax definition to encode node labels.
  </para>

  <para>
sfix-yield -i file.asfix -o file.txt]

        \ \\ \texttt{Asfix-yield} is an unparser for AsFix files, i.e.,
        it produces the exact text from which the parse tree was derived.


  </para>

  <para>
sglri -p m.tbl -i file.m -o file.asfix]

        \ \\ \texttt{Sglri} is a convenience composition of
        \texttt{sglr} and \texttt{implode-asfix}.

  </para>

 </section>

 <section>
   <title>Signatures</title>

  <para>

sdf-to-sig -i m.def

        \ \\ \texttt{Sdf-to-sig} derives from an SDF syntax definition
        \texttt{m.def} a set of Stratego modules, one for each SDF
        module, with the signatures of the constructors declared in
        the SDF modules.

  </para>

 </section>

 <section>
   <title>Pretty-Printing and Term Visualization</title>

  <para>
ppgen -i m.def -o m.pp]

        \ \\ \texttt{Ppgen} generates from an SDF syntax definition a
        pretty-print table with an entry for each context-free syntax
        production with a constructor annotation. Typically it is
        necessary to edit the pretty-print table to add appropriate
        Box markup to the entries. The result should be saved under
        a different name to avoid overwriting it.

  </para>

  <para>
ast2abox -p m.pp -i file.ast -o file.abox]

        \ \\ \texttt{Ast2abox} maps an abstract syntax tree \texttt{file.ast} to
        an abstract syntax representation \texttt{file.abox} of a Box term based
        on a pretty-print table \texttt{m.pp}.

  </para>

  <para>
abox2text -i file.abox -o file.txt]

        \ \\ \texttt{Abox2text} formats a Box term as ASCII text.
  </para>

  <para>
abox2latex -i file.abox -o file.txt]

        \ \\ \texttt{Abox2latex} formats a Box term as a LaTeX document.


  </para>

  <para>
abox2html -i file.abox -o file.txt]

        \ \\ \texttt{Abox2html} formats a Box term as an HTML document.
  </para>

  <para>
pp-aterm]

        \ \\ \texttt{Pp-aterm} formats an ATerm as an ATerm in text
        format, adding newlines and indentation to make the structure
        of the term understandable. This is a useful tool to inspect
        terms while debugging transformations.

  </para>

  <para>
term-to-dot -i file.trm -o file.dot (--tree | --graph)]

        \ \\ \texttt{Term-to-dot} is another visualization tool for
        terms that creates a \texttt{dot} graph representation, which
        can be visualized using the \texttt{dot} tool from the
        graphviz graph layout package. \texttt{Term-to-dot} can
        produce an expanded tree view (\texttt{--tree}), or a directed
        acyclic graph view (\texttt{--graph}) preserving the maximal
        sharing in the term. This tool was used to produce the tree
        visualizations in this chapter.

  </para>
 </section>

</section>

</chapter>
