
<chapter xml:id="tutorial-software-transformation-systems"
   xmlns="http://docbook.org/ns/docbook"
   xmlns:xi="http://www.w3.org/2003/XInclude">

  <title>Software Transformation Systems (*)</title>

<section>
  <title>What is Software Transformation?</title>

  <para>
    Imagine finding yourself in the a situation where you have a
    collection of files containing source code. If this is an
    unreasonable prospect for you, stop reading and pick another
    tutorial. If you are still with us, consider these files the
    blueprints for your software.  They are still not the
    award-winning, executable program you are aiming for, but by
    applying a compiler to them, you can generate one (with some minor
    provisions about syntactial and semantical correctness). If so
    inclined, you may also run a documentation generator like Javadoc
    on the source, to generate structured documentation. Or, while
    colleagues are not looking, you can secretly invoke tools like
    <command>lint</command> (C/C++) or FindBugs (Java) to weed out
    common programming errors.
  </para>
  
  <para>
    The compilation, documentation generation and source-code analysis
    are all examples of <emphasis>software transformations
    </emphasis>, but they are certainly not the only ones. Software
    transformation has been used by the mathematically inclined for
    generating programs from high-level specifications, by forgetful
    people to recover lost design and architecture from legacy code
    and by reverse-engineers to obtain high-level, readable code from
    binary files after somebody accidentally misplaced a stack of
    backup tapes. Specialization of a program to known inputs in order
    to improve performance, optimization using domain knowledge from
    the application domain and improving program understanding by
    analysing sources are also favoured topics among software
    transformers.
  </para>

  <para>
    But who uses software transformation, anyway? People with a
    problem resembling any in <xref linkend="Fig-Applications"/>
    are. All too often, Real Programmers with such a problem have the
    opinion that software transformation is overly complicated dark
    magic, and that simple regular expression hacks solve the problem
    just fine. Almost equally often, their ad-hoc, text-based
    solutions turn out to be brittle, overly complicated and acquire a
    status of dark magic, with the result that no other team member
    dears touch the stuff. Most of the time, the problem would be
    easily solved in a maintainable and robust way if only the right
    tool could be found.
  </para>

  <figure xml:id="Fig-Applications">
    <title>
      Applications of Program Transformation. (*)
    </title>
  <screen>
Compilers 
- translation   
- desugaring  
- instruction selection 
  - maximal munch
  - burg-style dynamic programming
- optimization 
  - data-flow optimizations
  - vectorization
  - ghc-style simplification
  - deforestation
  - domain-specific optimization (codeboost)
  - partial evaluation   
- typechecking   
- specialization of dynamic typing

Program generators
- pretty-printer and signature generation from syntax definitions
- application generation from DSL (Java, C++) 

Program migration
- grammar conversion (yacc to sdf, ...)

Program understanding
- documentation generation 

Document generation/transformation 
- Web/XML programming (server-side  scripts )
  </screen>
  </figure>
  
  <para>
    So what do should you do if you have a mountain of source code
    that you have to do some transformation on? Obviously, using the
    the right tool for the job is a good start. We don't recommend
    using toothpicks to move software mountains. Instead, we think
    using Stratego for this is a good idea. In this tutorial, we will
    use small, understandable and cute examples that you can try out
    in the leisure of your own desktop. We hope these will convince
    you exactly how good an idea using Stratego for software
    transformation really is.
  </para>

</section>

<section>
  <title>What is Stratego/XT?</title>

  <para>
    A program transformation system is usually organized as a simple
    pipeline of transformation steps. At the source of the pipeline
    (far left), a parser reads the text of the input program and turns
    it into a parse tree or abstract syntax tree. Subsequently, one or
    several transformations components modify the tree. At the sink of
    the pipeline (far right), a pretty-printer turns the output tree
    into program text. <xref linkend="Fig-Pipeline"/> plots these
    components in on the map of a Transformation System. Of course,
    the output program need not be in the same language as the input
    program. It need not even be a programming language.
  </para>

  <figure xml:id="Fig-Pipeline">
    <title>
      Pipeline of a software transformation system.
    </title>
    <pngobject fileref="pipe.png" align="center"/>
  </figure>

  <para>
    So, what is Stratego/XT? Stratego/XT combines Stratego, a language
    for implementing program transformations, and XT, a collection of
    transformation tools. The Stratego language is a powerful language
    for implementing the core transformations of a complete
    transformation system. The XT tools help with the implementation
    of the infrastructure required around these core transformations,
    such as a parser and a pretty-printer.
  </para>

  <para>
    Stratego and XT aims at better productivity in the development of
    transformation systems through the use of a high-level
    representations of programs, domain-specific languages for the
    development of parts of a transformation system, and generating
    various aspects of a transformation system automatically.
  </para>

  <variablelist>
    <para>
      The main ingredients of Stratego/XT are:
    </para>

    <varlistentry>
      <term>ATerm Format</term>
      <listitem>
	<para>
	  For the structured representation of a program.
	</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Stratego Language</term>
      <listitem>
	<para>
	  For implementing program transformations.
	</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>SDF Language</term>
      <listitem>
	<para>
	  For modular, concise, definition of the syntax of a
	  language. Parsers can be fully generated from SDF.
	</para>
      </listitem>
    </varlistentry>


    <varlistentry>
      <term>GPP and the Box Language</term>
      <listitem>
	<para>
	  For generating and implementing pretty-printers.
	</para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>XTC</term>
      <listitem>
	<para>
	  For composing individual transformation tools into a
	  complete transformation systems.
	</para>
      </listitem>
    </varlistentry>
  </variablelist>

  <para>
    Exactly what all this means will become clear to you as we move
    along in this tutorial.
  </para>
</section>
  
<section>
  <title>Outline</title>

  <!-- TODO: outline must be updated -->
  <para>
    The rest of this tutorial is organized as follows. First, we will
    discuss how we represent programs in Stratego/XT. Afterwards, we
    will discuss the Stratego language itself, which our primary tool
    for manipulating the programs. We will then cover how to construct
    parsers using the syntax definition formalism SDF.  We round off
    with a brief guide to the most important tools in the XT toolkit.
  </para>
  
</section>

<section>
  <title>Components for Transformation Systems</title>

  <para>

    In this section we discuss the main concepts and components
    involved in the implementation of transformation systems with
    Stratego/XT.
    
  </para>

  <section>
    <title>ATerms: Program Representation</title>

    <para>

      Although some transformation systems work directly on text, in
      general a textual representation is not adequate for performing
      complex transformations.  Therefore, a structured representation
      is used by most systems.  Since programs are written as texts by
      programmers, parsers are needed to convert from text to
      structure and unparsers are needed to convert structure to text.

    </para>
  
    <para>

      The basic assumptions in our approach are that programs can be
      represented as terms and that term rewrite rules are an
      excellent way to formalize transformations on programs.

      Stratego uses the Annotated Term Format, or ATerms for short, as
      term representation.

      The Stratego run-time system is based on the ATerm Library which
      provides support for internal term representation as well as
      their persistent representation in files.

      This makes it easy to provide input and output for terms in
      Stratego, and to exchange terms between transformation tools.

    </para>

  </section>

  <section>
    <title>SDF: Syntax Definition</title>

    <para>

      Converting program texts to terms for transformations requires
      parsers. Since Stratego programs operate on terms, they do not
      particularly care about the implementation of parsers. Thus,
      parsers can be implemented with any parsing technology, or terms
      can be produced by an existing compiler front-end. In practice,
      Stratego is mostly used together with the syntax definition
      formalism SDF. The Stratego compiler itself uses SDF to parse
      Stratego programs, and many Stratego applications have been
      developed with SDF as well.
 
    </para>

    <para>

      The syntax definition formalism SDF supports high-level,
      declarative, and modular definition of the syntax of programming
      languages and data formats. The formalism integrates the
      definition of lexical and context-free syntax.  The modularity
      of the formalism implies that it is possible to easily combine
      two languages or to embed one language into another.

    </para>

  </section>

  <section>
    <title>GPP: Pretty-printing</title>
	
    <para>

      Stratego/XT uses the pretty-printing model provided by the
      Generic Pretty-Printing package GPP. In this model a tree is
      unparsed to a Box expression, which contains text with markup
      for pretty-printing. A Box expression can be interpreted by
      different back-ends to produce formatted output for different
      displaying devices such as plain text, HTML, and LATEX.

    </para>

  </section>

  <section>
    <title>Stratego: Transformation Strategies</title>

    <para>

      Stratego is the core of Stratego/XT. It is a language for
      program transformation based on the paradigm of rewriting
      strategies. Basic transformations are defined using conditional
      term rewrite rules. These are combined into full fledged
      transformations by means of strategies, which control the
      application of rules.

    </para>

    <para>

      Term rewrite systems are formalisations of systematic
      modifications of terms or trees. A rewrite rule describes how a
      program fragment matching a certain pattern is transformed into
      another program fragment. Term rewriting is the exhaustive
      application of a set of rules to a term.

    </para>

    <para>

      A complex program transformation is achieved through a number of
      consecutive modifications of a program.  At least at the level
      of design it is useful to distinguish transformation rules from
      transformation strategies.  A rule defines a basic step in the
      transformation of a program.  A strategy is a plan for achieving
      a complex transformation using a set of rules.

    <includefile 
        id="demos-sample-rules-str"
        root="../../examples"
        file="sample-rules.str" />

      For example, consider the transformation rules above. The Inline
      rules define inlining of function and variable definitions. The
      Dead rule eliminates an unused variable definition. The Extract
      rule abstracts an expression into a function. The Hoist rule
      defines lifting a function definition out of a variable
      definition if the variable is not used in the function. Using
      this set of rules, different transformations can be
      achieved. For example, a constant propagation strategy in an
      optimizer could use the InlineV and Dead rules to eliminate
      constant variable definitions:

<screen>
   let x = 3 in x + y  ->  let x = 3 in 3 + y  ->  3 + y
</screen>
        On the other hand, the ExtractFunction strategy in a
        refactoring browser could use the Extract and
        Hoist rules to abstract addition with y into a
        new function and lift it to top-level.
<screen>
  let x = 3 in x + y
  -> let x = 3 in let addy(z) = z + y in addy(x)
  -> let addy(z) = z + y in let x = 3 in addy(x)
</screen>

      Rules can be applied interactively by a programmer via a
      graphical user interface.  The problem with such manipulations
      is that the transformation is not reproducible, since the
      decisions have not been recorded.  By automating the
      transformation process, a series of basic transformations can be
      repeatedly applied to a program. By generalizing the sequence of
      transformations the combined transformation can be applied to
      many programs.  This requires a mechanism for combining rules
      into more complex transformations.

    </para>
  
    <para>
  
      Pure term rewriting is not adequate for the implementation of
      program transformation systems, since most rewrite systems are
      non-confluent and/or non-terminating. Hence, standard rewriting
      strategies are not applicable.  The paradigm of programmable
      rewriting strategies solves this problem by supporting the
      definition of strategies adapted to a specific transformation
      system. This makes it possible to select which rule to apply in
      which transformation stage, and using which traversal order.

    </para>
  
  </section>

  <section>
    <title>XT: Transformation Tools</title>

    <para>

	XT is a collection of transformation tools providing support
	for the generation of many infrastructural aspects of program
	transformation systems, including parsers, pretty-printers,
	parenthesizers, and format checkers. 

    </para>

  </section>

  <section>
    <title>XTC: Transformation Tool Composition</title>

    <para>

      Parsers, pretty-printers, and transformations can be
      encapsulated in separate executable components, which can be
      reused in multiple transformation systems. Composition of such
      components is facilitated by the XTC transformation tool
      composition library.

      Initially this tutorial uses separate components that are glued
      using shell scripts, in order to improve the understanding of
      the separate components. The use of XTC is introduced later on.

    </para>
  
  </section>
</section>

</chapter>
