<section
   xmlns="http://docbook.org/ns/docbook"
   xmlns:xi="http://www.w3.org/2003/XInclude">

  <title>Examples: Defining Context-Free Syntax</title>

  <para>
    Context-free syntax in SDF is syntax where layout is allowed
    between the symbols of the productions. Context-free syntax can be
    defined in a natural way, thanks to the use of generalized-LR
    parsing, declarative disambiguation mechanism, and an extensive
    set of regular expression operators. To illustrate the definition
    of context-free syntax, we give examples of defining expressions
    and statements. Most of the time will be spend on explaining the
    disambiguation mechanisms.
  </para>

  <section>
    <title>Expressions</title>

    <para>
      In the following sections, we will explain the details of a
      slightly extended version of the SDF modules in <xref
      linkend="ex-basic-module"/>, shown in <xref
      linkend="xmpl-sdf-expression-modules"/>.
    </para>

    <example xml:id='xmpl-sdf-expression-modules'>
      <title>Syntax of Small Expression Language in SDF</title>

    <programlisting>
module Expression
imports
  Lexical Operators

exports
  context-free start-symbol Exp
  context-free syntax
    Id          -> Exp {cons("Var") <co xml:id="xmpl-cf-cons1"/>}
    IntConst    -> Exp {cons("Int")}
    "(" Exp ")" -> Exp {bracket <co xml:id="xmpl-cf-bracket"/>}

module Operators
exports
  sorts Exp
  context-free syntax
    "-" Exp     -> Exp {cons("UnaryMinus")}
    Exp "*" Exp -> Exp {cons("Times"), left <co xml:id="xmpl-cf-assoc-left"/>}
    Exp "/" Exp -> Exp {cons("Div"), left}
    Exp "%" Exp -> Exp {cons("Mod"), left}
  
    Exp "+" Exp -> Exp {cons("Plus") <co xml:id="xmpl-cf-cons2"/>, left}
    Exp "-" Exp -> Exp {cons("Minus"), left}

    Exp "=" Exp -> Exp {cons("Eq"), non-assoc <co xml:id="xmpl-cf-non-assoc"/>}
    Exp ">" Exp -> Exp {cons("Gt"), non-assoc}

  context-free priorities <co xml:id='xmpl-cf-priorities' />
       "-" Exp -> Exp <co xml:id="xmpl-cf-priority-prod"/>
    > {left: <co xml:id="xmpl-cf-group-left"/>
        Exp "*" Exp -> Exp
        Exp "/" Exp -> Exp
        Exp "%" Exp -> Exp
      } 
    > {left: 
        Exp "+" Exp -> Exp
        Exp "-" Exp -> Exp
      }
    > {non-assoc: <co xml:id="xmpl-cf-group-non-assoc"/>
        Exp "=" Exp -> Exp
        Exp ">" Exp -> Exp
      }</programlisting>
    </example>
  </section>

  <section>
    <title>Constructor Attributes</title>

    <para>
      cons
    </para>

    <para>
      bracket
    </para>
  </section>

  <section>
    <title>Ambiguities in Expressions</title>

    <para>
      Syntax definitions in the style of <xref
      linkend="Fig-test1-acub"/> are <emphasis>ambiguous</emphasis>,
      i.e., there is more than one way to map strings to trees. For
      example, the string <code>a+b*c</code> has two possible
      derivations, as shown in <xref linkend="Fig-ambiguities"/>.
    </para>

    <programlisting>
  AddExp -> Exp

  MulExp -> AddExp
  AddExp "+" MulExp -> AddExp {cons("Plus")}
  AddExp "-" MulExp -> AddExp {cons("Minus")}

  PrimExp -> MulExp
  MulExp "*" PrimExp -> MulExp {cons("Mul")} 
  MulExp "/" PrimExp -> MulExp {cons("Div")}

  IntConst -> PrimExp {cons("Int")}
  Id       -> PrimExp {cons("Var")}</programlisting>
    
    <example xml:id="Fig-ambiguities">
      <title>
	Parses for the string <code>a+b*c</code>
      </title>
	<nexttoeachother>
	  <entry>
	    <pngobject fileref="xmpl/test5-acub.png" align="center"/>
	  </entry>
	  <entry>
	    <pngobject fileref="xmpl/test4-acub.png" align="center"/>
	  </entry>
	</nexttoeachother>
    </example>
  </section>

  <section>
    <title>Associativity and Priorities</title>

    <para>
      In plain context-free grammars such ambiguities are solved by
      introducing additional non-terminals and productions. This
      results in much more complex parse trees and increases the
      distance between parse trees and abstract syntax trees. In order
      to support natural syntax definitions, SDF provides several
      declarative disambiguation mechanismqs. Associativity
      declarations (<code>left</code>, <code>right</code>,
      <code>non-assoc</code>), disambiguate combinations of a binary
      operator with itself and with other operators. Thus, the left
      associativity of <code>+</code> entails that <code>a+b+c</code>
      is parsed as <code>(a+b)+c</code>. Priority declarations
      (<code>></code>) declare the relative priority of productions. A
      production with lower priority cannot be a direct subtree of a
      production with higher priority. Thus <code>a+b*c</code> is
      parsed as <code>a+(b*c)</code> since the other parse
      <code>(a+b)*c</code> has a conflict between the <code>*</code>
      and <code>+</code> productions.
    </para>
    
    <programlisting>
  ...
> Exp "&amp;"  Exp -> Exp
> Exp "^"  Exp -> Exp
> Exp "|"  Exp -> Exp
> Exp "&amp;&amp;" Exp -> Exp
> Exp "||" Exp -> Exp
> ... </programlisting>

    <section>
      <title>Group Associativity</title>
      <para/>
    </section>
    
    <section>
      <title>Priorities and Hedged Symbols</title>
      <para/>
      <para>
	Solution: introduce an auxiliary non-terminal
      </para>
    </section>
  </section>

  <section>
    <title>Array Creation and Access Ambiguity</title>
    
    <para>
      This is usually handled with introducing a new non-terminal.
    </para>
    
    <programlisting>
context-free syntax
  "new" ArrayBaseType DimExp+ Dim*  -> ArrayCreationExp {cons("NewArray")}

  Exp "[" Exp "]" -> Exp {cons("ArrayAccess")}
  ArrayCreationExp "[" Exp "]" -> Exp {reject}</programlisting>
  </section>
  
  <section>
    <title>Statements</title>
    
    <para>
      <xref linkend="Fig-RegularExpressions"/> illustrates the use of
      these operators in the extension of the expression language with
      statements and function declarations. Lists are used in numerous
      places, such as for the sequential composition of statements
      (<code>Seq</code>), the declarations in a let binding, and the
      formal and actual arguments of a function (<code>FunDec</code>
      and <code>Call</code>). An example function definition in this
      language is:
    </para>

    <figure xml:id="Fig-RegularExpressions">
      <title>
	Syntax definition with regular expressions.
      </title>
      <showfile root="." file="xmpl/Statements.sdf"/>
    </figure>

    <screen>
function fact(n, x) =
  if n > 0 then fact(n - 1, n * x) else x</screen>

    <section>
      <title>Dangling Else</title>
      <para/>
    </section>
  </section>

  <section>
    <title>Whitespace and Comments</title>

<programlisting>
context-free restrictions
  LAYOUT? -/- [\ \t\12\n\r]</programlisting>

    <para>
      Why follow restrictions on whitespace is necessary
    </para>

<programlisting>
context-free restrictions
  LAYOUT?  -/- [\/].[\*]
  LAYOUT?  -/- [\/].[\/]</programlisting>
  </section>
</section>