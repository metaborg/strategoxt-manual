<chapter xml:id="tutorial-sdf"
   xmlns="http://docbook.org/ns/docbook"
   xmlns:xi="http://www.w3.org/2003/XInclude">

  <title>Syntax Definition and Parsing</title>

  <para>
    In <xref linkend="xt-architecture"/> we have introduced the
    architecture of the XT tansformation tools. Source to source
    transformation systems based on XT consist of a pipeline of a
    parser, a series of transformations on a structured program
    representation, and a pretty-printer. In <xref
    linkend="tutorial-aterms"/> we have explained the ATerm format,
    which is the format we use for this structured program
    transformation. This chapter will be about the parser part of the
    pipeline.
  </para>

  <para>
    Stratego/XT uses the <emphasis>Syntax Definition Formalism
    (SDF)</emphasis>, for defining the syntax of a programming
    language. From a syntax definition in SDF, a parser can be
    generated fully automatically. There is no need for a separate
    lexer or scanner specification, since SDF integrates the lexical
    and the context-free syntax definition of a programming language
    in a single specification. The generated parser is based on the
    <emphasis>Scannerless Generalized-LR</emphasis> algorithm, but
    more details about that later. The parser directly produces an
    ATerm representation of the program, as a parse tree, or as an
    abstract syntax tree.
  </para>

  <para>
    Actually, the component-based approach of XT allows you to use any
    technique for parsing a source program to an ATerm. So, you don't
    necessarily have to use the parsing techniques we present in this
    chapter. Instead, it might sometimes be a good idea to create an
    ATerm backend for a parser that you already have developed (by
    hand or using a different parser generator), or reuse an existing
    front-end that is provided by a third-party. However, the
    techniques we present in this chapter are extremely expressive,
    flexible, and easy to use, so for developing a new parser it would
    be a very good idea to use SDF and SGLR.
  </para>

  <xi:include href="concepts.xml" />

  <section>
    <title>Pratical: Generating and Using a Parser</title>

    <para>
      Before we dive into the details of SDF, let's try to ...
    </para>

    <formalpara>
      <title><link linkend="ref-sdf2table"><code>
	sdf2table -i m.def -o m.tbl -m M
      </code></link></title>
      
      <para>
	<code>Sdf2table</code> is the parser generator for SDF. It takes
	a complete syntax definition <code>m.def</code> (as produced by
	  <code>pack-sdf</code>), and produces a parse table
	  <code>m.tbl</code> in ATerm format. By default a parse table is
	  generated for module <code>Main</code>; this can be overridden
	  using the <code>-m</code> option.
      </para>
    </formalpara>

      <formalpara>
	<title><link linkend="ref-sglr"><code>
	  sglr -p m.tbl -i file.m -o file.asfix -2
	</code></link></title>
	
	<para>
	  <code>sglr</code> is the parser for SDF. It takes as
	  arguments a parse table <code>m.tbl</code> and an input file
	  <code>file.m</code>, presumably in the language described by
	  <code>m.def</code>. The parser produces a parse tree in the
	  AsFix format. If option <code>-2</code> is produced, the
	  tree is in the specific AsFix2 format, which is what
	  Stratego/XT tools use.  The AsFix2 format is a complete and
	  faithful representation of the derivation constructed by the
	  parser. It includes all details of the input file, including
	  whitespace, comments, and is self documenting as it uses the
	  complete productions of the syntax definition to encode node
	  labels.
	</para>
      </formalpara>

  <formalpara>
    <title><link linkend="ref-implode-asfix"><code>
       implode-asfix -i file.asfix -o file.trm
    </code></link></title>

    <para>

      <code>implode-asfix</code> transforms an AsFix parse tree to an
      abstract syntax tree.

    </para>

  </formalpara>


  <formalpara>
    <title><link linkend="ref-asfix-yield"><code>
       asfix-yield -i file.asfix -o file.txt
    </code></link></title>

    <para>

      <code>asfix-yield</code> is an unparser for AsFix files, i.e.,
      it produces the exact text from which the parse tree was
      derived.

    </para>

  </formalpara>

  </section>
  
  <section>
    <title>SDF: The Syntax Definition Formalism</title>
    
    <para>
      Note: there is already a lot of explanation in the TIL syntax
      example.
    </para>
    
    <section>
      <title>Modules</title>

      <para>
	Little bit about SDF, refer to SDF maual for more details.
      </para>

      <para>
	Renamings
      </para>
    </section>

    <section>
      <title>Generating a Parser</title>

      
      <para>
	sglri, options
      </para>

      <formalpara>
	<title><link linkend="ref-pack-sdf"><code>
	  pack-sdf -i m.sdf -o m.def -I dir
	</code></link></title>
	
	<para>
	  An SDF syntax definition consists of a set of
	  modules. <code>pack-sdf</code> collects all modules imported
	  by module <code>m</code> in file <code>m.sdf</code> and
	  creates a combined syntax definition in file
	  <code>m.def</code>. Modules are looked for in the current
	  directory and any of the include directories indicated with
	  the <code>-I dir</code> arguments.
	</para>
      </formalpara>

      <formalpara>
	<title><link linkend="ref-sglri"><code>
	  sglri -p m.tbl -i file.m -o file.asfix
	</code></link></title>
	
	<para>
	  <code>Sglri</code> is a convenience composition of
	  <code>sglr</code> and <code>implode-asfix</code>.
	</para>
      </formalpara>
    </section>

    <section>
      <title>Lexical Syntax</title>
      
      <para>
	So far we have looked at syntax of expressions and statements,
	but not at the definition of lexical items such as identifiers
	and constants. In most syntax definition formalisms these are
	defined separately to generate a scanner which divides a
	string into tokens before the parser recognizes the
	context-free structure.
      </para>
      
      <para>
	In SDF the definition of lexical and context-free syntax are
	integrated in the same formalism, and are specified using the
	same means, i.e., context-free productions, regular
	expressions, etc. Productions for lexical items are introduced
	using the keywords <code>lexical syntax</code>. The only
	difference between lexical and context-free syntax is that
	layout (whitespace, comments) can occur between the strings
	corresponding to sorts in the left-hand of a context-free
	production, or, conversely, <emphasis>no</emphasis> layout is
	allowed between the tokens of a lexeme. The occurrence of
	layout is indicated by injecting <code>LAYOUT?</code>, i.e.,
	optional layout, between every two symbols of a context-free
	production. To avoid cluttering syntax definitions, this is
	done automatically by the SDF parser generator.
      </para>

      <para>
	In order to define the syntax at the level of characters, SDF
	provides character classes <code>[...]</code>, which generate
	one character from the set. Letters and digits can be written
	as themselves, all other characters should be escaped using a
	slash, e.g. <code>\_</code>. Characters can also be indicated
	by their decimal ASCII\footnote{These codes could also be
	interpreted in a different character encoding.} code, e.g.,
	<code>\13</code> for linefeed. Some often used non-printable
	characters have more mnemonic names, e.g., <code>\n</code> for
	newline, <code>\ </code> for space and <code>\t</code> for
	tab.
      </para>
      
      <para>
	The definition of lexical syntax with a context-free grammar,
	gives rise to ambiguities that cannot be resolved with the
	associativity and priority mechanisms shown earlier. SDF
	provides two additional disambiguation mechanism for this
	purpose. A follow restriction \texttt{A -/- cc1 . ... . ccn}
	indicates that a string of sort A cannot be followed by a
	string in <code>cc1 ... ccn</code>, where the <code>cc</code>
	are character classes. Follow restrictions can be used to
	encode longest match disambiguation. A reject production
	<code>A1 ... An -> A0 {reject}</code> forbids an
	<code>A0</code> if it can also be parsed as <code>A1
	... An</code>. Reject productions are typically used to
	specify reserved words, by rejecting them as identifiers.
      </para>

      <section>
	<title>Layout: Whitespace and Comments</title>
	<para/>
      
	<para>
	  These concepts are illustrated in <xref
	  linkend="Fig-LexicalSyntax"/>, which defines the lexical syntax of
	  identifiers, integer constants, and C-style comments. Note how
	  follow restrictions are used for longest match disambiguation of
	  identifiers, integer constants, and layout. Since an identifier
	  cannot be followed by a letter, the <code>a</code> in
	  <code>ab</code> cannot be recognized as an identifier by itself,
	  only the entire string <code>ab</code>.  Restrictions are also
	  used to define that a sole asterisk within a C style comment
	  should not be followed by a slash (which would end the comment). A
	  reject production is used to forbid the use of keywords as
	  identifiers.
	</para>
      
	<figure xml:id="Fig-LexicalSyntax">
	  <title>
	    Definition of lexical syntax.
	  </title>
	  <showfile root="." file="xmpl/Lexical.sdf"/>
	</figure>
      </section>
    </section>
  </section>

  <section>
    <title>Context-free Syntax</title>

    <section>
      <title>Regular Expressions</title>
      
      <para>
	Programming languages usually contain all kinds of list
	constructs. Specification of lists with plain context-free
	grammars requires several productions for each list construct.
	SDF provides a bunch of regular expression operators abbreviating
	common patterns. The operators <code>A*</code> and
	<code>A+</code> denote lists of zero (one) or more
	<code>A</code>s.  The <code>{A lit}*</code> and <code>{A
	lit}+</code> operators denote lists of zero (one) or more
	<code>A</code>s separated by <code>lit</code>.
      </para>
      
      <para>
	<xref linkend="Fig-RegularExpressions"/> illustrates the use of
	these operators in the extension of the expression language with
	statements and function declarations. Lists are used in numerous
	places, such as for the sequential composition of statements
	(<code>Seq</code>), the declarations in a let binding, and the
	formal and actual arguments of a function (<code>FunDec</code>
	and <code>Call</code>). An example function definition in this
	language is:

<screen>
function fact(n, x) =
  if n > 0 then fact(n - 1, n * x) else x
</screen>

      </para>

      <figure xml:id="Fig-RegularExpressions">
	<title>
	  Syntax definition with regular expressions.
	</title>
	<showfile root="." file="xmpl/Statements.sdf"/>
      </figure>
    </section>
  
    <section>
      <title>Disambiguation</title>
      
      <para>
	Syntax definitions in the style of <xref
	linkend="Fig-test1-acub"/> are <emphasis>ambiguous</emphasis>,
	i.e., there is more than one way to map strings to trees. For
	example, the string <code>a+b*c</code> has two possible
	derivations, as shown in <xref linkend="Fig-ambiguities"/>.
      </para>
      
      <figure xml:id="Fig-ambiguities">
	<title>
	  Parses for the string <code>a+b*c</code>
	</title>
	<nexttoeachother>
	  <entry>
	    <pngobject fileref="xmpl/test5-acub.png" align="center"/>
	  </entry>
	  <entry>
	    <pngobject fileref="xmpl/test4-acub.png" align="center"/>
	  </entry>
	</nexttoeachother>
      </figure>


      <section>
	<title>Associativity</title>
      
	<para>
	  In plain context-free grammars such ambiguities are solved
	  by introducing additional non-terminals and
	  productions. This results in much more complex parse trees
	  and increases the distance between parse trees and abstract
	  syntax trees. In order to support natural syntax
	  definitions, SDF provides several declarative disambiguation
	  mechanismqs. Associativity declarations (<code>left</code>,
	  <code>right</code>, <code>non-assoc</code>), disambiguate
	  combinations of a binary operator with itself and with other
	  operators. Thus, the left associativity of <code>+</code>
	  entails that <code>a+b+c</code> is parsed as
	  <code>(a+b)+c</code>. Priority declarations (<code>></code>)
	  declare the relative priority of productions. A production
	  with lower priority cannot be a direct subtree of a
	  production with higher priority. Thus <code>a+b*c</code> is
	  parsed as <code>a+(b*c)</code> since the other parse
	  <code>(a+b)*c</code> has a conflict between the
	  <code>*</code> and <code>+</code> productions.
	</para>
	
	<figure xml:id="Fig-Expressions.sdf">
	  <title>
	    Syntax definition with associativity and priority declarations.
	  </title>
	  <showfile root="." file="xmpl/Expressions.sdf"/>
	</figure>
      </section>

      <section>
	<title>Priorities</title>
	<para/>
      </section>

      <section>
	<title>Follow Restrictions</title>
	<para/>
	<section>
	  <title>Example: ++</title>
	  <para/>
	</section>
      </section>

      <section>
	<title>Reject Productions</title>
	<para/>
	<section>
	  <title>Example: No New Array</title>
	  <para/>
	</section>
      </section>

      <section>
	<title>Avoid and Prefer Productions</title>
	<para/>
	<section>
	  <title>Example: Dangling Else</title>
	  <para/>
	</section>
      </section>
    </section>
  </section>
    
  <xi:include href="parse-unit/section.xml"/>
</chapter>
