<chapter xml:id="tutorial-sdf"
   xmlns="http://docbook.org/ns/docbook"
   xmlns:xi="http://www.w3.org/2003/XInclude">

  <title>Syntax Definition and Parsing (*)</title>

  <para>
    In <xref linkend="xt-architecture"/> we have introduced the
    architecture of the XT tansformation tools. Source to source
    transformation systems based on XT consist of a pipeline of a
    parser, a series of transformations on a structured program
    representation, and a pretty-printer. In <xref
    linkend="tutorial-aterms"/> we have explained the ATerm format,
    which is the format we use for this structured program
    transformation. This chapter will be about the parser part of the
    pipeline.
  </para>

  <para>
    Stratego/XT uses the <emphasis>Syntax Definition Formalism
    (SDF)</emphasis>, for defining the syntax of a programming
    language. From a syntax definition in SDF, a parser can be
    generated fully automatically. There is no need for a separate
    lexer or scanner specification, since SDF integrates the lexical
    and the context-free syntax definition of a programming language
    in a single specification. The generated parser is based on the
    <emphasis>Scannerless Generalized-LR</emphasis> algorithm, but
    more details about that later. The parser directly produces an
    ATerm representation of the program, as a parse tree, or as an
    abstract syntax tree.
  </para>

  <para>
    Actually, the component-based approach of XT allows you to use any
    tool for parsing a source program to an ATerm. So, you don't
    necessarily have to use the parsing tools we present in this
    chapter. Instead, it might sometimes be a good idea to create an
    ATerm backend for a parser that you already have developed (by
    hand or using a different parser generator), or reuse an entire,
    existing front-end that is provided by a third-party. However, the
    techniques we present in this chapter are extremely expressive,
    flexible, and easy to use, so for developing a new parser it would
    be a very good idea to use SDF and SGLR.
  </para>

  <xi:include href="concepts.xml" />
  <xi:include href="practice.xml" />
  <xi:include href="modules.xml" />

  <section>
    <title>Syntax</title>

    <section>
      <title>Lexical and Context-free Syntax</title>

      <para>
	Everything defined using productions.
      </para>

      <para>
	Difference between lexical and context-free syntax.
      </para>

      <para>
	In SDF the definition of lexical and context-free syntax are
	integrated in the same formalism, and are specified using the
	same means, i.e., context-free productions, regular
	expressions, etc. Productions for lexical items are introduced
	using the keywords <code>lexical syntax</code>. The only
	difference between lexical and context-free syntax is that
	layout (whitespace, comments) can occur between the strings
	corresponding to sorts in the left-hand of a context-free
	production, or, conversely, <emphasis>no</emphasis> layout is
	allowed between the tokens of a lexeme. The occurrence of
	layout is indicated by injecting <code>LAYOUT?</code>, i.e.,
	optional layout, between every two symbols of a context-free
	production. To avoid cluttering syntax definitions, this is
	done automatically by the SDF parser generator.
      </para>
    </section>

    <section>
      <title>Productions and Symbols</title>
      <para/>
    </section>

    <section>
      <title>Regular Expressions</title>

      <para>
	Programming languages usually contain all kinds of list
	constructs. Specification of lists with plain context-free
	grammars requires several productions for each list construct.
	SDF provides a bunch of regular expression operators abbreviating
	common patterns. The operators <code>A*</code> and
	<code>A+</code> denote lists of zero (one) or more
	<code>A</code>s.  The <code>{A lit}*</code> and <code>{A
	lit}+</code> operators denote lists of zero (one) or more
	<code>A</code>s separated by <code>lit</code>.
      </para>
    </section>
  </section>


  <xi:include href="lexical.xml" />
  <xi:include href="context-free.xml" />

  <xi:include href="disambiguation.xml" />

  <section>
    <title>Advanced Topics</title>

    <section>
      <title>Combining Languages</title>
      <para/>
    </section>
    
    <section>
      <title>Advanced Module Features</title>
      
      <section>
	<title>Renaming Symbols</title>
	<para>
	  Import module and rename symbols in the imported definition.
	</para>
	
	<para>
	  Not very common, but heavily used for combining syntax
	  definitions of different language. See concrete object syntax.
	</para>
      </section>
      
      <section>
	<title>Parameterized Modules</title>
	<para>
	  Modules can have formal parameters.
	</para>
	
	<example>
	  <title>Parameterized Module for Regular Expressions</title>
	  <para/>
	</example>
      </section>

      <section>
	<title>Hiding Grammars</title>
	<para/>
    </section>
    </section>

    <section>
      <title>Context-sensitive Lexical Syntax</title>
      <para/>
    </section>

    <section>
      <title>Explicit versus Implicit Ambiguities</title>
      <para/>
    </section>

    <section>
      <title>Performance Tips and Tricks</title>
      <para/>
    </section>
  </section>

  <section>
    <title>SDF Glossary</title>

    <glosslist>
      <glossentry>
	<glossterm>Sort</glossterm>
	<glossdef>
	  <para/>
	</glossdef>
      </glossentry>

      <glossentry>
	<glossterm>Symbol</glossterm>
	<glossdef>
	  <para/>
	</glossdef>
      </glossentry>

      <glossentry>
	<glossterm>Section</glossterm>
	<glossdef>
	  <para/>
	</glossdef>
      </glossentry>
    </glosslist>
  </section>
  
  <xi:include href="parse-unit/section.xml"/>
</chapter>
