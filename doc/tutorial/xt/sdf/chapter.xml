<chapter xml:id="tutorial-sdf"
   xmlns="http://docbook.org/ns/docbook"
   xmlns:xi="http://www.w3.org/2003/XInclude">

  <title>Syntax Definition and Parsing</title>

  <para>
    In <xref linkend="xt-architecture"/> we have introduced the
    architecture of the XT tansformation tools. Source to source
    transformation systems based on XT consist of a pipeline of a
    parser, a series of transformations on a structured program
    representation, and a pretty-printer. In <xref
    linkend="tutorial-aterms"/> we have explained the ATerm format,
    which is the format we use for this structured program
    transformation. This chapter will be about the parser part of the
    pipeline.
  </para>

  <para>
    Stratego/XT uses the <emphasis>Syntax Definition Formalism
    (SDF)</emphasis>, for defining the syntax of a programming
    language. From a syntax definition in SDF, a parser can be
    generated fully automatically. There is no need for a separate
    lexer or scanner specification, since SDF integrates the lexical
    and the context-free syntax definition of a programming language
    in a single specification. The generated parser is based on the
    <emphasis>Scannerless Generalized-LR</emphasis> algorithm, but
    more details about that later. The parser directly produces an
    ATerm representation of the program, as a parse tree, or as an
    abstract syntax tree.
  </para>

  <para>
    Actually, the component-based approach of XT allows you to use any
    technique for parsing a source program to an ATerm. So, you don't
    necessarily have to use the parsing techniques we present in this
    chapter. Instead, it might sometimes be a good idea to create an
    ATerm backend for a parser that you already have developed (by
    hand or using a different parser generator), or reuse an existing
    front-end that is provided by a third-party. However, the
    techniques we present in this chapter are extremely expressive,
    flexible, and easy to use, so for developing a new parser it would
    be a very good idea to use SDF and SGLR.
  </para>

  <section>
    <title>Concepts: Grammars, Parse Trees, and Abstract Syntax Trees</title>

    <para>
      In this section, we review the basics of grammars, parse trees
      and abstract syntax trees. Although you might already be
      familiar with these basic concepts, the perspective from the
      Stratego/XT point of view might still be interesting to read.
    </para>

    <section>
      <title>Context-free Grammars</title>
      
      <para>
	Context-free grammars were originally introduced by Chomsky to
	describe the <emphasis>generation</emphasis> of grammatically
	correct sentences in a language. A context-free grammar is a
	set of <emphasis>productions</emphasis> of the form
	A<subscript>0</subscript> -> A<subscript>1</subscript>
	... A<subscript>n</subscript>, where A<subscript>0</subscript>
	is non-terminal and A<subscript>1</subscript>
	... A<subscript>n</subscript> is a string of terminals and
	non-terminals. From this point of view, a grammar describes a
	language by <emphasis>generating</emphasis> its sentences. A
	string is generated by starting with the start non-terminal
	and repeatedly replacing non-terminal symbols according to the
	productions until a string of <emphasis>terminal</emphasis>
	symbols is reached.
      </para>

      <para>
	A context-free grammar can also be used to
	<emphasis>recognize</emphasis> sentences in the language. In
	that process, a string of terminal symbols is rewritten to the
	start non-terminal, by repeatedly applying grammar productions
	backwards, i.e. reducing a substring matching the right-hand
	side of a production to the non-terminal on the left-hand
	side. In SDF, productions are specified as
	A<subscript>1</subscript> ... A<subscript>n</subscript> ->
	A<subscript>0</subscript>, to emphasize the recognition aspect
	of grammars.
      </para>

      <para>
	As an example, consider the SDF productions for a small
	language of arithmetic expressions in <xref
	linkend="Fig-Expressions-NoCons.sdf"/>, where <code>Id</code>
	and <code>IntConst</code> are terminals and <code>Var</code>
	and <code>Exp</code> are non-terminals. Using this definition,
	and provided that <code>a</code> and <code>n</code> are
	identifiers (<code>Id</code>) and <code>1</code> is an
	<code>IntConst</code>, a string such as <code>(a+n)*1</code>
	can be recognized as an expression by reducing it to
	<code>Exp</code>, as shown by the reduction sequence in the
	<link linkend="Fig-Expressions-NoCons.sdf">right-hand side of
	the figure</link>.
      </para>

      <figure xml:id="Fig-Expressions-NoCons.sdf">
	<title>
	  Context-free productions and a reduction sequence.
	</title>
	<nexttoeachother align="left" valign="top">
	  <entry>
	    <showfile root="." file="xmpl/Expressions-NoCons.sdf"/>
	  </entry>
	  <entry>
	    <showfile root="." file="xmpl/Expressions-NoCons.red"/>
	  </entry>
	</nexttoeachother>
      </figure>
    </section>

    <section>
      <title>Parse Trees</title>
      
      <para>
	Recognition of a string only leads to its grammatical
	category, not to any other information. However, a
	context-free grammar not only describes a mapping from strings
	to sorts, but actually assigns structure to strings.  A
	context-free grammar can be considered as a declaration of a
	set of trees of one level deep. For example, the following
	trees correspond to productions from the syntax definition in
	<xref linkend="Fig-Expressions-NoCons.sdf"/>:

	<informalfigure pgwide="1">
	  <pngobject fileref="Plus.png" align="center"/>
	</informalfigure>
      </para>

      <para>
	<informalfigure pgwide="0">
	  <pngobject fileref="PlusTimes.png" align="right"/>
	</informalfigure>

	Such one-level trees can be composed into larger trees by
	fusing trees such that the symbol at a leaf of one tree
	matches with the root symbol of another, as is illustrated in
	the fusion of the plus and times productions on the right.
	
	The fusion process can continue as long as the tree has
	non-terminal leaves. A tree composed in this fashion is a
	parse tree if all leaves are terminal symbols. <xref
	linkend="Fig-ParseTree"/> shows a parse tree for the
	expression <code>(a+n)*1</code>, for which we showed a
	reduction sequence earlier in <xref
	linkend="Fig-Expressions-NoCons.sdf"/>. This illustrates the
	direct correspondence between a string and its grammatical
	structure. The string underlying a parse tree can be obtained
	by concatening the symbols at its leaves, also known as the
	yield.
      </para>
      
      <figure xml:id="Fig-ParseTree">
	<title>Parse tree</title>
	<pngobject fileref="parse-tree.png" align="left"/>
      </figure>
      
      <para>
	Parse trees can be derived from the reduction sequence induced
	by the productions of a grammar. Each rewrite step is
	associated with a production, and thus with a tree
	fragment. Instead of replacing a symbol with the non-terminal
	symbol of the production, it is replaced with the tree
	fragment for the production fused with the trees representing
	the symbols being reduced. Thus, each node of a parse tree
	corresponds to a rewrite step in the reduction of its
	underlying string. This is illustrated by comparing the
	reduction sequence in <xref
	linkend="Fig-Expressions-NoCons.sdf"/> with the tree in <xref
	linkend="Fig-ParseTree"/>
      </para>

      <para>
	The recognition of strings described by a syntax definition,
	and the corresponding construction of parse trees can be done
	automatically by a parser, which can be generated from the
	productions of a syntax definition.
      </para>
    </section>
    
    <section>
      <title>Abstract Syntax Trees</title>
      
      <para>
	Parse trees contain all the details of a program including
	literals, whitespace, and comments.  This is usually not
	necessary for performing transformations.  A parse tree is
	reduced to an <emphasis>abstract syntax tree</emphasis> by
	eliminating irrelevant information such as literal symbols and
	layout.  Furthermore, instead of using sort names as node
	labels, <emphasis>constructors</emphasis> encode the
	production from which a node is derived. For this purpose, the
	productions in a syntax definition are extended with
	<emphasis>constructor annotations</emphasis>.  <xref
	linkend="Fig-test1-acub"/> shows the extension of the syntax
	definition from <xref linkend="Fig-Expressions-NoCons.sdf"/>
	with constructor annotations and the abstract syntax tree for
	the string <code>(a+n)*1</code>. Note that some identifiers
	are used as sort names <emphasis>and</emphasis> and as
	constructors. This does not lead to a conflict since sort
	names and constructors are derived from separate name spaces.
      </para>

     
      <figure xml:id="Fig-test1-acub">
	<title>
	  Context-free productions with constructor annotations and an
	  abstract syntax tree.
	</title>
	<nexttoeachother>
	  <entry><showfile root="." file="xmpl/Expressions-Cons.sdf"/></entry>
	  <entry><pngobject fileref="xmpl/test1-acub.png" align="center"/></entry>
	</nexttoeachother>
      </figure>
    </section>
  </section>

  <section>
    <title>Pratical: Generating and Using a Parser</title>

    <para>
      Before we dive into the details of SDF, let's try to ...
    </para>

    <formalpara>
      <title><link linkend="ref-sdf2table"><code>
	sdf2table -i m.def -o m.tbl -m M
      </code></link></title>
      
      <para>
	<code>Sdf2table</code> is the parser generator for SDF. It takes
	a complete syntax definition <code>m.def</code> (as produced by
	  <code>pack-sdf</code>), and produces a parse table
	  <code>m.tbl</code> in ATerm format. By default a parse table is
	  generated for module <code>Main</code>; this can be overridden
	  using the <code>-m</code> option.
      </para>
    </formalpara>

      <formalpara>
	<title><link linkend="ref-sglr"><code>
	  sglr -p m.tbl -i file.m -o file.asfix -2
	</code></link></title>
	
	<para>
	  <code>sglr</code> is the parser for SDF. It takes as
	  arguments a parse table <code>m.tbl</code> and an input file
	  <code>file.m</code>, presumably in the language described by
	  <code>m.def</code>. The parser produces a parse tree in the
	  AsFix format. If option <code>-2</code> is produced, the
	  tree is in the specific AsFix2 format, which is what
	  Stratego/XT tools use.  The AsFix2 format is a complete and
	  faithful representation of the derivation constructed by the
	  parser. It includes all details of the input file, including
	  whitespace, comments, and is self documenting as it uses the
	  complete productions of the syntax definition to encode node
	  labels.
	</para>
      </formalpara>

  <formalpara>
    <title><link linkend="ref-implode-asfix"><code>
       implode-asfix -i file.asfix -o file.trm
    </code></link></title>

    <para>

      <code>implode-asfix</code> transforms an AsFix parse tree to an
      abstract syntax tree.

    </para>

  </formalpara>


  <formalpara>
    <title><link linkend="ref-asfix-yield"><code>
       asfix-yield -i file.asfix -o file.txt
    </code></link></title>

    <para>

      <code>asfix-yield</code> is an unparser for AsFix files, i.e.,
      it produces the exact text from which the parse tree was
      derived.

    </para>

  </formalpara>

  </section>
  
  <section>
    <title>SDF: The Syntax Definition Formalism</title>
    
    <para>
      Note: there is already a lot of explanation in the TIL syntax
      example.
    </para>
    
    <section>
      <title>Modules</title>

      <para>
	Little bit about SDF, refer to SDF maual for more details.
      </para>

      <para>
	Renamings
      </para>
    </section>

    <section>
      <title>Generating a Parser</title>

      
      <para>
	sglri, options
      </para>

      <formalpara>
	<title><link linkend="ref-pack-sdf"><code>
	  pack-sdf -i m.sdf -o m.def -I dir
	</code></link></title>
	
	<para>
	  An SDF syntax definition consists of a set of
	  modules. <code>pack-sdf</code> collects all modules imported
	  by module <code>m</code> in file <code>m.sdf</code> and
	  creates a combined syntax definition in file
	  <code>m.def</code>. Modules are looked for in the current
	  directory and any of the include directories indicated with
	  the <code>-I dir</code> arguments.
	</para>
      </formalpara>

      <formalpara>
	<title><link linkend="ref-sglri"><code>
	  sglri -p m.tbl -i file.m -o file.asfix
	</code></link></title>
	
	<para>
	  <code>Sglri</code> is a convenience composition of
	  <code>sglr</code> and <code>implode-asfix</code>.
	</para>
      </formalpara>
    </section>

    <section>
      <title>Lexical Syntax</title>
      
      <para>
	So far we have looked at syntax of expressions and statements,
	but not at the definition of lexical items such as identifiers
	and constants. In most syntax definition formalisms these are
	defined separately to generate a scanner which divides a
	string into tokens before the parser recognizes the
	context-free structure.
      </para>
      
      <para>
	In SDF the definition of lexical and context-free syntax are
	integrated in the same formalism, and are specified using the
	same means, i.e., context-free productions, regular
	expressions, etc. Productions for lexical items are introduced
	using the keywords <code>lexical syntax</code>. The only
	difference between lexical and context-free syntax is that
	layout (whitespace, comments) can occur between the strings
	corresponding to sorts in the left-hand of a context-free
	production, or, conversely, <emphasis>no</emphasis> layout is
	allowed between the tokens of a lexeme. The occurrence of
	layout is indicated by injecting <code>LAYOUT?</code>, i.e.,
	optional layout, between every two symbols of a context-free
	production. To avoid cluttering syntax definitions, this is
	done automatically by the SDF parser generator.
      </para>

      <para>
	In order to define the syntax at the level of characters, SDF
	provides character classes <code>[...]</code>, which generate
	one character from the set. Letters and digits can be written
	as themselves, all other characters should be escaped using a
	slash, e.g. <code>\_</code>. Characters can also be indicated
	by their decimal ASCII\footnote{These codes could also be
	interpreted in a different character encoding.} code, e.g.,
	<code>\13</code> for linefeed. Some often used non-printable
	characters have more mnemonic names, e.g., <code>\n</code> for
	newline, <code>\ </code> for space and <code>\t</code> for
	tab.
      </para>
      
      <para>
	The definition of lexical syntax with a context-free grammar,
	gives rise to ambiguities that cannot be resolved with the
	associativity and priority mechanisms shown earlier. SDF
	provides two additional disambiguation mechanism for this
	purpose. A follow restriction \texttt{A -/- cc1 . ... . ccn}
	indicates that a string of sort A cannot be followed by a
	string in <code>cc1 ... ccn</code>, where the <code>cc</code>
	are character classes. Follow restrictions can be used to
	encode longest match disambiguation. A reject production
	<code>A1 ... An -> A0 {reject}</code> forbids an
	<code>A0</code> if it can also be parsed as <code>A1
	... An</code>. Reject productions are typically used to
	specify reserved words, by rejecting them as identifiers.
      </para>

      <section>
	<title>Layout: Whitespace and Comments</title>
	<para/>
      
	<para>
	  These concepts are illustrated in <xref
	  linkend="Fig-LexicalSyntax"/>, which defines the lexical syntax of
	  identifiers, integer constants, and C-style comments. Note how
	  follow restrictions are used for longest match disambiguation of
	  identifiers, integer constants, and layout. Since an identifier
	  cannot be followed by a letter, the <code>a</code> in
	  <code>ab</code> cannot be recognized as an identifier by itself,
	  only the entire string <code>ab</code>.  Restrictions are also
	  used to define that a sole asterisk within a C style comment
	  should not be followed by a slash (which would end the comment). A
	  reject production is used to forbid the use of keywords as
	  identifiers.
	</para>
      
	<figure xml:id="Fig-LexicalSyntax">
	  <title>
	    Definition of lexical syntax.
	  </title>
	  <showfile root="." file="xmpl/Lexical.sdf"/>
	</figure>
      </section>
    </section>
  </section>

  <section>
    <title>Context-free Syntax</title>

    <section>
      <title>Regular Expressions</title>
      
      <para>
	Programming languages usually contain all kinds of list
	constructs. Specification of lists with plain context-free
	grammars requires several productions for each list construct.
	SDF provides a bunch of regular expression operators abbreviating
	common patterns. The operators <code>A*</code> and
	<code>A+</code> denote lists of zero (one) or more
	<code>A</code>s.  The <code>{A lit}*</code> and <code>{A
	lit}+</code> operators denote lists of zero (one) or more
	<code>A</code>s separated by <code>lit</code>.
      </para>
      
      <para>
	<xref linkend="Fig-RegularExpressions"/> illustrates the use of
	these operators in the extension of the expression language with
	statements and function declarations. Lists are used in numerous
	places, such as for the sequential composition of statements
	(<code>Seq</code>), the declarations in a let binding, and the
	formal and actual arguments of a function (<code>FunDec</code>
	and <code>Call</code>). An example function definition in this
	language is:

<screen>
function fact(n, x) =
  if n > 0 then fact(n - 1, n * x) else x
</screen>

      </para>

      <figure xml:id="Fig-RegularExpressions">
	<title>
	  Syntax definition with regular expressions.
	</title>
	<showfile root="." file="xmpl/Statements.sdf"/>
      </figure>
    </section>
  
    <section>
      <title>Disambiguation</title>
      
      <para>
	Syntax definitions in the style of <xref
	linkend="Fig-test1-acub"/> are <emphasis>ambiguous</emphasis>,
	i.e., there is more than one way to map strings to trees. For
	example, the string <code>a+b*c</code> has two possible
	derivations, as shown in <xref linkend="Fig-ambiguities"/>.
      </para>
      
      <figure xml:id="Fig-ambiguities">
	<title>
	  Parses for the string <code>a+b*c</code>
	</title>
	<nexttoeachother>
	  <entry>
	    <pngobject fileref="xmpl/test5-acub.png" align="center"/>
	  </entry>
	  <entry>
	    <pngobject fileref="xmpl/test4-acub.png" align="center"/>
	  </entry>
	</nexttoeachother>
      </figure>


      <section>
	<title>Associativity</title>
      
	<para>
	  In plain context-free grammars such ambiguities are solved
	  by introducing additional non-terminals and
	  productions. This results in much more complex parse trees
	  and increases the distance between parse trees and abstract
	  syntax trees. In order to support natural syntax
	  definitions, SDF provides several declarative disambiguation
	  mechanismqs. Associativity declarations (<code>left</code>,
	  <code>right</code>, <code>non-assoc</code>), disambiguate
	  combinations of a binary operator with itself and with other
	  operators. Thus, the left associativity of <code>+</code>
	  entails that <code>a+b+c</code> is parsed as
	  <code>(a+b)+c</code>. Priority declarations (<code>></code>)
	  declare the relative priority of productions. A production
	  with lower priority cannot be a direct subtree of a
	  production with higher priority. Thus <code>a+b*c</code> is
	  parsed as <code>a+(b*c)</code> since the other parse
	  <code>(a+b)*c</code> has a conflict between the
	  <code>*</code> and <code>+</code> productions.
	</para>
	
	<figure xml:id="Fig-Expressions.sdf">
	  <title>
	    Syntax definition with associativity and priority declarations.
	  </title>
	  <showfile root="." file="xmpl/Expressions.sdf"/>
	</figure>
      </section>

      <section>
	<title>Priorities</title>
	<para/>
      </section>

      <section>
	<title>Follow Restrictions</title>
	<para/>
	<section>
	  <title>Example: ++</title>
	  <para/>
	</section>
      </section>

      <section>
	<title>Reject Productions</title>
	<para/>
	<section>
	  <title>Example: No New Array</title>
	  <para/>
	</section>
      </section>

      <section>
	<title>Avoid and Prefer Productions</title>
	<para/>
	<section>
	  <title>Example: Dangling Else</title>
	  <para/>
	</section>
      </section>
    </section>
  </section>
    
  <xi:include href="parse-unit/section.xml"/>
</chapter>
