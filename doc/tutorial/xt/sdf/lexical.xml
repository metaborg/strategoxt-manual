<section xml:id="section-lexical-syntax"
   xmlns="http://docbook.org/ns/docbook"
   xmlns:xi="http://www.w3.org/2003/XInclude">

  <title>Examples: Defining Lexical Syntax</title>

  <para>
    Until now, we have mostly discussed the design of SDF. Now, it's
    about time to see how all these fancy ideas for syntax definition
    work about in practice. In this and the next section, we will
    present a series of examples that explain how typical language
    constructs are defined in SDF. This first section covers examples
    of lexical syntax constructs. The next section will be about
    context-free syntax.
  </para>

  <section>
    <title>Defining Whitespace</title>

    <programlisting>
lexical syntax
  [\ \t\r\n] -> LAYOUT</programlisting>
  </section>

  <section>
    <title>Defining Identifiers</title>

    <para>
      Almost every language has identifiers, so we will start with
      that. Defining identifiers themselves is easy, but there is some
      more definition of syntax required, as we will see next. First,
      the actual definition of identifiers. As in most languages, we
      want to disallow digits as the first character of an identifier,
      so we take a little bit more restrictive character class for
      that first character.
    </para>

    <programlisting>
lexical syntax
  [A-Za-z][A-Za-z0-9]* -> Id</programlisting>

    <formalpara>
      <title>Reserving Keywords</title>

      <para>
	If a language would only consists of identifiers, then this
	production does the job. Unfortunately, life is not that easy.
	In practice, identifiers interact with other language
	constructs. The best known interaction is that most languages
	do not allow keywords (such as <code>if</code>,
	<code>while</code>, <code>class</code>) and special literals
	(such as <code>null</code>, <code>true</code>). In SDF,
	keywords and special literals are not automatically preferred
	over identifiers. For example, consider the following, very
	simple expression language (for the context-free syntax we
	appeal to your intuition for now).
      </para>
    </formalpara>

    <programlisting>
lexical syntax
  [A-Za-z][A-Za-z0-9]* -> Id
  "true"  -> Bool
  "false" -> Bool

context-free start-symbols Exp
context-free syntax
  Id   -> Exp {cons("Id")}
  Bool -> Exp {cons("Bool")}</programlisting>

    <para>
      The input <code>true</code> can now be parsed as an identifier
      as well as a boolean literal. Since the generalized-LR parser
      actually supports ambiguities, we can even try this out:
    </para>

    <screen><prompt>$</prompt> echo "true" | sglri -p Test.tbl --no-heuristic-filters
amb([Bool("true"), Id("true")])</screen>
      
    <para>
      The <code>amb</code> term is a representation of the
      ambiguity. The argument of the ambiguity is a list of
      alternatives. In this case, the first is the boolean literal and
      the second is the identifier true. So, we have to define
      explicitly that we do not want to allow these boolean literals
      as identifiers. For this purpose, we can use SDF
      <emphasis>reject</emphasis> productions. The intuition of these
      reject productions is that <emphasis>all</emphasis> derivations
      for which there is a reject production are forbidden. In this
      example,
    </para>

    <programlisting>
lexical syntax
  "true"  -> Id {reject}
  "false" -> Id {reject}</programlisting>

    <para>
      Indeed, if we add these productions to our syntax definition,
      then the true literal is no longer ambiguous:
    </para>

    <screen><prompt>$</prompt> echo "true" | sglri -p Test.tbl --no-heuristic-filters
Bool("true")</screen>

    <para>
      We can make the definition of these reject productions a bit
      more concise by just reusing the <code>Bool</code> sort. In the
      same way, we can define keywords using separate production rules
      and have a single reject productions for keywords to
      identifiers.
    </para>

    <programlisting>
lexical syntax
  Bool    -> Id {reject}
  Keyword -> Id {reject}

  "class" -> Keyword
  "if"    -> Keyword
  "while" -> Keyword</programlisting>

    <formalpara>
      <title>Longest Match</title>
      
      <para>
	Surprising effects: break of identifiers
	The definition of lexical syntax with a context-free grammar,
	gives rise to ambiguities that cannot be resolved with the
	associativity and priority mechanisms shown earlier. SDF
	provides two additional disambiguation mechanism for this
	purpose. A follow restriction \texttt{A -/- cc1 . ... . ccn}
	indicates that a string of sort A cannot be followed by a string
	in <code>cc1 ... ccn</code>, where the <code>cc</code> are
	character classes. Follow restrictions can be used to encode
	longest match disambiguation.
      </para>
    </formalpara>

    <programlisting>
context-free syntax
  Id    -> Stm {cons("Call")}
  Id Id -> Stm {cons("VarDec")}</programlisting>

    <screen><prompt>$</prompt> echo "foo" | sglri -p Test.tbl --no-heuristic-filters
amb([Call("foo"), VarDec("f","oo"), VarDec("fo","o")])</screen>

    <programlisting>
lexical restrictions
  Id -/- [A-Za-z0-9]</programlisting>

    <screen><prompt>$</prompt> echo "foo" | sglri -p Test.tbl --no-heuristic-filters
Call("foo")</screen>

    <para>
      Similar issue with keywords:
    </para>

    <screen><prompt>$</prompt> echo "gotox" | sglri -p Test.tbl --no-heuristic-filters
Goto("x")</screen>

    <para>
      Usually, we want to forbid this.
    </para>

    <programlisting>
lexical restrictions
  "goto" -/- [A-Za-z0-9]</programlisting>

    <para>
      Note that it is not possible to define follow restrictions on
      abstractions. The follow restriction must be defined on the
      symbol that literally occurs in the productions.
    </para>

    <programlisting>
lexical restrictions
  "goto" "if" -/- [A-Za-z0-9]</programlisting>
  </section>

  <section>
    <title>Defining Whitespace</title>
    <para/>

    <para>
      These concepts are illustrated in <xref
      linkend="Fig-LexicalSyntax"/>, which defines the lexical syntax
      of identifiers, integer constants, and C-style comments. Note
      how follow restrictions are used for longest match
      disambiguation of identifiers, integer constants, and
      layout. Since an identifier cannot be followed by a letter, the
      <code>a</code> in <code>ab</code> cannot be recognized as an
      identifier by itself, only the entire string <code>ab</code>.
      Restrictions are also used to define that a sole asterisk within
      a C style comment should not be followed by a slash (which would
      end the comment). A reject production is used to forbid the use
      of keywords as identifiers.
    </para>

    <para>
      Lexical syntax sections are used to define constructs, such as
      identifiers, layout, comments, and literals. Layout is a special
      non-terminal in \SDF{} named \verb|LAYOUT|. A symbol for this
      non-terminal is inserted between the symbols of productions in a
      context-free syntax section to allow layout between the symbols
      there. The following lexical syntax section defines layout
      (\texttt{LAYOUT}), identifiers (\verb|Id|), and integer
      constants (\verb|IntConst|).
    </para>

    <para>
      Why follow restrictions on whitespace is necessary
    </para>
  </section>

  <section>
    <title>Defining Comments</title>
    <para/>

    <example>
      <title>Lexical Syntax of Line Comments</title>
      <para/>
    </example>

    <example>
      <title>Balanced Block Comments</title>
      <para/>
    </example>
  </section>

  <section>
    <title>Defining Literals</title>

    <para>
      The use of productions for lexical syntax becomes clear if we
      take a look at the definition of floating point literals in
      Java.
    </para>

    <example>
      <title>Lexical Syntax for Floating Point Literals</title>
      <para>
	Very complex regular expressions, without a clear structure.
      </para>

      <para>
	Reject integer literals
      </para>

      <para>
	Follow restrictions
      </para>
    </example>
  </section>

  <section>
    <title>Defining Keywords</title>
    <para>
      See identifiers
    </para>

    <para>
      Follow restriction
    </para>

    <figure xml:id="Fig-LexicalSyntax">
      <title>
	Definition of lexical syntax.
      </title>
      <showfile root="." file="xmpl/Lexical.sdf"/>
    </figure>  
  </section>
</section>

