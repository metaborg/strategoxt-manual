<section
   xmlns="http://docbook.org/ns/docbook"
   xmlns:xi="http://www.w3.org/2003/XInclude">

  <title>SDF: The Syntax Definition Formalism</title>
  
  <para>
    Note: there is already a lot of explanation in the TIL syntax
    example.
  </para>
  
  <section>
    <title>Modules</title>
    
    <para>
      Little bit about SDF, refer to SDF maual for more details.
    </para>
    
    <para>
      Renamings
    </para>

    <para>
      Hierarchical names
    </para>
  </section>


    <section>
      <title>Lexical Syntax</title>
      
      <para>
	So far we have looked at syntax of expressions and statements,
	but not at the definition of lexical items such as identifiers
	and constants. In most syntax definition formalisms these are
	defined separately to generate a scanner which divides a
	string into tokens before the parser recognizes the
	context-free structure.
      </para>
      
      <para>
	In SDF the definition of lexical and context-free syntax are
	integrated in the same formalism, and are specified using the
	same means, i.e., context-free productions, regular
	expressions, etc. Productions for lexical items are introduced
	using the keywords <code>lexical syntax</code>. The only
	difference between lexical and context-free syntax is that
	layout (whitespace, comments) can occur between the strings
	corresponding to sorts in the left-hand of a context-free
	production, or, conversely, <emphasis>no</emphasis> layout is
	allowed between the tokens of a lexeme. The occurrence of
	layout is indicated by injecting <code>LAYOUT?</code>, i.e.,
	optional layout, between every two symbols of a context-free
	production. To avoid cluttering syntax definitions, this is
	done automatically by the SDF parser generator.
      </para>

      <para>
	In order to define the syntax at the level of characters, SDF
	provides character classes <code>[...]</code>, which generate
	one character from the set. Letters and digits can be written
	as themselves, all other characters should be escaped using a
	slash, e.g. <code>\_</code>. Characters can also be indicated
	by their decimal ASCII\footnote{These codes could also be
	interpreted in a different character encoding.} code, e.g.,
	<code>\13</code> for linefeed. Some often used non-printable
	characters have more mnemonic names, e.g., <code>\n</code> for
	newline, <code>\ </code> for space and <code>\t</code> for
	tab.
      </para>
      
      <para>
	The definition of lexical syntax with a context-free grammar,
	gives rise to ambiguities that cannot be resolved with the
	associativity and priority mechanisms shown earlier. SDF
	provides two additional disambiguation mechanism for this
	purpose. A follow restriction \texttt{A -/- cc1 . ... . ccn}
	indicates that a string of sort A cannot be followed by a
	string in <code>cc1 ... ccn</code>, where the <code>cc</code>
	are character classes. Follow restrictions can be used to
	encode longest match disambiguation. A reject production
	<code>A1 ... An -> A0 {reject}</code> forbids an
	<code>A0</code> if it can also be parsed as <code>A1
	... An</code>. Reject productions are typically used to
	specify reserved words, by rejecting them as identifiers.
      </para>

      <section>
	<title>Layout: Whitespace and Comments</title>
	<para/>
      
	<para>
	  These concepts are illustrated in <xref
	  linkend="Fig-LexicalSyntax"/>, which defines the lexical syntax of
	  identifiers, integer constants, and C-style comments. Note how
	  follow restrictions are used for longest match disambiguation of
	  identifiers, integer constants, and layout. Since an identifier
	  cannot be followed by a letter, the <code>a</code> in
	  <code>ab</code> cannot be recognized as an identifier by itself,
	  only the entire string <code>ab</code>.  Restrictions are also
	  used to define that a sole asterisk within a C style comment
	  should not be followed by a slash (which would end the comment). A
	  reject production is used to forbid the use of keywords as
	  identifiers.
	</para>
      
	<figure xml:id="Fig-LexicalSyntax">
	  <title>
	    Definition of lexical syntax.
	  </title>
	  <showfile root="." file="xmpl/Lexical.sdf"/>
	</figure>
      </section>
    </section>

  <section>
    <title>Context-free Syntax</title>

    <section>
      <title>Regular Expressions</title>
      
      <para>
	Programming languages usually contain all kinds of list
	constructs. Specification of lists with plain context-free
	grammars requires several productions for each list construct.
	SDF provides a bunch of regular expression operators abbreviating
	common patterns. The operators <code>A*</code> and
	<code>A+</code> denote lists of zero (one) or more
	<code>A</code>s.  The <code>{A lit}*</code> and <code>{A
	lit}+</code> operators denote lists of zero (one) or more
	<code>A</code>s separated by <code>lit</code>.
      </para>
      
      <para>
	<xref linkend="Fig-RegularExpressions"/> illustrates the use of
	these operators in the extension of the expression language with
	statements and function declarations. Lists are used in numerous
	places, such as for the sequential composition of statements
	(<code>Seq</code>), the declarations in a let binding, and the
	formal and actual arguments of a function (<code>FunDec</code>
	and <code>Call</code>). An example function definition in this
	language is:

<screen>
function fact(n, x) =
  if n > 0 then fact(n - 1, n * x) else x
</screen>

      </para>

  <para>
    bracket annotations
  </para>

      <figure xml:id="Fig-RegularExpressions">
	<title>
	  Syntax definition with regular expressions.
	</title>
	<showfile root="." file="xmpl/Statements.sdf"/>
      </figure>
    </section>
  </section>
  
  <section>
    <title>Disambiguation</title>
    
    <para>
      Syntax definitions in the style of <xref
      linkend="Fig-test1-acub"/> are <emphasis>ambiguous</emphasis>,
      i.e., there is more than one way to map strings to trees. For
      example, the string <code>a+b*c</code> has two possible
      derivations, as shown in <xref linkend="Fig-ambiguities"/>.
    </para>
    
    <figure xml:id="Fig-ambiguities">
      <title>
	Parses for the string <code>a+b*c</code>
      </title>
	<nexttoeachother>
	  <entry>
	    <pngobject fileref="xmpl/test5-acub.png" align="center"/>
	  </entry>
	  <entry>
	    <pngobject fileref="xmpl/test4-acub.png" align="center"/>
	  </entry>
	</nexttoeachother>
    </figure>
    
    
    <section>
      <title>Associativity</title>
      
      <para>
	In plain context-free grammars such ambiguities are solved by
	introducing additional non-terminals and productions. This
	results in much more complex parse trees and increases the
	distance between parse trees and abstract syntax trees. In
	order to support natural syntax definitions, SDF provides
	several declarative disambiguation mechanismqs. Associativity
	declarations (<code>left</code>, <code>right</code>,
	<code>non-assoc</code>), disambiguate combinations of a binary
	operator with itself and with other operators. Thus, the left
	associativity of <code>+</code> entails that
	<code>a+b+c</code> is parsed as <code>(a+b)+c</code>. Priority
	declarations (<code>></code>) declare the relative priority of
	productions. A production with lower priority cannot be a
	direct subtree of a production with higher priority. Thus
	<code>a+b*c</code> is parsed as <code>a+(b*c)</code> since the
	other parse <code>(a+b)*c</code> has a conflict between the
	<code>*</code> and <code>+</code> productions.
      </para>
      
      <figure xml:id="Fig-Expressions.sdf">
	<title>
	  Syntax definition with associativity and priority declarations.
	</title>
	<showfile root="." file="xmpl/Expressions.sdf"/>
      </figure>
    </section>
    
    <section>
      <title>Priorities</title>
      <para/>
    </section>
    
    <section>
      <title>Follow Restrictions</title>
      <para/>
      
      <section>
	  <title>Example: Don't split Identifiers</title>
	  <para/>
      </section>
      
      <section>
	<title>Example: ++</title>
	<para/>
      </section>
    </section>
    
    <section>
      <title>Reject Productions</title>
      <para/>
      
      <section>
	<title>Example: Reserved Keywords</title>
	<para/>
      </section>
      
      <section>
	<title>Example: No New Array</title>
	<para/>
      </section>
    </section>
    
    <section>
      <title>Avoid and Prefer Productions</title>
      <para/>
      <section>
	<title>Example: Dangling Else</title>
	<para/>
      </section>
    </section>
  </section>
</section>
