<section
   xmlns="http://docbook.org/ns/docbook"
   xmlns:xi="http://www.w3.org/2003/XInclude">

  <title>Concepts: Grammars, Parse Trees, and Abstract Syntax Trees</title>
  
  <para>
    In this section, we review the basics of grammars, parse trees and
    abstract syntax trees. Although you might already be familiar with
    these basic concepts, the perspective from the Stratego/XT point
    of view might still be interesting to read.
  </para>
  
  <section>
    <title>Context-free Grammars</title>
    
    <para>
      Context-free grammars were originally introduced by Chomsky to
      describe the <emphasis>generation</emphasis> of grammatically
      correct sentences in a language. A context-free grammar is a set
      of <emphasis>productions</emphasis> of the form
      A<subscript>0</subscript> -> A<subscript>1</subscript>
      ... A<subscript>n</subscript>, where A<subscript>0</subscript>
      is non-terminal and A<subscript>1</subscript>
      ... A<subscript>n</subscript> is a string of terminals and
      non-terminals. From this point of view, a grammar describes a
      language by <emphasis>generating</emphasis> its sentences. A
      string is generated by starting with the start non-terminal and
      repeatedly replacing non-terminal symbols according to the
      productions until a string of <emphasis>terminal</emphasis>
      symbols is reached.
    </para>

    <para>
      A context-free grammar can also be used to
      <emphasis>recognize</emphasis> sentences in the language. In
      that process, a string of terminal symbols is rewritten to the
      start non-terminal, by repeatedly applying grammar productions
      backwards, i.e. reducing a substring matching the right-hand
      side of a production to the non-terminal on the left-hand
      side. In SDF, productions are specified as
      A<subscript>1</subscript> ... A<subscript>n</subscript> ->
      A<subscript>0</subscript>, to emphasize the recognition aspect
      of grammars.
    </para>

    <para>
      As an example, consider the SDF productions for a small language
      of arithmetic expressions in <xref
      linkend="Fig-Expressions-NoCons.sdf"/>, where <code>Id</code>
      and <code>IntConst</code> are terminals and <code>Var</code> and
      <code>Exp</code> are non-terminals. Using this definition, and
      provided that <code>a</code> and <code>n</code> are identifiers
      (<code>Id</code>) and <code>1</code> is an
      <code>IntConst</code>, a string such as <code>(a+n)*1</code> can
      be recognized as an expression by reducing it to
      <code>Exp</code>, as shown by the reduction sequence in the
      <link linkend="Fig-Expressions-NoCons.sdf">right-hand side of
      the figure</link>.
    </para>
    
    <figure xml:id="Fig-Expressions-NoCons.sdf">
      <title>
	Context-free productions and a reduction sequence.
      </title>
      <nexttoeachother align="left" valign="top">
	<entry>
	  <showfile root="." file="xmpl/Expressions-NoCons.sdf"/>
	</entry>
	<entry>
	  <showfile root="." file="xmpl/Expressions-NoCons.red"/>
	</entry>
      </nexttoeachother>
    </figure>
  </section>
  
  <section>
    <title>Parse Trees</title>
    
    <para>
      Recognition of a string only leads to its grammatical category,
      not to any other information. However, a context-free grammar
      not only describes a mapping from strings to sorts, but actually
      assigns structure to strings.  A context-free grammar can be
      considered as a declaration of a set of trees of one level
      deep. For example, the following trees correspond to productions
      from the syntax definition in <xref
      linkend="Fig-Expressions-NoCons.sdf"/>:

      <informalfigure pgwide="1">
	<pngobject fileref="Plus.png" align="center"/>
      </informalfigure>
    </para>
    
    <para>
      <informalfigure pgwide="0">
	<pngobject fileref="PlusTimes.png" align="right"/>
      </informalfigure>
      
      Such one-level trees can be composed into larger trees by fusing
      trees such that the symbol at a leaf of one tree matches with
      the root symbol of another, as is illustrated in the fusion of
      the plus and times productions on the right.
	
      The fusion process can continue as long as the tree has
      non-terminal leaves. A tree composed in this fashion is a parse
      tree if all leaves are terminal symbols. <xref
      linkend="Fig-ParseTree"/> shows a parse tree for the expression
      <code>(a+n)*1</code>, for which we showed a reduction sequence
      earlier in <xref linkend="Fig-Expressions-NoCons.sdf"/>. This
      illustrates the direct correspondence between a string and its
      grammatical structure. The string underlying a parse tree can be
      obtained by concatening the symbols at its leaves, also known as
      the yield.
    </para>
    
    <figure xml:id="Fig-ParseTree">
      <title>Parse tree</title>
      <pngobject fileref="parse-tree.png" align="left"/>
    </figure>
    
    <para>
      Parse trees can be derived from the reduction sequence induced
      by the productions of a grammar. Each rewrite step is associated
      with a production, and thus with a tree fragment. Instead of
      replacing a symbol with the non-terminal symbol of the
      production, it is replaced with the tree fragment for the
      production fused with the trees representing the symbols being
      reduced. Thus, each node of a parse tree corresponds to a
      rewrite step in the reduction of its underlying string. This is
      illustrated by comparing the reduction sequence in <xref
      linkend="Fig-Expressions-NoCons.sdf"/> with the tree in <xref
      linkend="Fig-ParseTree"/>
    </para>
      
    <para>
      The recognition of strings described by a syntax definition, and
      the corresponding construction of parse trees can be done
      automatically by a parser, which can be generated from the
      productions of a syntax definition.
    </para>
  </section>
  
  <section>
    <title>Abstract Syntax Trees</title>
    
    <para>
      Parse trees contain all the details of a program including
      literals, whitespace, and comments. This is usually not
      necessary for performing transformations.  A parse tree is
      reduced to an <emphasis>abstract syntax tree</emphasis> by
      eliminating irrelevant information such as literal symbols and
      layout. Furthermore, instead of using sort names as node labels,
      <emphasis>constructors</emphasis> encode the production from
      which a node is derived. For this purpose, the productions in a
      syntax definition are extended with <emphasis>constructor
      annotations</emphasis>.  <xref linkend="Fig-test1-acub"/> shows
      the extension of the syntax definition from <xref
      linkend="Fig-Expressions-NoCons.sdf"/> with constructor
      annotations and the abstract syntax tree for the same good old
      string <code>(a+n)*1</code>. Note that some identifiers are used
      as sort names <emphasis>and</emphasis> and as constructors. This
      does not lead to a conflict since sort names and constructors
      are derived from separate name spaces.
    </para>
    
    <figure xml:id="Fig-test1-acub">
      <title>
	Context-free productions with constructor annotations and an
	abstract syntax tree.
      </title>
      <nexttoeachother>
	<entry><showfile root="." file="xmpl/Expressions-Cons.sdf"/></entry>
	<entry><pngobject fileref="xmpl/test1-acub.png" align="center"/></entry>
      </nexttoeachother>
    </figure>
  </section>
</section>
