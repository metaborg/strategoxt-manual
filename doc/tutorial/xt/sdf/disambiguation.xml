<section
   xmlns="http://docbook.org/ns/docbook"
   xmlns:xi="http://www.w3.org/2003/XInclude">

  <title>Disambiguation</title>
    
    <para>
      Syntax definitions in the style of <xref
      linkend="Fig-test1-acub"/> are <emphasis>ambiguous</emphasis>,
      i.e., there is more than one way to map strings to trees. For
      example, the string <code>a+b*c</code> has two possible
      derivations, as shown in <xref linkend="Fig-ambiguities"/>.
    </para>
    
    <example xml:id="Fig-ambiguities">
      <title>
	Parses for the string <code>a+b*c</code>
      </title>
	<nexttoeachother>
	  <entry>
	    <pngobject fileref="xmpl/test5-acub.png" align="center"/>
	  </entry>
	  <entry>
	    <pngobject fileref="xmpl/test4-acub.png" align="center"/>
	  </entry>
	</nexttoeachother>
    </example>

    <section>
      <title>Associativity</title>
      
      <para>
	In plain context-free grammars such ambiguities are solved by
	introducing additional non-terminals and productions. This
	results in much more complex parse trees and increases the
	distance between parse trees and abstract syntax trees. In
	order to support natural syntax definitions, SDF provides
	several declarative disambiguation mechanismqs. Associativity
	declarations (<code>left</code>, <code>right</code>,
	<code>non-assoc</code>), disambiguate combinations of a binary
	operator with itself and with other operators. Thus, the left
	associativity of <code>+</code> entails that
	<code>a+b+c</code> is parsed as <code>(a+b)+c</code>. Priority
	declarations (<code>></code>) declare the relative priority of
	productions. A production with lower priority cannot be a
	direct subtree of a production with higher priority. Thus
	<code>a+b*c</code> is parsed as <code>a+(b*c)</code> since the
	other parse <code>(a+b)*c</code> has a conflict between the
	<code>*</code> and <code>+</code> productions.
      </para>
      
      <figure xml:id="Fig-Expressions.sdf">
	<title>
	  Syntax definition with associativity and priority declarations.
	</title>
	<showfile root="." file="xmpl/Expressions.sdf"/>
      </figure>

      <para>
	Associativity in Group
      </para>
    </section>
    
    <section>
      <title>Priorities</title>

      <example>
	<title>Expressions</title>
	<para/>
      </example>

      <example>
	<title>Preventing Cycles</title>
	<para/>
      </example>

      <warning>
	<title>Hedged Symbols</title>
	<para/>
	<para>
	  Solution: introduce an auxiliary non-terminal
	</para>
      </warning>
    </section>

    <section>
      <title>Follow Restrictions</title>
      <para/>

      <example>
	<title>Reject split of ++</title>
	<para/>
      </example>
      
      <example>
	<title>Don't split keywords and identifiers</title>
	<para/>
      </example>

      <warning>
	<title>Follow Restrictions require exact symbols</title>
	<para>
	  Abstract is not possible: symbol must occur in the
	  production as specified in the follow restriction.
	</para>

	<para>
	  As opposed to reject productions, where abstraction is
	  possible. So, you can abstract over keywords for rejecting
	  them as identifiers, but you cannot abstract over a follow
	  restriction for keywords.
	</para>
      </warning>
	
    </section>
    
    <section>
      <title>Reject Productions</title>
      <para/>
      
      <example>
	<title>Reserved Keywords</title>
	<para/>
      </example>
      
      <example>
	<title>No New Array</title>
	<para/>
      </example>

      <example>
	<title>Hexidecimal floating point literals</title>
	<para/>
      </example>
    </section>
    
    <section>
      <title>Avoid and Prefer Productions</title>
      <para/>

      <example>
	<title>Dangling Else</title>
	<para/>
      </example>

    </section>
  </section>

