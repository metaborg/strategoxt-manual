<section
   xmlns="http://docbook.org/ns/docbook"
   xmlns:xi="http://www.w3.org/2003/XInclude">

  <title>From Concepts to Practice: Generating a Parser</title>
  
  <para>
    In the next section we will take a closer look at the various
    features of the SDF language, but before that it is useful to know
    your tools, so that you can immediately experiment with the
    various SDF features you will learn about. You don't need to fully
    understand the SDF fragments we use to explain the tools: we will
    come back to that later.
  </para>

  <para>
    One of the nice things about SDF and the tools for it, is that the
    concepts that we have discussed directly translate to
    practice. For example, SDF supports all context-free grammars; the
    parser produces complete parse trees, which can even be yielded;
    parse trees can be converted to abstract syntax trees.
  </para>
  
  <section>
    <title>From Modules to Definition</title>

    <para>
      In SDF, you can split a syntax definition into multiple
      modules. So, a complete syntax definition consists a set of
      modules. SDF modules are stored in files with the extension
      <filename>.sdf</filename>. <xref linkend="Fig-Modules"/> shows
      two SDF modules for a small language of expressions. The module
      Lexical defines the identifiers and integer literals of the
      language. This module is imported by the module Expression.
    </para>

    <figure xml:id="Fig-Modules">
      <title>
	SDF modules for a small language of artithemetic expressions.
      </title>

      <informaltable frame="void">
	<col width="0*"/>
	<col width="1*"/>
	<tbody align='left'>
	    <tr valign="top">
	      <td>
		<programlisting><xi:include parse="text" href="practice/Expression.sdf"/></programlisting>
	      </td>
	      <td rowspan="2">
		<programlisting><xi:include parse="text" href="practice/Operators.sdf"/></programlisting>
	      </td>
	    </tr>
	    <tr valign="top">
	      <td>
		<programlisting><xi:include parse="text" href="practice/Lexical.sdf"/></programlisting>
	      </td>
	    </tr>
	</tbody>
      </informaltable>
    </figure>

    <para>
      Before you can invoke the parser generator to create a parser
      for this expression language, the modules that constitute a
      complete syntax definition have to be collected into a single
      file, usually called a <emphasis>definition</emphasis>. This
      file has the extension <filename>.def</filename>. Collecting SDF
      modules into a <filename>.def</filename> file is the job of the
      tool <link linkend="ref-pack-sdf">pack-sdf</link>.

      <screen><prompt>$</prompt> pack-sdf -i Expression.sdf -o Expression.def</screen>
      
      Pack-sdf collects all modules imported by the SDF module
      specified using the <code>-i</code> parameter. This results in a
      combined syntax definition, which is written to the file
      specified with the <code>-o</code> parameter. Modules are looked
      for in the current directory and any of the include directories
      indicated with the <code>-I dir</code> arguments.
    </para>

    <para>
      Pack-sdf does not analyse the contents of an SDF module to
      report possible errors (except for syntactical ones). The parser
      generator, discussed next, performs this analysis.
    </para>

    <tip>
      <title>Standard options for input and output</title>
      <para>
	All tools in Stratego/XT use the <code>-i</code> and
	<code>-o</code> options for input and output. Also, most tools
	read from the standard input or write to standard output if no
	input or output is specified.
      </para>
    </tip>
  </section>

  <section>
    <title>Generating a Parser</title>

    <para>
      From the <code>.def</code> definition file (as produced by
      <code>pack-sdf</code>), the <emphasis>parser
      generator</emphasis> <xref linkend="ref-sdf2table"/> will
      construct a parse table. This parse table can later on be handed
      off to the actual parser.
    </para>

    <screen><prompt>$</prompt> sdf2table -i Expression.def -o Expression.tbl -m Expression</screen>

    <para>
      The <code>-m</code> option is used to specify the module for
      which to generate a parse table. The default module is
      <code>Main</code>, so if the syntax definition has a different
      main module (in this case <code>Expression</code>), then you
      need to specify this option.
    </para>

    <para>
      The parse table is stored in a file with extension
      <code>.tbl</code>. If all you plan on doing with your grammar is
      parsing, the resulting <code>.tbl</code> file is all you need to
      deploy. <xref linkend="ref-sdf2table"/> could be thought of as a
      parse-generator; however, unlike many other parsing systems, it
      does not construct an parser program, but a compact data
      representation of the parse table.
    </para>

    <para>
      Sdf2table analyzes the SDF syntax definition to detect possible
      errors, such as undefined symbols, symbols for which no
      productions exists, deprecated features, etc. It is a good idea
      to try to fix these problems, although <code>sdf2table</code>
      will usually still happily generated a parse table for you.
    </para>
  </section>

  <section>
    <title>Invoking the Parser</title>

    <para>
      The parser (sglr) takes as input the parse table to use, which
      represents the grammar you want it to parse, and a file in the
      language described by the grammar.
    </para>

    <para>
      This tool is is the actual parser. By giving it a .tbl file
      describing your grammar and a file with a text in that grammar's
      language, sglr will construct a parse tree.
    </para>
      
  <formalpara>
    <title><link linkend="ref-sglr"><code> sglr -p m.tbl -i file.m -o
    file.asfix -2 </code></link></title>
    
    <para>
      <code>sglr</code> is the parser for SDF. It takes as
      arguments a parse table <code>m.tbl</code> and an input file
      <code>file.m</code>, presumably in the language described by
      <code>m.def</code>. The parser produces a parse tree in the
      AsFix format. If option <code>-2</code> is produced, the
      tree is in the specific AsFix2 format, which is what
      Stratego/XT tools use.  The AsFix2 format is a complete and
      faithful representation of the derivation constructed by the
      parser. It includes all details of the input file, including
      whitespace, comments, and is self documenting as it uses the
      complete productions of the syntax definition to encode node
      labels.
    </para>
  </formalpara>

  <formalpara>
    <title><link linkend="ref-implode-asfix"><code>
      implode-asfix -i file.asfix -o file.trm
    </code></link></title>
    
    <para>
      <code>implode-asfix</code> transforms an AsFix parse tree to an
      abstract syntax tree.
    </para>
    
  </formalpara>

    <formalpara>
      <title><link linkend="ref-sglri"><code>
	sglri -p m.tbl -i file.m -o file.asfix
      </code></link></title>
      
      <para>
	<code>Sglri</code> is a convenience composition of
	<code>sglr</code> and <code>implode-asfix</code>.
      </para>
    </formalpara>

  <formalpara>
    <title><link linkend="ref-asfix-yield"><code>
      asfix-yield -i file.asfix -o file.txt
    </code></link></title>
    
    <para>
      <code>asfix-yield</code> is an unparser for AsFix files, i.e.,
      it produces the exact text from which the parse tree was
      derived.
    </para>
    
  </formalpara>
  </section>
</section>
  