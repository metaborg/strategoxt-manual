<chapter xml:id="tutorial-aterms"
   xmlns="http://docbook.org/ns/docbook"
   xmlns:xi="http://www.w3.org/2003/XInclude">

  <title>Annotated Terms</title>

  <para>
    The Annotated Term Format [BJKO00], or <emphasis>ATerms</emphasis>
    for short is a standard format for the representation of
    structured data for exchange between programs. It is essentially
    the prefix term format sketched above with a few additional
    features.

  </para>


  <section>
    <title>Annotated Term Format</title>

    <para>
      An ATerm is one of:
    </para>
    
    <itemizedlist>
      <listitem>
       <para>
         Constant constructor: <code>Nil</code> or <code>Nil()</code>
       </para>
     </listitem>

     <listitem>
       <para>
         Integer constant, e.g., <code>1</code>
       </para>
     </listitem>

     <listitem>
       <para>
        Real constant, e.g., <code>0.1</code>
       </para>
     </listitem>

     <listitem>
       <para>
        String constant, e.g., <code>"foo"</code>
       </para>
     </listitem>

     <listitem>
       <para>
        Constructor application to n terms, e.g.,
        <code>Plus(Var("a"),Int(1))</code>
       </para>
     </listitem>

     <listitem>
       <para>
        A list of terms, e.g., <code>[A,B,C]</code>
       </para>
     </listitem>

     <listitem>
       <para>
        A tuple of terms, e.g., <code>(A,B,C)</code>
       </para>
     </listitem>

   </itemizedlist>

   <para>
     In addition, any ATerm can be annotated with a list of terms
     using the notation <code>t{a1,...,an}</code>. The purpose of
     annotations is to attach semantic information to terms without
     changing its basic structure.  A precise syntax definition of
     ATerms can be found in <xref linkend="ref-aterms"/>
  </para>
  </section>

  <section>
    <title>Maximal Sharing</title>

    <para>
      An important feature of the implementation is that terms are
      represented using maximal sharing. This means that any term in
      use in a program is represented only once. In other words, two
      occurrences of the same term will be represented by pointers to
      the same location. <xref linkend="Fig-Sharing"/> illustrates the
      difference between a pure tree representation and a tree, or
      more accurately, a <emphasis>directed acyclic graph</emphasis>,
      with maximal sharing. That is, any sub-term is represented
      exactly once in memory, with each occurrence pointing to the
      same memory location. This representation entails that term
      equality is a constant operation, since it consists of comparing
      pointers. It should be noted that annotations create different
      terms, that is, two terms, one with and the other without
      annotations that are otherwise, modulo annotations, the same,
      are not equal.
    </para>

    <para>
      Maximal sharing can make a big difference [BJKO00] in the amount
      of memory needed for representing programs.  When exporting a
      term using the textual exchange format, this compression is
      lost. Therefore, the ATerm Library also provides a binary
      exchange format that preserves maximal sharing.
    </para>
    
    <figure xml:id="Fig-Sharing">
      <title>
	Tree and dag for the string <code>(a + b) * c + (a + b)</code>
      </title>
      <nexttoeachother>
	<entry>
	  <pngobject fileref="xmpl/sharing-acub.png" align="center"/>
	</entry>
	<entry>
	  <pngobject fileref="xmpl/sharing-scub.png" align="center"/>
	</entry>
      </nexttoeachother>
    </figure>
  </section>
  
  <section>
    <title>ATerm Library</title>

    <para>
      The ATerm Format is an external representation for terms that
      can be used to exchange structured data between programs.  In
      order to use a term, a program needs to parse ATerms and
      transform them into some internal representation. To export a
      term after processing it, a program should transform the
      internal representation into the standard format.  There are
      libraries supporting these operation for a number of languages,
      including C, Java, and Haskell.
    </para>

    <para>
      The implementation of the Stratego transformation language is
      based on the C implementation of the library. The library
      provides term input and output, and an API for constructing and
      inspecting terms. Garbage collection is based on B\"ohms
      conservative garbage collection algorithm.
    </para>

    <para>
      See <xref linkend="ref-aterms"/> for more information on ATerms.
    </para>
  </section>
</chapter>
