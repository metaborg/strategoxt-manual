<chapter xml:id="tutorial-rtg"
   xmlns="http://docbook.org/ns/docbook"
   xmlns:xi="http://www.w3.org/2003/XInclude">

  <title>Trees, Terms, and Tree Grammars</title>

  <section>
    <title>Terms</title>

    <para>
      The Annotated Term Format [BJKO00], or
      <emphasis>ATerms</emphasis> for short is a standard format for
      the representation of structured data for exchange between
      programs. It is essentially the prefix term format sketched
      above with a few additional features. An ATerm is one of:

   <itemizedlist>

     <listitem>
       <para>
         Constant constructor: <code>Nil</code> or <code>Nil()</code>
       </para>
     </listitem>

     <listitem>
       <para>
         Integer constant, e.g., <code>1</code>
       </para>
     </listitem>

     <listitem>
       <para>
        Real constant, e.g., <code>0.1</code>
       </para>
     </listitem>

     <listitem>
       <para>
        String constant, e.g., <code>"foo"</code>
       </para>
     </listitem>

     <listitem>
       <para>
        Constructor application to n terms, e.g.,
        <code>Plus(Var("a"),Int(1))</code>
       </para>
     </listitem>

     <listitem>
       <para>
        A list of terms, e.g., <code>[A,B,C]</code>
       </para>
     </listitem>

     <listitem>
       <para>
        A tuple of terms, e.g., <code>(A,B,C)</code>
       </para>
     </listitem>

   </itemizedlist>

   In addition, any ATerm can be annotated with a list of terms using
   the notation <code>t{a1,...,an}</code>. The purpose of annotations
   is to attach semantic information to terms without changing its
   basic structure.  A precise syntax definition of ATerms can be
   found in <xref linkend="ref-aterms"/>

  </para>

  <para>
        
    The ATerm Format is an external representation for terms that can
    be used to exchange structured data between programs.  In order to
    use a term, a program needs to parse ATerms and transform them
    into some internal representation. To export a term after
    processing it, a program should transform the internal
    representation into the standard format.  There are libraries
    supporting these operation for a number of languages, including C,
    Java, and Haskell.

  </para>

  <para>
       
    The implementation of the Stratego transformation language is
    based on the C implementation of the library. The library provides
    term input and output, and an API for constructing and inspecting
    terms. Garbage collection is based on B\"ohms conservative garbage
    collection algorithm.

  </para>

  <para>
        
    An important feature of the implementation is that terms are
    represented using maximal sharing. This means that any term in use
    in a program is represented only once. In other words, two
    occurrences of the same term will be represented by pointers to
    the same location. <xref linkend="Fig-Sharing"/> illustrates the
    difference between a pure tree representation and a tree, or more
    accurately, a <emphasis>directed acyclic graph</emphasis>, with
    maximal sharing. That is, any sub-term is represented exactly once
    in memory, with each occurrence pointing to the same memory
    location. This representation entails that term equality is a
    constant operation, since it consists of comparing pointers. It
    should be noted that annotations create different terms, that is,
    two terms, one with and the other without annotations that are
    otherwise, modulo annotations, the same, are not equal.

  </para>

  <figure xml:id="Fig-Sharing">
    <title>
      Tree and dag for the string <code>(a + b) * c + (a + b)</code>
    </title>
    <nexttoeachother>
      <entry>
        <pngobject fileref="xmpl/sharing-acub.png" align="center"/>
      </entry>
      <entry>
        <pngobject fileref="xmpl/sharing-scub.png" align="center"/>
      </entry>
    </nexttoeachother>
  </figure>

  <para>

    Maximal sharing can make a big difference [BJKO00] in the amount
    of memory needed for representing programs.  When exporting a term
    using the textual exchange format, this compression is
    lost. Therefore, the ATerm Library also provides a binary exchange
    format that preserves maximal sharing.

  </para>
  <para>
    See <xref linkend="ref-aterms"/> for more information on ATerms.
  </para>
 </section>

  <section>
    <title>Regular Tree Grammars</title>
    <para>
      Explains regular tree grammars and how to generate them.  See
      thesis.
    </para>
  </section>

  <section>
    <title>Generating Code from an RTG</title>
    <para>
      Typematch, API.
    </para>
  </section>

  <section>
    <title>Creating a Subset of a Regular Tree Grammar</title>
    <para>
      Explains rtg-script
    </para>
  </section>
  
  <xi:include href="format/section.xml"/>

 <section>
  <title>Signatures (todo: imported)</title>

  <para>

    The abstract syntax of a programming language or data format can
    be described by means of an <emphasis>algebraic
    signature</emphasis>.  A signature declares for each constructor
    its arity <code>m</code>, the sorts of its arguments <code>S1 *
    ... * Sm</code>, and the sort of the resulting term
    <code>S0</code> by means of a constructor declaration <code>c:S1 *
    ... * Sm -> S0</code>.  A term can be validated against a
    signature by a <emphasis>format checker</emphasis>.

  </para>

  <para>

    Signatures can be derived automatically from syntax definitions.
    For each production <code>A1...An -> A0 {cons(c)}</code> in a
    syntax definition, the corresponding constructor declaration is
    <code>c:S1 * ... * Sm -> S0</code>, where the <code>Si</code> are
    the sorts corresponding to the symbols <code>Aj</code> after
    leaving out literals and layout sorts.  <xref
    linkend="Fig-Signatures"/> shows the signatures of statement and
    expression constructors for the example language from this
    chapter.  The modules have been derived automatically from the
    syntax definitions in <xref linkend="Fig-Expressions.sdf"/> and
    <xref linkend="Fig-RegularExpressions"/>.

  </para>

  <figure xml:id="Fig-Signatures">
    <title>
      Signature for statement and expression constructors,
      automatically derived from a syntax definition.
    </title>
    <showfile root="." file="xmpl/Statements.str"/>
  </figure>

 </section>

 <section>
   <title>Signature Tools (todo: imported)</title>

  <formalpara>
    <title><link linkend="ref-sdf2rtg"><code>
       sdf2rtg -i m.def -o m.rtg -m M
    </code></link></title>

    <para>

      <code>sdf2rtg</code> derives from an SDF syntax definition
      <code>m.def</code> a regular tree grammar for the module
      <code>M</code> and all modules it imports.

    </para>

  </formalpara>

  <formalpara>
    <title><link linkend="ref-rtg2sig"><code>
       rtg2sig -i m.def -o m.rtg
    </code></link></title>

    <para>

      <code>rtg2sig</code> generates from a regular tree grammar a
      Stratego signature.

    </para>

  </formalpara>

 </section>


</chapter>
