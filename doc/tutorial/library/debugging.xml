<chapter
   xmlns="http://docbook.org/ns/docbook"
   xmlns:xi="http://www.w3.org/2003/XInclude">

  <title>Debugging Techniques for Stratego/XT (*)</title>

  <para>
    Even in Stratego/XT, it is not entirely uncommon for developers
    to produce erroneous code from time to time. This chapter will
    walk you through the tools and techniques available for hunting
    down bugs, and tips for how to avoid them in the first place.
  </para>
  
<section>
  <title>Debugging Stratego</title>
  
  <para>
    Both the Stratego language paradigm and its syntax are rather
    different from most other languages. Knowing how to use the
    unique features of Stratego properly, in the way we have
    described in this manual, goes a long way towards avoiding
    future maintenance problems. 
  </para>

<section>
  <title>Writing readable code</title>
  
  <para>
    One important practical aspect of using language constructs is
    expressing their syntax in a readable manner. The intention behind
    the code should be apparent for readers of the code. Judicious use
    of whitespaces is vital in making Stratego code readable, partly
    because its language constructs are less block-oriented than
    most Algol-derivates.
  </para>

  <para>
    The most basic unit of transformation in Stratego is the rewrite
    rule. The following suggests how rules should be written to
    maximize readability.
  </para>
      
<screen>
  EvalExpr:
  Expr(Plus(x), Plus(y) -> Expr(z)
  where
    &lt;addS> (x,y) => z
</screen>
  
  <para>
    Rules are composed using combinators in strategies. One of the
    combinators is <emphasis>composition</emphasis>, written
    <code>;</code>. It is important to realize that <code>;</code>
    is not a statement terminator, as found in imperative
    languages. Therefore, we suggest writing a series of
    strategies and rules joined by composition as follows:
  </para>

<screen>  
  eval-all =
      EvalExpr
    ; s1
    ; s2
</screen>

  <para>
    Both rules and strategies should be documented, using xDoc. At the
    very least, the type of term expected and the type of term returned
    should be specified by the <code>@type</code> attribute. Also take
    care to specify the arity of lists and tuples, if this is fixed.
  </para>

<screen>
 /**
  * @type A -> B
  */
  foo = ...
</screen>
    
  <para>
    Inline rules are handy syntactic sugar that should be used
    with care. Mostly, inline rules are small enough to fit a
    single line. When they are significantly longer than one line,
    it is recommended to extract them into a separate, named rule.
  </para>

<screen>
  strat = 
    \ x -> y where is-okay(|x) => y \
</screen>    
          
  <para>
    Formatting concrete syntax depends very much on the language
    being embedded, so we will provide no hard and fast rules
    for how to do this.
  </para>

  <para>
    Formatting of large terms should be done in the style output
    by <command>pp-aterm</command>.
  </para>

</section>

<section>
  <title>Debugging Stratego code</title>
  
  <para>
	The Stratego/XT environment does not feature a proper debugger
	yet, so the best low-level debugging aids are provided by the
	library, in the from of two kinds of strategies, namely
	<code>debug</code> and a family based around <code>log</code>.
  </para>

  <para>
    The <code>debug</code> strategy will print the current term
    to <filename>stdout</filename>. It will not alter
    anything. While hunting down a bug in your code, it is
    common to sprinkle <code>debug</code> statements liberally
    in areas of code which are suspect:
  </para>  

<screen>
  foo = 
      debug
    ; bar
    ; debug
    ; baz
</screen>

  <para>
    Sometimes, you need to add additional text to your output. In
    this case, an idiom with <code>where</code> and <code>id</code> 
    is used:
  </para>

<screen>
  foo = 
     where(&lt;debug> [ "Entering foo : ", &lt;id> ])
     ; bar
     ; where(&lt;debug> [ "After bar : ", &lt;id> ])
     ; baz
</screen>
          
  <para>
    The <code>where</code> prevents the current term from being
    altered by the construction of your debugging text, and
    <code>id</code> is used to retrieve the current term
    before the <code>where</code> clause.
  </para>
                
  <para>
    The use of <code>debug</code> is an effective, but very intrusive
    approach. A more disciplined regime has been built on top of
    the <code>log(|severity, msg)</code> and
    <code>lognl(|severity, msg)</code> strategies. 
    (See <xref linkend="library-io" /> for details on
    <code>log</code> and <code>lognl</code>). The higher-level 
    strategies you should focus on are <code>fatal-err-msg(|msg)</code>,
    <code>err-msg(|msg)</code>, <code>warn-msg(|msg)</code> and
    <code>notice-msg(|msg)</code>.
  </para>      

  <para>
    It is recommended that you insert calls to these strategies
    at places where your code detects potential and actual
    problems. During normal execution of your program, the
    output from the various <code>-msg</code> strategies is
    silenced. Provided you allow Stratego to deal with the
    I/O and command line options, as explained in
    <xref linkend="library-options"/>, the user (or the
    developer doing debugging) can use the
    <option>--verbose</option> option to adjust 
    which messages he wants to be printed as part of
    program execution. This way, you get adjustable
    levels of tracing output, without having to change
    your code by inserting and removing calls to 
    <code>debug</code>, and without having to recompile.
  </para>
  
</section>

<section>
  <title>Common Pitfalls</title>
  
  <para>
    Some types of errors seem to be more common than others in
    Stratego programs. Awareness of these will help you avoid
    them in your code.
  </para>

  <formalpara>
    <title>Strategy and Rule Overloading</title>
    
  <para>
    The way Stratego invokes strategies and rules may be a bit
    unconventional to some people. We have already seen that 
    the language allows overloading on name, i.e. you can have
    multiple strategies with the same name, and also multiple
    rules with the same name. You can even have rules and
    strategies which share a common name. When invoking a 
    name, say <code>s</code>, all rules and strategies with
    that name will be considered, by trying all of them in
    some order, until one succeeds. The language does not
    specify the order which the alternatives will be tried.
    If <code>Eval</code> is called, 
  </para>
  </formalpara>

<screen>
 Eval:
 If(t, e1, e2) -> ...
 
 Eval:
 If(False, e1, e2) -> e2
</screen>  

  <para>
    If you want to control the order a set of rules should
    be tried on, you must name each alternative differently,
    and make a new strategy of application betwee
  </para>

  <formalpara>
    <title>Combinator Precedence</title>
    
  <para>
    The precedence of the composition operator (<code>;</code>) is higher
    than that of the choice operators (<code>&lt;+</code>,<code>+</code>,
    <code>&gt;+</code>). This means that the expression
    <code>s1 &lt; s2 ; s3</code> should be read as
    <code>s1 &lt; (s2 ; s3)</code>, and similarly for non-deterministic
    choice (<code>+</code>) and right choice (<code>&gt;+</code>). See
    <xref linkend="choice"/> for a more detailed treatment.
  </para>    
  </formalpara>
  
  <formalpara>
    <title>Guarded Choice vs <code>if-then-else</code></title>
      
  <para>
	The difference between <code>if s1 then s2 else s3 end</code> and
	<code>s1 &lt; s2 + s3</code> (guarded choice) is whether or not
	the result after <code>s1</code> is passed on to the branches.
	For <code>if-then-else</code>, <code>s2</code> (or
	<code>s3</code>) will be applied to the original term, that is,
	the effects of <code>s1</code> are unrolled before proceeding
	to the branches. With the guarded choice, this unrolling does
	not happen. Refer to <xref linkend="stratego-guarded-choice"/>
	for details.
  </para>
  </formalpara>
  
  <formalpara>
    <title>Variable Scoping</title>
    
  <para>
    Stratego enforces a functional style, with scoped variables. Once
    a variable has been initialized to a value inside a given scope,
    it cannot be changed. Variables are <emphasis>immutable</emphasis>.
    Any attempt at changing the value inside this scope will result
    in a failure. This is generally a Good Thing, but may at times
    be the cause of subtle coding errors. Consider the code below:
  </para>
  </formalpara>

<screen>
<prompt>stratego></prompt> &lt;map(\ x -> y where !x => y \)> [1]
[1]
<prompt>stratego></prompt> &lt;map(\ x -> y where !x => y \)> [1,1,1,1]
[1,1,1,1]
<prompt>stratego></prompt> &lt;map(\ x -> y where !x => y \)> [1,2,3,4]
command failed
</screen>    

  <para>
    Apparently, the <code>map</code> expression works for a singleton
    list, a list with all equal elements, but not lists with four different
    elements. Why? Let us break this conondrum into pieces and attack
    it piece by piece.
  </para>
  
  <para>
    First, the inline rule <code>\ x -> y where !x => y \</code> will
	be applied to each element in the list, by <code>map</code>. For
	each element, it will bind <code>x</code> to the element, then
	build <code>x</code> and assign the result to <code>y</code>. 
    Thus, for each element in the list, we will assign this element
    to <code>y</code>. This explains why it works for lists
    with only one element; we never reassign to <code>y</code>. But why
    does it work for lists of four equal elements? Because the rule
    about immutability is not violated: we do not
    <emphasis>change</emphasis> the value of <code>y</code> by
    reassigning the same value to it.
  </para>
  
  <para>
    But why does this happen? We clearly stated that we want a local
    rule here. The gotcha is that Stratego separates control of scopes
    from the local rules. A separate scoping construct, 
    <code>{y: s}</code> must be used to control the scoping of
    variables. If no scoping has been specified, the scope of a 
    variable will be that of its enclosing named strategy. Thus, the code
    above must be written:
  </para>    

<screen>
<prompt>stratego></prompt> &lt;map({y: \ x -> y where !x => y \})> [1,2,3,4]
[1,2,3,4]
</screen>    

  <para>
    It may be a bit surprising that this works. We have not said anything
    about <code>x</code>, so logically, we should not be able to change
    this variable either. The difference between <code>x</code> and 
    <code>y</code> is that <code>x</code> is a pattern variable. Its
    lifetime is restricted to the local rule. At first glance, this may
    seem a bit arbitrary, but after you code a bit of Stratego, it will
    quickly feel natural.
  </para>

</section>

</section>

<section>
  <title>Debugging XT compositions</title>
  <para></para>
<screen>
 - checking component registration
 - checking configuration file accesses
  - strace
 - xtc shell?
 - format checkers
</screen>
</section>

<section>
  <title>Debugging SDF definitions</title>
  <para></para>
<screen>
 - SDF tools
  - sdfchecker
  - sdf2parenthesize
 - concrete syntax
  - correct .meta file
  - reserved metavariables
  - ambiguities
</screen>
</section>

</chapter>
