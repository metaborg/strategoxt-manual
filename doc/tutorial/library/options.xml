<chapter
   xml:id="library-options"
   xmlns="http://docbook.org/ns/docbook"
   xmlns:xi="http://www.w3.org/2003/XInclude">

  <title>Command-line Options (*)</title>
  
  <para>
    As <xref linkend="tutorial-xt"/> explained, the world of
    Stratego is one of small programs tied together using
    Unix pipes. The pipes carry the data, while configuration
    and control is passed between programs in the form of
    command line arguments. Incidentally, this is the same
    mechanism used by humans to invoke programs, and this
    eases understanding and debugging of XT compositions
    tremendously. Details about  debugging is covered in
    <xref linkend="library-debugging"/>. In this chatper, 
    we will cover the mechanism available in Stratego for
    working with command line arguments.
  </para>
  
  <para>
    When a compiled Stratego program is first started, 
    the initial value of the current term is a list
    containing the command line arguments to the program.
    Fhe following program, <command>foo</command>, is a
    genuine "do nothing" program.
  </para>
  
<screen>
module foo
imports
  liblib
strategies
  main = id
</screen>

  <para>
    In the course of this chapter, we will extend this program
    with new options and even a help screen for the user to 
    enjoy. But first, let us compile and run <command>foo</command> 
    with some arguments, to get an idea of where we stand.
  </para>
  
<screen>
<prompt>$</prompt> strc -i foo.str
...
<prompt>$</prompt> ./foo --help
["./foo","--help"]
<prompt>$</prompt> ./foo -i foo.str --extra --option -s
["./foo","-i","foo.str","--extra","--option","-s"]
</screen>

  <para>
    From this interaction, we see that a list of the
    arguments provided on the command line becomes the
    initial term of the program. Each command line argument
    becomes its own string element in the list, and the first
    element of the list is the command used to invoke the
    <command>foo</command> itself. Clearly, this list must be
    interpreted somehow, for the arguments to have any meaning.
    The library contains a collection of robust strategies
    that deal with just this. The option handling strategies
    will parse the argument list, let you set default values
    for options and transparently deal with long and short
    forms of the same option. Even more interesting, the
    library provides so-called <code>wrap</code> strategies
    that abstract away all of the dreary details of this
    option handling, and also provide a default set of
    options with some basic functionality.
  </para>
    
  <para>
    Perhaps the most frequently used wrap strategy is 
    <code>io-wrap</code> (or its XTC equivalent,
    <code>xtc-io-wrap</code>, which is not covered here).
    In fact, <code>io-wrap</code> is a family of strategy,
    which includes <code>io-wrap(s)</code>, 
    <code>io-wrap(opts, s)</code> and
    <code>io-wrap(opts, usage, about, s)</code>. All of
    these variants provide the same basic functionality. The
    increasing number parameters allows you to override
    default bevhavior, when you need to. When using
    one of these strategies, a standard package of
    command line handling will be provided to your users
    through your program. Let us start with the simplest
    case, <code>io-wrap(s)</code> and work our way from
    there. Consider a revised edition of <command>foo</command>,
    from above:
  </para>
  
<screen>
module foo
imports
  liblib
strategies
  main = io-wrap(id)
</screen>

  <para>
    Here, we wrap the core logic of our program (just <code>id</code>
    in our case) inside the <code>io-wrap</code>er. If we run
    <command>foo</command> with the <option>--help</option>
    this time around, we will get a more instructive reply than
    previously: 
  </para>
  
<screen>
<prompt>$</prompt> ./foo --help
Options:
   -i f|--input f   Read input from f
   -o f|--output f  Write output to f
   -b               Write binary output
   -S|--silent      Silent execution (same as --verbose 0)
   --verbose i      Verbosity level i (default 1)
                    ( i as a number or as a verbosity descriptor:
                      emergency, alert, critical, error,
                      warning, notice, info, debug, vomit )
   -k i | --keep i  Keep intermediates (default 0)
   --statistics i  Print statistics (default 0 = none)
   -h|-?|--help     Display usage information
   --about          Display information about this program
   --version        Same as --about

Description:
</screen>
  
  <para>
    All of a sudden, our program is a well-behaved citizen
    in the command line world. It answers to
    <option>--help</option>, and appears to have a few other
    tricks up its sleeve to. For example, the input term
    to <command>foo</command> can now be specified using the 
    <code>-i</code> option, and output can be stored to
    a file using the <code>-o</code> option. 
  </para>

  <para>
    So does this actually work? All for free? Let's test with
    putting the following term into the file
    <filename>term.trm</filename>:
  </para>  
  
<screen>
Yes(It(Works))
</screen>
  
  <para>
    Bursting with excitement, we try:
  </para>

<screen>
<prompt>$</prompt> ./foo -i term.trm
Yes(It(Works))
</screen>   

  <para>
    And if that's not enough, there is even a bit of extra
    convenience provided by <code>io-wrap</code>: If
    <option>-i</option> is not provided,
    <filename>stdin</filename> is read. Similarly,
    <filename>stdout</filename> is written to if
    <option>-o</option> is not specified.
  </para>

  <para>
    So, using <code>io-wrap</code> is all you have to do for your program
    to gain a minimal, but functional set of command line options. As a
    bonus, these options also make your program compatible with XTC; it
	can be composed with other XTC components.
  </para>

  <formalpara>
    <title>Adding Options</title>
    
    <para>
      It is often necessary for programs to expose switches to turn
      functionality on and off, or to read extra configuration knowledge
      from additional files. All these cases require additional command
      line options, so we need a mechanism for extending
      the basic <code>io-wrap(s)</code> strategy. The preferred way of
      adding new options is to use the <code>io-wrap(opts,s)</code>
      strategy, providing it with a strategy encoding the options.
    </para>
  </formalpara>
  
    <para>
      When adding a new option, we must decide whether this option
      will require a argument of its own, or not. The term 
      <code>ArgOption</code> is used to construct options that take
      arguments and <code>Option</code> is the term used for on/off
      switches. Suppose we want to expose an option 
      <option>--verify</option> that enables the user to run our
      transformation in a self-verifying mode. This is clearly an
      on/off switch, and therefore a job for <code>Option</code>.
    </para>

    <para>
      Adding this option to our program <command>foo</command> 
      makes our program look like this:
    </para>
    
<screen>
module foo
imports
  liblib
signature
  constructors
    Conservative : Option

strategies

  main =  io-wrap(
    Option(
        "--verify"
      , &lt;set-config> (Verify(), "on")
      , !"--verify         Turn on verification")
    , id)
</screen>
    
    <para>
      Note that we made a new term type, <code>Verify</code>, to serve as
      our switch symbol. Our sample program is just <code>id</code>, but
      in a more realistic program, we would write
      <code>&lt;get-config> Verify</code> to get the state of the 
      <code>Verify</code> switch. In the case where the user had specified
      <option>--verify</option> on the command line, 
      <code>get-config</code> would result in the term <code>"on"</code>, 
      taken from the declaration of our <code>Option</code>, above. If
      the user had not added <option>--verify</option> to his command
      line arguments, <code>get-config</code> would fail.
    </para>
    
    <para>
      The usage of options with arguments, <code>ArgOption</code>,
      is very much the same. Assume our transformation needs a bit of
      help from configurable processing tables, and that we want these
      specified using the <option>-p</option> option. We would add
      another alternative to the <code>opts</code> argument of
      <code>io-wrap</code>:
    </para>
    
<screen>
  main = io-wrap(
     Option(....)
     + 
     ArgOption(
        "-p"
       , where(&lt;extend-config> ("-p", [&lt;id>]))
       , !"-p file   Use processing table in file")
     , id)
</screen>  

    <para>
      Again, the value (the filename) provided to the <option>-p</option>
      is returned by the <code>get-option</code> strategy. Sometimes, it
      is a bit annoying that <code>get-option</code> fails for certain
      arguments. If you browse through Stratego code, you may come across
      the following idiom for dealing with this situation:
    </para>
    
<screen>
  get-config-p =
    &lt;get-config> "-p" &lt;+ ![]
</screen>

    <para>
      That is all you need to know about basic command-line option
      processing. As usual, detailed API documentation is available in
      the API reference.
    </para>

  <formalpara>
    <title>Setting Description and About</title>
    
    <para>
	  If your program is primarily intended for human use, you are
	  encouraged to complete your program's option configuration with
	  a short description of what your tool does.
    </para>
  </formalpara>

  <para>
    We can easily add a short description and also an about section.
    The description is shown as part of the help screen 
    (displayed with <option>--help</option>), whereas the about
    section is displayed when the arguments to <command>foo</command>
    contain <option>--about</option>. It is customary for the about
    screen to contain copyright notices and credits.
  </para>
  
<screen>  
  main = io-wrap(
        ...
      , foo-tool-usage
      , foo-tool-about
      , id)

  foo-tool-usage =
    default-system-usage(
      !["Usage: foo -p proctbl [options]"]
    , ![ "This program verifies the input against a processing table.\n"]
    )

  foo-tool-about =
     &lt;echo> "Written by Alan Turing &lt;alan@turing.org>"
</screen>

  <para>
    After compiling this version of <command>foo</command>, invoking
    it with <option>--help</option> give the following help screen:
  </para>
  
<screen>
<prompt>$</prompt> ./foo --help
Usage: foo -p proctbl [options]

Options:
   --verify         Turn on verification
   -p file          Use processing table in file
   -i f|--input f   Read input from f
   -o f|--output f  Write output to f
   -b               Write binary output
   -S|--silent      Silent execution (same as --verbose 0)
   --verbose i      Verbosity level i (default 1)
                    ( i as a number or as a verbosity descriptor:
                      emergency, alert, critical, error,
                      warning, notice, info, debug, vomit )
   -k i | --keep i  Keep intermediates (default 0)
   --statistics i  Print statistics (default 0 = none)
   -h|-?|--help     Display usage information
   --about          Display information about this program
   --version        Same as --about

Description:
This program verifies the input against a processing table.
</screen>

  <para>
    If we invoke our splendid program <command>foo</command> with
    the <option>--about</option> option, we can now observe:
  </para>

<screen>
<prompt>$</prompt> ./foo --about
Written by Alan Turing &lt;alan@turing.org>
</screen>  

  <formalpara>
    <title>option-wrap</title>

    <para>
      It is not always the case that programs written in Stratego are
      used for processing ATermsome rare cases, the full I/O functionality provided by
      <code>io-wrap</code> is not appropriate. In these cases, you
      can use the <code>option-wrap</code> family of strategies.
      <code>option-wrap</code> works analogously to <code>io-wrap</code>,
      but dooes not provide the <option>-i</option> and
      <option>-o</option> options, nor does it read anything from
      <filename>stdin</filename> automatically.
    </para>
  </formalpara>
  
  <para>
    The default set of options proveded by <code>option-wrap</code>
    is shown below:
  </para>
  
<screen>    
   --verify         Turn on verification
   -h|-?|--help     Display usage information
   --about          Display information about this program
   --version        Same as --about
</screen>
    
</chapter>

