<chapter
   xmlns="http://docbook.org/ns/docbook"
   xmlns:xi="http://www.w3.org/2003/XInclude">

  <title>I/O</title>

  <para>
    This chapter explains the strategies available in the
    library for controlling file and console I/O.
  </para>
  
  <para>
    The need for traditionally file I/O is somewhat diminished
    for typical applications of Stratego. Normally, Stratego 
    programs are designed to worktogether connected by Unix
    pipes. The programs employ <code>io-wrap</code> (or similar
    strategies) that automatically take care of the input and
    output. See the chapter on 
    <link linkend="library-options">options</link> for details.
  </para>

  <para>
    The primitive layer of Stratego I/O inherits its 
    characteristics from Unix. The basic I/O strategies
    recognize the special files <code>stdout</code>, 
    <code>stdin</code> and <code>stderr</code>. Streams are
    opened by <code>fopen</code> and closed with
    <code>fclose</code> On top of this, a collection of
    more convient strategies have been built.
  </para>

  <section>
    <title>Console I/O</title>

  <para>
    The basic strategies for console I/O <code>print</code>
    and <code>printnl</code> are used to write terms to
    <code>stdout</code> or <code>stderr</code> (or any 
    other opened file). They both take a tuple. The first
    element of the tuple is the file to write to, the
    second is a list of terms. Each term in the list be
    converted to a string, and and these strings will
    be concatenated together to form the resulting output.
    The <code>printnl</code> will also append a newline to
    the end of the resulting string.
  </para>

  <para>
    The following module should be compiled with
    <command>strc</command>, as usual.
  </para>
    
<screen>
module example
imports lib
strategies

  main = 
    &lt;print> (stdout, ["baz"])
    &lt;printnl> (stdout, [ "foo", 0, "bar" ])
</screen>

  <para>
    After compiling this file, running it will give the
    following result:
  </para>

<screen>
<prompt>$</prompt> ./example
bazfoo0bar
<prompt>$</prompt>
</screen>

  <para>
    Notice how the string <code>baz</code> will be written
    without a newline (or other space). Also, notice how the
    terms in the list argument were concatenated.
  </para>
  
  <para>
    When using these strategies in the in the Stratego Shell,
    some care must be taken when using the <code>std*</code>
    files, as the following example shows.
  </para>

<screen>
<prompt>stratego></prompt> &lt;printnl> (stdout(), [ "foo", 0, "bar" ])
foo0bar
</screen>  

  <para>
    The shell requires that you put an extra parenthesis after the
    <code>stdout</code>.
  </para>
  
  <para>
    The <code>debug</code> and <code>error</code> are convenience
    wrappers around <code>printnl</code>. They will always write
    their result to <code>stderr</code>. The <code>error</code>
    strategy is defined as:
  </para>
  
<screen>
error =
  where(&lt;printnl> (stderr, &lt;id>))
</screen>  

  <para>
    It is used similarly to the <code>printnl</code> strategy:
  </para>    

<screen>
<prompt>stratego></prompt> &lt;error> ["foo", 0, "bar"]
foo0bar
</screen>  
  
  <para>
    The <code>debug</code> strategy accepts any term, i.e.
    not only lists of terms. The term will be written
    verbatim:
  </para>

<screen>
<prompt>stratego></prompt> &lt;debug> [ "foo", 0, "bar" ]
["foo",0,"bar"]
</screen>

  </section>
  
  <section>
    <title>Path and Directory Operations</title>
  
  <para>
    The library provides a small set of simple file and directory
    manipulation operations. Assume the directory 
    <code>/tmp</code> only contains the files 
    <filename>foo</filename>, <filename>bar</filename>,
    <filename>baz</filename>.
  </para>
  
<screen>
<prompt>stratego></prompt> &lt;readdir> "/tmp"
["foo","bar","baz"]
<prompt>stratego></prompt> &lt;rename-file> ("/tmp/foo", "/tmp/bax")
"/tmp/bax"
<prompt>stratego></prompt> &lt;remove-file> "/tmp/baz"
[]
<prompt>stratego></prompt> &lt;link-file> ("/tmp/bar", "/tmp/foo")
"/tmp/foo"
<prompt>stratego></prompt> &lt;link-file> ("/tmp/bar", "/tmp/foo")
"/tmp/foo"
</screen>
 
  <para>
    <code>is-abspath</code>
    <code>new-temp-dir</code>
    <code>isdir</code>
    <code>isatty</code>
    <code>isfifo</code>
    <code>islnk</code>
    <code>file-exists</code>
    <code>dirname</code>
    <code>find-file</code>
    <code>is-executable</code>
    <code>is-readable</code>
    <code>is-writeable</code>
    <code>get-extension</code>
    <code>base-filename</code>
    <code>abspath</code>
  </para>
  </section>
  
  <section>
    <title>File and Text I/O</title>

    <para>
      Opening a file is done with the <code>fopen</code> strategy. It takes
      a two-element tuple, the first element is the filename as a string,
      the second is the open mode, which is also a string. The most important
      modes are read (<code>r</code>); write ("w") which opens and empty file
      for writing, truncating any existing file with the same name; and 
      append (<code>a</code>) which appends to the file if it already exists.
      After all file operations stream have been finished, it should be closed
      with <code>fclose</code>, which will flush and close the file. Explicit
      flushing can also be done with <code>fflush</code>.
    </para>
    
    <para>
      It should be pointed out that reading and writing text files with Stratego
      is rather rare. Normally, text files are read with a parser generated from
      an SDF description and written using a pretty-printer defined in the
      Box formalism. In rare cases, this may turn out be too heavy handed,
      especially if the file format is simplistic and line-based. In this
      instance, we can come up with an easier solution using  
      <code>read-text-file</code> and <code>read-text-line</code>.
    </para>

    <para>
      Assume the file <filename>/tmp/foo</filename> contains the following
      lines:
    </para>

<screen>
one
two
three
</screen>

    <para>
      We can read this file in one big chunk into a string with the
      <code>read-text-file</code> strategy, which must be applied to
      a filename:
    </para>    
    
<screen>
stratego> &lt;read-text-file> "/tmp/foo"
"one\ntwo\nthree\n"
</screen>

   <para>
     Alternatively, for example if the file is large, we can read it
     line by line. In this scenario, we must open the file and get
     a handle to a stream.
   </para>

<screen>      
<prompt>stratego></prompt> &lt;fopen> ("foo.txt", "r") => inp
Stream(136788400)
<prompt>stratego></prompt> &lt;read-text-line> inp
"one"
</screen>

  </section>
  
  <section>
    <title>Term I/O</title>
    
  <para>
    The primary form of file I/O you will be using in Stratego is
    reading and writing terms. As explained earlier, the terms
    are stored on disk as either binary, compressed text or
    plain text ATerms. Reading a term, no matter which storage
    format, is done with the <code>ReadFromFile</code> strategy.
    It is applied to a filename.
  </para>

<screen>
<prompt>stratego></prompt> &lt;ReadFromFile> "/tmp/foo.trm"
Foo(Bar)
</screen>

  <para>
    To write a term to file, you can use <code>WriteToTextFile</code>
    or <code>WriteToBinaryFile</code>. The binary format is
    approximately eight times more space-efficient on average. Both
    strategies take a two-element tuple where the first element is
    the filename and second is the term to write. Writing the current
    term requires a minor twist, which is shown here:
  </para>  

<screen>
<prompt>stratego></prompt> &lt;WriteToBinaryFile> ("/tmp/bar.trm", &lt;id>)
Foo(Bar)
</screen>  

  <para>
    It is also possible to read and write terms from and to strings,
    using <code>read-from-string</code> and <code>write-to-string</code>.
    The chapter on <link linkend="library-strings">strings</link>
    contains explanation of how these strategies work.
  </para>
  
  </section>

  <section>
    <title>Logging</title>
    
  <para>
    <code>log</code>
    <code>log(|severity, msg)</code>
    <code>log(|severity, msg, term)</code>
  </para>
  </section>
</chapter>

