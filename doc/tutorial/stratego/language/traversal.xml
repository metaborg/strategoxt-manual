<chapter
  xml:id="stratego-traversal-strategies"
  xmlns="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2003/XInclude">

  <title>Traversal Strategies (*)</title>

<para>

  In <xref linkend="stratego-rewriting-strategies"/> we saw a number
  of idioms of strategic rewriting, which all involved <emphasis>tree
  traversal</emphasis>.

  In the previous chapters we saw how strategies can be used to
  control transformations and how rules can be broken down into the
  primitive actions match, build and scope.

  The missing ingredient are combinators for defining traversals.

 </para>

<para>

  There are many ways to traverse a tree. For example, a bottom-up
  traversal, visits the subterms of a node before it visits the node
  itself, while a top-down traversal visits nodes before it visits
  children. One-pass traversals traverse the tree one time, while
  fixpoint traversals, such as innermost, repeatedly traverse a term
  until a fixpoint is reached.

 </para>

<para>

  It is not attractive to provide built-in implementations for each
  traversal algorithm. Rather we would like to define traversals in
  terms of the primitive ingredients of traversal.  For example, a
  top-down, one-pass traversal strategy will first visit a node, and
  then descend to the children of a node in order to
  <emphasis>recursively</emphasis> traverse all subterms.  Similarly,
  the bottom-up, fixpoint traversal strategy
  <emphasis>innermost</emphasis>, will first descend to the children
  of a node in order to <emphasis>recursively</emphasis> traverse all
  subterms, then visit the node itself, and possibly recursively
  reapply the strategy.

 </para>

<para>

   This suggests that a full term traversal can be composed from a
   one-step descent to the children of a node and recursive
   closure. Thus, we need an operator which applies a strategy to one
   or more direct subterms.  By separating this one-step descent
   operator from recursion, and making it a first-class operation,
   many different traversals can be defined.

 </para>

<para>

  In this chapter we explore the ways in which Stratego supports the
  definition of <emphasis>traversal strategies</emphasis>.

  <emphasis>Congruences operators</emphasis> provide data-type
  specific traversal combinators. <emphasis>Generic traversal
  operators</emphasis> support data type independent definitions of
  traversals, which can be reused for any data type.

</para>

<section>
  <title>Congruence Operators</title>

<para>
      
  A congruence operator applies a strategy to each direct subterm of a
  specific constructor. A congruence fails if the application of one
  the argument strategies fails or if constructor of the operator and
  that of the term do not match.
    
</para>

<screen>
Plus(Int("14"),Int("3"))
<prompt>stratego></prompt> Plus(!Var("a"), id)
Plus(Var("a"),Int("3"))
</screen>	

<para>
      
  For each n-ary constructor c declared in a signature, there is a
  corresponding <emphasis>congruence operator</emphasis> <code>c(s1 ,
  ..., sn )</code>, which applies to terms of the form <code>c(t1 ,
  ..., tn )</code> by applying the argument strategies to the
  corresponding argument terms.
    
</para>

<para>
      
  The congruence operator is used e.g. in conjunction with the
  recursive traversal operator to define specific data structure
  traversals.
    
</para>

<para>
      
  Congruences can also be applied to tuples,
  <code>(s1,s2,...,sn)</code>, and lists,
  <code>[s1,s2,...,sn]</code>. A special list congruence is
  <code>[]</code> which 'visits' the empty list.
    
</para>

<para>
      
  A good example of the use of list congruences is the
  <code>map(s)</code> strategy.
    
</para>

    <screen>  
map(s) = Nil() + Cons(s, map(s))

fetch(s) = Cons(s, id) &lt;+ Cons(id, fetch(s))

filter(s) = Nil + (Cons(s, filter(s)) &lt;+ ?Cons( , &lt;id>); filter(s))
</screen>

    <screen>  
map(s) = [] + [s | map(s)])

fetch(s) = [s | id] &lt;+ [id | fetch(s)]

filter(s) = [] + ([s | filter(s)] &lt;+ ?[ |&lt;id>]; filter(s))
</screen>

<para>
      
  Example: constant folding
    
</para>

<screen>
BinOp(PLUS(), Int("14"), Int("3")) 
stratego> EvalBinOp 
Int("17")
</screen>   

<screen>
const-fold =
  BinOp(id, const-fold, const-fold); try(EvalBinOp)
  &lt;+ Call(id, map(const-fold)); try(EvalCall)
  &lt;+ If(const-fold, const-fold, const-fold); try(EvalIf)
</screen>

<screen>
BinOp(TIMES(), 
  If(BinOp(PLUS(),Int("14"),Int("3")),Int("2"),Int("23")),
  Int("4") 
)
stratego> const-fold 
Int("8")
</screen>   

    
<para>
      
Example: format checking

Format checking 

Describe a subset of a term language using a recursive pattern 

Applications 

Verify output (testing) 

Verify input (pre-condition) 

Documentation

Describe format of terms in normal form 
    </para>

    
<screen>
conj(s) = rec x(And(x, x) &lt;+ s)
disj(s) = rec x(Or(x, x) &lt;+ s)

// Conjunctive normal form
conj-nf = conj(disj(Not(Var(x)) + Var(x)))

// Disjunctive normal form
disj-nf = disj(conj(Not(Var(x)) + Var(x)))
</screen>   
 
</section>

<section>
  <title>Generic Traversal: Visiting All Subterms</title>
      
<para>
    
  Using the congruence operators for all constructors in a type, one
  can define a one-step traversal for that type, which can be composed
  into all kinds of full traversals. However, the combination of
  congruence strategies and the traversals built using them have to be
  redone for each data type. Instead of using such
  <emphasis>type-specific</emphasis> traversal strategies, it is
  desirable to use <emphasis>generic</emphasis> strategies that work
  on any data type.

</para>

<para>
    
  Stratego provides generic traversal by means of several
  <emphasis>generic one-step descent operators</emphasis>. The
  operator <code>all</code>, applies a strategy to all direct
  subterms.  The operator <code>one</code>, applies a strategy to one
  direct subterm, and the operator <code>some</code>, applies a
  strategy to as many direct subterms as possible, and at least one.
  It will turn out later in this chapter that <code>all</code>,
  <code>one</code>, and <code>some</code> can be defined in terms of
  still more primitive operations. That does not change the usefulness
  of these notions, however,

      
  Generic traversal operators

  Data-type specific traversal requires tedious enumeration of cases 

  Even if traversal behaviour is uniform 

  Generic traversal allows concise specification of default traversals
  
</para>

<para>
	
  The <code>all(s)</code> strategy transforms a constructor
  application by applying the parameter strategy <code>s</code> to
  each direct subterm. An application of <code>all(s)</code> fails if
  the application to one of the subterms fails.
  
</para>

<screen>
Plus(Int("14"),Int("3"))
<prompt>stratego></prompt> all(!Var("a"))
Plus(Var("a"),Var("a"))
</screen>

<para>
	
  Using the <code>all</code> traversal primitive we can define generic
  traversal strategies like <code>topdown</code> and
  <code>bottomup</code>.

  The most general class of traversals visits every node of a term and
  applies a transformation to it. The following operators define
  traversals that apply a strategy <code>s</code> to all nodes of a
  term.
  
</para>

<screen>
bottomup(s) = all(bottomup(s)); s
topdown(s)  = s; all(topdown(s))
downup(s)   = s; all(downup(s)); s
alltd(s)    = s &lt;+ all(alltd(s))
</screen>

<screen>
const-fold = bottomup(try(EvalBinOp &lt;+ EvalCall &lt;+ EvalIf))
</screen>

  
<para>

  \paragraph{Topdown}

  The strategy <code>topdown(s)</code> first visits a node before it
  descends to the subterms, <code>bottomup(s)</code> first transforms
  subterms before applying <code>s</code> to a node, and
  <code>downup(s)</code> applies the transformation <code>s</code> on
  the way down and again on the way up. Since <code>s</code> is
  applied at every subterm, these traversals only succeed if
  <code>s</code> succeeds everywhere. Therefore, these traversals are
  typically applied in combination with <code>try</code> or repeat.

  For example, a constant folding transformation for proposition
  formulae can be defined as a bottom-up traversal that repeatedly
  applies one of the truth-rules <code>T</code>.
    
<screen>
  eval = bottomup(repeat(T))
</screen>
    
    The following derivation illustrates the behaviour of
    this strategy
  </para>

  <para>
    Similarly, a desugaring transformation for propositions, which
    defines implication and equivalence in terms of other
    connectives can be defined as a <code>topdown</code> traversal which
    tries to apply one of the rules <code>DefI</code> or <code>DefE</code> at
    every subterm.


    Example: Desugaring Expressions
  </para>

<screen>
DefAnd : And(e1, e2) -> If(e1, e2, Int("0")) 

DefPlus : Plus(e1, e2) -> BinOp(PLUS(), e1, e2) 

DesugarExp = DefAnd &lt;+ DefPlus &lt;+ ... 

desugar = topdown(try(DesugarExp)
</screen>

<screen>
IfThen(And(Var("a"),Var("b")), Plus(Var("c"),Int("3")))
stratego> desugar 
IfThen(If(Var("a"),Var("b"),Int("0")), BinOp(PLUS,Var("c"),Int("3")))
</screen>

  <para>

    \paragraph{Topdown vs Bottomup}

    To see why this transformation should use a <code>topdown</code>
    rather than a <code>bottomup</code> traversal, consider the following
    derivation based on the definitions
    
<screen>
  desugar = bottomup(try(D))
  D       = DefI + DefE
  DefI    : I(x, y) -> O(N(x), y)
  DefE    : E(x, y) -> A(I(x, y), I(y, x))
</screen>


    Since a the subterms of a node are traversed
    <emphasis>before</emphasis> the node itself is visited, this
    transformation misses the application of the implications
    (<code>I</code>), originating from the application of the
    <code>DefE</code> rule. When <code>desugar</code> is defined
    using a <code>topdown</code> traversal
    
<screen>
  desugar = topdown(try(D))
</screen>

    this problem does not arise.
  </para>

  <para>

    \paragraph{Repeated Application}

    In case one rule produces a term to which another desugaring
    rule can be used, the desugaring strategy should repeat
    the application of rules to each subterm.
    
<screen>
  impl-nf = topdown(repeat(DefN + DefA2 + DefO1 + DefE))
</screen>

    Term traversals can be categorized into classes according to
    how much of the term they traverse and to which parts
    of the term they modify.

\subsection{Paramorphism}

    A variation on bottomup is a traversal that also provides the
    original term as well as the term in which the direct subterms
    have been transformed. (also known as a paramorphism?)

<screen>
  bottomup-para(s) = &lt;s>(&lt;id>, &lt;all(bottomup-para(s))>)
</screen>

\subsection{Skipping Subtrees}

    The traversals above go through all constructors. If it
    is not necessary to traverse the entire tree, the following
    versions of the traversals can be used. They are parameterized
    with a strategy operator <code>stop</code> that

<screen>
  topdownS(s, stop: (a -> a) * b -> b) =
    rec x(s; (stop(x) &lt;+ all(x)))

  bottomupS(s, stop: (a -> a) * b -> b) =
    rec x((stop(x) &lt;+ all(x)); s)

  downupS(s, stop: (a -> a) * b -> b) =
    rec x(s; (stop(x) &lt;+ all(x)); s)

  downupS(s1, s2, stop: (a -> a) * b -> b) =
    rec x(s1; (stop(x) &lt;+ all(x)); s2)
</screen>

    The strategy <code>don't-stop</code> is a unit for these traversals,
    i.e., <code>topdown(s)</code> is equivalent
    to <code>topdown(s,don't-stop)</code>.

<screen>
  don't-stop(s) = fail
</screen>

\subsection{Along a Spine}

    A spine of a term is a chain of nodes from the root to some
    subterm. <code>spinetd</code> goes down one spine and applies
    <code>s</code> along the way to each node on the spine. The
    traversal stops when <code>s</code> fails for all children
    of a node.

<screen>
  spinetd(s)  = s; try(one(spinetd(s)))
  spinebu(s)  = try(one(spinebu(s))); s
  spinetd'(s) = s; (one(spinetd'(s)) + all(fail))
  spinebu'(s) = (one(spinebu'(s)) + all(fail)); s
</screen>

\subsection{Along all Spines}

    Apply <code>s</code> everywhere along al spines where
    <code>s</code> applies.

<screen>
  somespinetd(s) = rec x(s; try(some(x)))
  somespinebu(s) = rec x(try(some(x)); s)
  spinetd'(s)    = rec x(s; (one(x) + all(fail)))
  spinebu'(s)    = rec x((one(x) + all(fail)); s)
</screen>

\subsection{Once}

    Apply s at one position. One s application has to succeed.

<screen>
  oncetd(s) = rec x(s &lt;+ one(x))
  oncebu(s) = rec x(one(x) &lt;+ s)
</screen>

<screen>
  oncetd-skip(s, skip: (a -> a) * b -> b) =
    rec x(s &lt;+ skip(x) &lt;+ one(x))
</screen>

\subsection{At Least Once}

    Apply s at some positions, but at least one. As soon as one is
    found, searching is stopped, i.e., in the top-down case
    searching in subtrees is stopped, in bottom-up case, searching
    in upper spine is stopped.

    One-pass traversals
    
<screen>
  sometd(s) = rec x(s &lt;+ some(x))
  somebu(s) = rec x(some(x) &lt;+ s)
</screen>

\subsection{Frontier}

    Find all topmost applications of <code>s</code>;

<screen>
  alltd(s) =rec x(s &lt;+ all(x))
  alldownup2(s1, s2) = rec x((s1 &lt;+ all(x)); s2)
  alltd-fold(s1, s2) = rec x(s1 &lt;+ all(x); s2)
</screen>

\subsection{Leaves}

<screen>
  leaves(s, is-leaf, skip: a * (a -> a) -> a) =
    rec x((is-leaf; s) &lt;+ skip(x) &lt;+ all(x))

  leaves(s, is-leaf) =
    rec x((is-leaf; s) &lt;+ all(x))
</screen>

\subsection{Many}

    Find as many applications as possible, but at least one.

<screen>
  manybu(s) = rec x(some(x); try(s) &lt;+ s)\
  manytd(s) = rec x(s; all(try(x)) &lt;+ some(x))
</screen>

<screen>
  somedownup(s) = rec x(s; all(x); try(s) &lt;+ some(x); try(s))
</screen>

<screen>
  breadthfirst(s) = rec x(all(s); all(x))
</screen>

\subsection{One-Pass Partial Traversals}

    While full traversals visit every node of a tree,
    partial traversals may stop at some point. An
    example is the <code>alltd(s)</code> strategy, which
    stops as soon as it has found a subterm to which
    <code>s</code> can be succesfully applied.

<screen>
  alltd(s) = s &lt;+ all(alltd(s))
</screen>

    If <code>s</code> does not succeed, the strategy is applied
    recursively at all direct subterms. This means that <code>s</code>
    is applied along a frontier of the subject term. This strategy
    is typically used in substitution operations in which subterms
    are replaced by other terms. For example, the strategy
    <code>alltd(?Var(x); !e)</code> replaces all occurrences of
    <code>Var(x)</code> by <code>e</code>.

    Note that <code>alltd(try(s))</code> is not a useful strategy.
    Since <code>try(s)</code> succeeds at the root of the term,
    no travesal is done.

  </para>

</section>


<section>

  <title>Generic Traversal: Visiting One Subterm</title>

  <para>
	The <code>one(s)</code> strategy transforms a constructor
	application by applying the parameter strategy <code>s</code>
	to exactly one direct subterm. An application of
	<code>one(s)</code> fails if the application to all of the
	subterms fails.
  </para>
	 
<screen>
Plus(Int("14"),Int("3"))
<prompt>stratego></prompt> one(!Var("a"))
Plus(Var("a"),Var("a"))
</screen>

  <para>
	We can use the <code>one</code> traversal primitive to define
	a strategy <code>contains</code>, which checks if the current
	term contains a given term.
   </para>

<screen>
oncetd(s)  = s &lt;+ one(oncetd(s)) 
oncebu(s)  = one(oncebu(s)) &lt;+ s 
spinetd(s) = s; try(one(spinetd(s))) 
spinebu(s) = try(one(spinebu(s))); s
</screen>
    
<screen>
contains(|t) = oncetd(?t)
</screen>

<screen>
reduce(s)     = repeat(rec x(one(x) + s)) 
outermost(s)  = repeat(oncetd(s)) 
innermostI(s) = repeat(oncebu(s))
</screen>

</section>

<section>
      
  <title>Generic Traversal: Visiting Some Subterms</title>

  <para>
	The <code>some(s)</code> strategy transforms a constructor
	application by applying the parameter strategy <code>s</code>
	to as many direct subterms as possible and at least one. An
	application of <code>some(s)</code> fails if the application
	to all of the subterms fails.
  </para>

<screen>
sometd(s) = s &lt;+ some(sometd(s)) 
somebu(s) = some(somebu(s)) &lt;+ s
</screen>

<screen>
reduce-par(s) = repeat(rec x(some(x) + s))
</screen>

</section>

<section>

   <title>Full Term Traversals</title>

   <para>
      The primitive term traversal operators of Stratego (all, some,
      one) can be combined with the other control operators in a wide
      variety of ways to define full term traversals.
   </para>

<section>

  <title>One-Pass traversals</title>

  <para>
	The most general class of traversals visits every node of a
	term and applies a transformation to it. The following
	operators define traversals that apply a strategy
	<code>s</code> to all nodes of a term.
  </para>

<screen><include href="xmpl/everywhere.str" parse="text" xmlns="http://www.w3.org/2003/XInclude"/></screen>

  <para>
	The strategy <code>topdown(s)</code> first visits a node
	before it descends to the subterms, <code>bottomup(s)</code>
	first transforms subterms before applying <code>s</code> to a
	node, and <code>downup(s)</code> applies the transformation
	<code>s</code> on the way down and again on the way up. Since
	<code>s</code> is applied at every subterm, these traversals
	only succeed if <code>s</code> succeeds everywhere. Therefore,
	these traversals are typically applied in combination with try
	or repeat.
  </para>

  <para>
	The traversals above go through all constructors. If it is not
	necessary to traverse the entire tree, the following versions
	of the traversals can be used.  They are parameterized with a
	strategy operator <code>stop</code> that will skip the
	irrelevant subtrees.
  </para>

<screen><include href="xmpl/skipping.str" parse="text" xmlns="http://www.w3.org/2003/XInclude"/></screen>

  <para>
	While full traversals visit every node of a tree, partial
	traversals may stop at some point. An example is the
	<code>alltd(s)</code> strategy, which stops as soon as it has
	found a subterm to which <code>s</code> can be succesfully
	applied.
  </para>

<screen><include href="xmpl/alltd.str" parse="text" xmlns="http://www.w3.org/2003/XInclude"/></screen>

  <para>
	If <code>s</code> does not succeed, the strategy is applied
	recursively at all direct subterms. This means that s is applied
	along a frontier of the subject term.  This strategy is typically
	used in substitution operations in which subterms are replaced
	by other terms. For example, the strategy <code>alltd(?Var(x);
	!e)</code> replaces all occurrences of <code>Var(x)</code> by
	<code>e</code>.
  </para>

  <para>
	Note that <code>alltd(try(s))</code> is not a useful
	strategy. Since <code>try(s)</code> succeeds at the root of
	the term, no traversal is done.
  </para>

</section>

</section>

<section>

  <title>Fixpoint Traversals</title>

  <para>
    One-pass traversals can be repeated to arrive at fixpoint
    traversals, which applies a strategy until no more
    transformations can be applied.

<screen>
  reduce(s)     = repeat(rec x(one(x) + s))
  outermost(s)  = repeat(oncetd(s))
  innermostI(s) = repeat(oncebu(s))
</screen>


<screen>
  reduce-par(s) = repeat(rec x(some(x) + s))
</screen>

    A typical example is the <code>innermost(s)</code> strategy,
    which reduces a subject term to normal form.

<screen>
  innermost(s) = bottomup(try(s; innermost(s)))
</screen>

    By instantiating the strategy with different sets of
    rules, different transformations can be defined:

<screen>
  dnf = innermost(DAOL + DAOR + DN + DMA + DMO)
  cnf = innermost(DOAL + DOAR + DN + DMA + DMO)
</screen>

<screen>
  innermost-memo(s) = rec x(memo(all(x); (s; x &lt;+ id)))
</screen>

    <code>innermost-tagged(s)</code> reduces the subject term by
    applying <code>s</code> to innermost redices first. Terms in
    normal form are tagged (using attributes) to prevent renormalization.

<screen>
  innermost-tagged(s) =
    where(new => tag);
    rec x(?_{tag} &lt;+ (all(x); (s; x &lt;+ !&lt;id>{tag})));
    bottomup(?&lt;id>{tag})
</screen>

  </para>

<screen>
innermost(s) = bottomup(try(s; innermost(s))) 
</screen>

  <para>
Normalization 
  </para>

<screen>
dnf = innermost(DAOL &lt;+ DAOR &lt;+ DN &lt;+ DMA &lt;+ DMO)

cnf = innermost(DOAL &lt;+ DOAR &lt;+ DN &lt;+ DMA &lt;+ DMO)
</screen>

</section>

<section>
   <title>Idioms</title>

   <para>
     Control over strategy admits wide variety of transformation idioms 

     Cascading transformations (rewriting, exhaustive application) 

<screen>
simplify =
  innermost(R1 &lt;+ ... &lt;+ Rn)

innermost(s) = 
  bottomup(try(s; innermost(s))) 
</screen>

    Staged transformations (sequence of normal forms) 

<screen>
simplify =
  innermost(A1 &lt;+ ... &lt;+ Ak)
  ; innermost(B1 &lt;+ ... &lt;+ Bl)
  ; ...
  ; innermost(C1 &lt;+ ... &lt;+ Cm)
</screen>

   Local  transformations 

<screen>
transformation =
  alltd( trigger-transformation
  ; innermost(A1 &lt;+ ... &lt;+ An) )

alltd(s) = s &lt;+ all(alltd(s))
</screen>

    Application-specific transformations 

    Recursive patterns 

    Dynamic programming 

  </para>
  
</section>


<section>
  <title>Summary</title>

<para>

</para>

</section>



</chapter>
