<section
  xmlns="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2003/XInclude">

  <title>Running Stratego Programs (*)</title>

 <para>

   Now let's see how we can actually transform terms using Stratego
   programs. In the rest of this chapter we will first look at the
   structure of Stratego programs, and how to compile and run them.
   In the next chapters we will then see how to define
   transformations.

 </para>

<section>
  <title>The Identity Transformation</title>

<para>

   The simplest program you can write in Stratego is the following
   <code>identity.str</code> program:

<screen>
module identity
imports list-cons
strategies
  main = id
</screen>

   It features the following elements:

   Each Stratego file is a <emphasis>module</emphasis>, which has the
   same name as the file it is stored in without the <code>.str</code>
   extension.

   A module may <emphasis>import</emphasis> other modules in order to
   use the definitions in those modules.

   A module may contain one or more <code>strategies</code> sections
   that introduce new strategy definitions. It will become clear later
   what strategies and strategy definitions are.

   Each Stratego program has <emphasis>one main definition</emphasis>,
   which indicates the strategy to be executed on invocation of the
   program.

   In the example, the body of this program's main definition is the
   <emphasis>identity</emphasis> strategy <code>id</code>.

</para>

<para>

   Now let's see what this program means. To find that out, we first
   need to compile it, which we do using the Stratego compiler
   <code>strc</code> as follows:

<screen>
$ strc -i identity.str
[ strc | info ] Compiling 'identity.str'
[ strc | info ] Front-end succeeded         : [user/system] = [0.59s/0.56s]
[ strc | info ] Back-end succeeded          : [user/system] = [0.46s/0.16s]
[ strc | info ] C compilation succeeded     : [user/system] = [0.28s/0.23s]
[ strc | info ] Compilation succeeded       : [user/system] = [1.35s/0.95s]
</screen>

   The <code>-i</code> option of <code>strc</code> indicates the
   module to compile. The compiler also reads all imported modules, in
   this case the <code>list-cons.str</code> module that is part of the
   Stratego library and that <code>strc</code> magically knows how to
   find. The compiler prints some information about what it is doing,
   i.e., the stages of compilation that it goes through and the times
   for those stages. You can turn this off using the argument
   <code>--verbose 0</code>. However, since the compiler is not very
   fast, it may be satisfying to see something going on.

</para>

<para>

   The result of compilation is an executable named
   <code>identity</code> after the name of the main module of the
   program. Just to satisfy our curiosity we inspect the file system
   to see what the compiler has done:

<screen>
$ ls -l identity*
-rwxrwxr-x  1 7182 Sep  7 14:54 identity*
-rw-------  1 1362 Sep  7 14:54 identity.c
-rw-rw-r--  1  200 Sep  7 14:54 identity.dep
-rw-rw-r--  1 2472 Sep  7 14:54 identity.o
-rw-rw-r--  1   57 Sep  7 13:03 identity.str
</screen>

   Here we see that in addition to the executable the compiler has
   produced a couple of other files. First of all the
   <code>identity.c</code> file gives away the fact that the compiler
   first translates a Stratego program to C and then uses the C
   compiler to compile to machine code. The <code>identity.o</code>
   file is the result of compiling the generated C program. Finally,
   the contents of the <code>identity.dep</code> file will look
   somewhat like this:

<screen>
identity: \
        /usr/local/share/stratego-lib/collection/list/cons.rtree \
        /usr/local/share/stratego-lib/list-cons.rtree \
        ./identity.str
</screen>

   It is a rule in the Make language that declares the dependencies of
   the <code>identity</code> program. You can include this file in a
   <code>Makefile</code> to automate its compilation. For example, the
   following <code>Makefile</code> automates the compilation of the
   <code>identity</code> program:

<screen>
include identity.dep

identity : identity.str
        strc -i identity.str
</screen>

   Just invoke <code>make</code> on the command-line whenever you
   change something in the program.

</para>

<para>

   Ok, we were digressing a bit. Let's turn back to finding out what
   the <code>identity</code> program does. When we execute the program
   with some arbitrary arguments on the command-line, this is what
   happens:

<screen>
$ ./identity foo bar
["./identity","foo","bar"]
</screen>

    The program writes to <code>stdout</code> the list of command-line
    arguments as a list of strings in the ATerm format.

    So what we have learned is that a Stratego program applies its
    main strategy to the list of command-line arguments, and writes
    the resulting term to <code>stdout</code>. Since the strategy in
    the <code>identity</code> program is the identity transformation
    it just writes the original command-line arguments (as a term).

</para>
</section>

<section>
  <title>The Identity Transformation with I/O</title>

<para>

    That was instructive, but not very useful. We are not interested
    in transforming lists of strings, but rather programs represented
    as terms. So we want to read a term from a file, transform it, and
    write it to another file. Let's open the bag of tricks. The
    <code>identity-io</code> program improves the previous program:

<screen>
module identity-io
imports liblib
strategies
  main = io-wrap(id)
</screen>

    The program looks similar to the previous one, but there are a
    couple of differences. First, instead of importing module
    <code>list-cons</code>, this module imports <code>liblib</code>,
    which is the interface to the separately compiled Stratego
    library. This library provides a host of useful strategies that
    are needed in implementing program transformations. <xref
    linkend="stratego-library"/> gives an overview of the Stratego
    library, and we will every now and then use some useful strategies
    from the library before we get there.

</para>

<para>

    Right now we are interested in the <code>io-wrap</code> strategy
    used above. It implements a wrapper strategy that takes care of
    input and output for our program. To compile the program we need
    to link it with the <code>stratego-lib</code> library using the
    <code>-la</code> option:

<screen>
$ strc -i identity-io.str -la stratego-lib
</screen>

    What the relation is between <code>liblib</code> and
    <code>stratego-lib</code> will become clear later; knowing that it
    is needed to compile programs using <code>liblib</code> suffices
    for now.

</para>

<para>

    If we run the compiled <code>identity-io</code> program with its
    <code>--help</code> option we see the standard interface supported
    by the <code>io-wrap</code> strategy:

<screen>
$ ./identity-io --help
Options:
   -i f|--input f   Read input from f
   -o f|--output f  Write output to f
   -b               Write binary output
   -S|--silent      Silent execution (same as --verbose 0)
   --verbose i      Verbosity level i (default 1)
                    ( i as a number or as a verbosity descriptor:
                      emergency, alert, critical, error,
                      warning, notice, info, debug, vomit )
   -k i | --keep i  Keep intermediates (default 0)
   --statistics i  Print statistics (default 0 = none)
   -h|-?|--help     Display usage information
   --about          Display information about this program
   --version        Same as --about
</screen>

   The most relevant options are the <code>-i</code> option for the
   input file and the <code>-o</code> option for the output file. For
   instance, if we have some file <code>foo-bar.trm</code> containing
   an ATerm we can apply the program to it:

<screen>
$ echo "Foo(Bar())" > foo-bar.trm
$ ./identity-io -i foo-bar.trm -o foo-bar2.trm
$ cat foo-bar2.trm
Foo(Bar)
</screen>

   If we leave out the <code>-i</code> and/or <code>-o</code> options,
   input is read from <code>stdin</code> and output is written to
   <code>stdout</code>. Thus, we can also invoke the program in a
   pipe:

<screen>
$ echo "Foo(Bar())" | ./identity-io 
Foo(Bar)
</screen>

   Now it might seem that the <code>identity-io</code> program just
   copies its input file to the output file. In fact, the
   <code>identity-io</code> does not just accept any input.  If we try
   to apply the program to a text file that is not an ATerm, it
   protests and fails:

<screen>
$ echo "+ foo bar" | ./identity-io
readFromTextFile: parse error at line 0, col 0
not a valid term
./identity: rewriting failed
</screen>

   So we have written a program to check if a file represents an ATerm.

</para>
</section>

<section>
    <title>Running Programs Interactively</title>
    
<para>
  
  We have just learned how to write, compile, and execute Stratego
  programs. This is the normal mode for development of transformation
  systems with Stratego. Indeed, we usually do not invoke the compiler
  from the command-line `by hand', but have an automated build system
  based on (auto)make to build all programs in a project at once.

  For learning to use the language this can be rather laborious,
  however. Therefore, we have also developed the <xref
  linkend="ref-stratego-shell"/>, and interactive interpreter for the
  Stratego language.

       stratego-shell: just for trying out language
   
</para>

<para>

      Strategies are the statements and functions of the Stratego
      language. A strategy transforms a term into a new term, or
      fails. The term to which a strategy is applied, is called the
      <emphasis>current term</emphasis>. In the Stratego Shell you can
      see the current term with <command>:show</command>.
    
</para>

<screen>
<prompt>stratego></prompt> :show
()
<prompt>stratego></prompt></screen>

<para>
      
So, the current term is the empty tuple if you have just started
      the Stratego Shell. At the prompt of the shell you can enter
      strategies. If the strategy succeeds, then the shell will show
      the transformed term, which is now the new current term.
    
</para>

<screen>
<replaceable>current term</replaceable>
<prompt>stratego></prompt> <replaceable>strategy expression</replaceable>
<replaceable>transformed current</replaceable>
<prompt>stratego></prompt></screen>

    
<para>

      Strategies can also fail. In that case, the shell will print a
      message and leave the current term untouched:
    
</para>


<screen>
<replaceable>current term</replaceable>
<prompt>stratego></prompt> <replaceable>strategy expression</replaceable>
command failed
<prompt>stratego></prompt> :show
<replaceable>current term</replaceable></screen>

 </section>

<section>
  <title>Summary</title>
<para>

       file extensions

       libraries?

       modules, imports

       Compiling Programs

       main definition
       seperate compilation

</para>
</section>

</section>
