<section
  xml:id="stratego-traversal-library"
  xmlns="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2003/XInclude">

  <title>Idioms and Library Strategies for Traversal (*)</title>

<para>

  Above we have seen the basic mechanisms for defining traversals in
  Stratego: custom traversal rules, data-type specific congruence
  operators, and generic traversal operators.

  Term traversals can be categorized into classes according to how
  much of the term they traverse and to which parts of the term they
  modify.

  We will consider a number of idioms and standard strategies from the
  Stratego Library that are useful in the definition of traversals.

</para>

<section>
  <title>Full Traversals</title>

<para>

  One class of traversal strategies performs a <emphasis>full
  traversal</emphasis>, that is visits and transforms every subterm of
  the subject term.

  We already saw the <code>bottomup</code> strategy defined as

<screen>
bottomup(s) = all(bottomup(s)); s
</screen>

  It first visits the subterms of the subject term, recursively
  transforming <emphasis>its</emphasis> subterms, and then applies the
  transformation <code>s</code> to the result.
  
</para>

<para>

  A related strategy is <code>topdown</code>, which is defined as
  
<screen>
topdown(s) = s; all(topdown(s))
</screen>
 
  It <emphasis>first</emphasis> transforms the subject therm and
  <emphasis>then</emphasis> visits the subterms of the result.

</para>

<para>

  A combination of <code>topdown</code> and <code>bottomup</code> is
  <code>downup</code>, defined as

<screen>
downup(s) = s; all(downup(s)); s
</screen>

  It applies <code>s</code> on the way down the tree, and again on the
  way up. 

  A variation is <code>downup(2,0)</code>

<screen>
downup(s1, s2) = s1; all(downup(s1, s2)); s2
</screen>

  which applies one strategy on the way down and another on the way
  up.

</para>

<para>

  Since the parameter strategy is applied at every subterm, these
  traversals only succeed if it succeeds everywhere. Therefore, these
  traversals are typically applied in combination with
  <code>try</code> or <code>repeat</code>.

<screen>
topdown(try(R1 &lt;+ R2 &lt;+ ...))
</screen>

  This has the effect that the rules are tried at each subterm. If
  none of the rules apply the term is left as it was and traversal
  continues with its subterms.

</para>

<formalpara>
  <title>Choosing a Strategy</title>

<para>

  The strategy to be used for a particular transformation depends on
  the rules and the goal to be achieved.

</para>

</formalpara>

<para>

  For example, a constant folding transformation for proposition
  formulae can be defined as a bottom-up traversal that tries to apply
  one of the truth-rules <code>T</code> at each subterm:
    
<screen>
T : And(True(), x) -> x
T : And(x, True()) -> x
T : And(False(), x) -> False()
T : And(x, False()) -> False()
T : Or(True(), x) -> True()
T : Or(x, True()) -> True()
T : Or(False(), x) -> x
T : Or(x, False()) -> x
T : Not(False()) -> True()
T : Not(True()) -> False()

eval = bottomup(try(T))
</screen>

   Bottomup is the strategy of choice here because it evaluates
   subterms before attempting to rewrite a term.

   An evaluation strategy using <code>topdown</code>

<screen>
eval2 = topdown(try(T)) // bad strategy
</screen>

  does not work as well, since it attempts to rewrite terms before
  their subterms have been reduced, thus missing rewriting
  opportunities.

  The following Stratego Shell session illustrates this:

<screen>
<prompt>stratego></prompt> !And(True(), Not(Or(False(), True())))
And(True,Not(Or(False,True)))
<prompt>stratego></prompt> eval
False
<prompt>stratego></prompt> !And(True(), Not(Or(False(), True())))
And(True,Not(Or(False,True)))
<prompt>stratego></prompt> eval2
Not(True)
</screen>

  Exercise: find other terms that show the difference between these
  strategies.

</para>

<para>
    
  On the other hand, a desugaring transformation for propositions,
  which defines implication and equivalence in terms of other
  connectives is best defined as a <code>topdown</code> traversal
  which tries to apply one of the rules <code>DefI</code> or
  <code>DefE</code> at every subterm.

<screen>
DefI : Impl(x, y) -> Or(Not(x), y)
DefE : Eq(x, y) -> And(Impl(x, y), Impl(y, x))

desugar = topdown(try(DefI &lt;+ DefE))
</screen>

  Since <code>DefE</code> rewrites <code>Eq</code> terms to terms
  involving <code>Impl</code>, a strategy with <code>bottomup</code>
  does not work.

<screen>
desugar2 = bottomup(try(DefI &lt;+ DefE))   // bad strategy
</screen>

  Since the subterms of a node are traversed
  <emphasis>before</emphasis> the node itself is visited, this
  transformation misses the desugaring of the implications
  (<code>Impl</code>) originating from the application of the
  <code>DefE</code> rule.

  The following Shell session illustrates this:

<screen>
<prompt>stratego></prompt> !Eq(Atom("p"), Atom("q"))
Eq(Atom("p"),Atom("q"))
<prompt>stratego></prompt> desugar
And(Or(Not(Atom("p")),Atom("q")),Or(Not(Atom("q")),Atom("p")))
<prompt>stratego></prompt> !Eq(Atom("p"), Atom("q"))
Eq(Atom("p"),Atom("q"))
<prompt>stratego></prompt> desugar2
And(Impl(Atom("p"),Atom("q")),Impl(Atom("q"),Atom("p")))
</screen>

</para>

<formalpara>
   <title>Repeated Application</title>

<para>

  In case one rule produces a term to which another desugaring rule
  can be applied, the desugaring strategy should repeat the
  application of rules to each subterm.

  Consider the following rules and strategy for desugaring
  propositional formulae to implicative normal form (using only
  implication and <code>False</code>).
    
<screen>
DefT  : True() -> Impl(False(), False())
DefN  : Not(x) -> Impl(x, False())
DefA2 : And(x, y) -> Not(Impl(x, Not(y)))
DefO1 : Or(x, y) -> Impl(Not(x), y)
DefE  : Eq(x, y) -> And(Impl(x, y), Impl(y, x))

impl-nf = topdown(repeat(DefT &lt;+ DefN &lt;+ DefA2 &lt;+ DefO1 &lt;+ DefE))
</screen>

  Application of the rules with <code>try</code> instead of
  <code>repeat</code> 

<screen>
impl-nf2 = topdown(try(DefT &lt;+ DefN &lt;+ DefA2 &lt;+ DefO1 &lt;+ DefE))  // bad strategy
</screen>

  is not sufficient, as shown by the following Shell session:

<screen>
<prompt>stratego></prompt> !And(Atom("p"),Atom("q"))
And(Atom("p"),Atom("q"))
<prompt>stratego></prompt> impl-nf
Impl(Impl(Atom("p"),Impl(Atom("q"),False)),False)
<prompt>stratego></prompt> !And(Atom("p"),Atom("q"))
And(Atom("p"),Atom("q"))
<prompt>stratego></prompt> impl-nf2
Not(Impl(Atom("p"),Impl(Atom("q"),False)))
</screen>

  Note that the <code>Not</code> is not desugared with
  <code>impl-nf2</code>.

</para>

</formalpara>

<formalpara>
   <title>Paramorphism</title>

<para>

  A variation on bottomup is a traversal that also provides the
  original term as well as the term in which the direct subterms have
  been transformed. (Also known as a paramorphism?)

<screen>
bottomup-para(s) = &lt;s>(&lt;id>, &lt;all(bottomup-para(s))>)
</screen>

  This is most useful in a bottom-up traversal; the original term is
  always available in a top-down traversal.

</para>

</formalpara>

<para>
  Exercise: give an example application of this strategy
</para>

</section>

<section>
  <title>Cascading Transformations</title>

<para>

  Cascading transformations are transformations upon
  transformations. While the full traversals discussed above walk over
  the tree once, cascading transformations apply multiple `waves' of
  transformations to the nodes in the tree.

  The prototypical example is the <code>innermost</code> strategy,
  which exhaustively applies a transformation, typically a set of
  rules, to a tree.

<screen>
simplify =
  innermost(R1 &lt;+ ... &lt;+ Rn)
</screen>

  The basis of <code>innermost</code> is a <code>bottomup</code>
  traversal that tries to apply the transformation at each node after
  visiting its subterms.

<screen>
innermost(s) = bottomup(try(s; innermost(s)))
</screen>

  If the transformation <code>s</code> succeeds, the result term is
  transformed again with a recursive call to <code>innermost</code>.

</para>

<para>

  Application of <code>innermost</code> exhaustively applies
  <emphasis>one</emphasis> set of rules to a tree.

  Using sequential composition we can apply several
  <emphasis>stages</emphasis> of reductions.

  A special case of such a <emphasis>staged transformation</emphasis>,
  is known as <emphasis>sequence of normal forms</emphasis> (in the
  TAMPR system):

<screen>
simplify =
  innermost(A1 &lt;+ ... &lt;+ Ak)
  ; innermost(B1 &lt;+ ... &lt;+ Bl)
  ; ...
  ; innermost(C1 &lt;+ ... &lt;+ Cm)
</screen>

  At each stage the term is reduced with respect to a different set of
  rules.

</para>

<para>

  Of course it is possible to mix different types of transformations
  in such a stage pipeline, for example.

<screen>
simplify =
  topdown(try(A1 &lt;+ ... &lt;+ Ak))
  ; innermost(B1 &lt;+ ... &lt;+ Bl)
  ; ...
  ; bottomup(repeat(C1 &lt;+ ... &lt;+ Cm))
</screen>

  At each stage a different strategy and different set of rules can be
  used. (Of course one may use the same strategy several times, and
  some of the rule sets may overlap.)

</para>

</section>

<section>
  <title>Mixing Generic and Specific Traversals (*)</title>

<para>

  While completely generic strategies such as <code>bottomup</code>
  and <code>innermost</code> are often useful, there are also
  situations where a mixture of generic and data-type specific
  traversal is necessary. Fortunately, Stratego allows you to mix
  generic traversal operators, congruences, your own traversal and
  regular rules, any way you see fit.

</para>

<para>

<screen>
transformation =
  special-case1
  &lt;+ special-case2
  &lt;+ special-case3
  &lt;+ all(transformation)
</screen>

  The traversals above go through all constructors. If it is not
  necessary to traverse the entire tree, the following versions of the
  traversals can be used. They are parameterized with a strategy
  operator <code>stop</code> that

<screen>
  topdownS(s, stop: (a -> a) * b -> b) =
    rec x(s; (stop(x) &lt;+ all(x)))

  bottomupS(s, stop: (a -> a) * b -> b) =
    rec x((stop(x) &lt;+ all(x)); s)

  downupS(s, stop: (a -> a) * b -> b) =
    rec x(s; (stop(x) &lt;+ all(x)); s)

  downupS(s1, s2, stop: (a -> a) * b -> b) =
    rec x(s1; (stop(x) &lt;+ all(x)); s2)
</screen>

    The strategy <code>don't-stop</code> is a unit for these traversals,
    i.e., <code>topdown(s)</code> is equivalent
    to <code>topdown(s,don't-stop)</code>.

<screen>
  don't-stop(s) = fail
</screen>

</para>

<note>
  <title>Separate rules and strategies</title>

  <para>
    
    While it is possible to construct your own strategies by mixing
    traversal elements and rules, in general, it is a good idea to try
    to get a clean separation between pure rewrite rules and a
    strategy that applies them.

  </para>

</note>

</section>

<section>
  <title>Partial Traversals (*)</title>

<para>

\subsection{Once}

    Apply s at one position. One s application has to succeed.

<screen>
  oncetd(s) = rec x(s &lt;+ one(x))
  oncebu(s) = rec x(one(x) &lt;+ s)
</screen>

<screen>
  oncetd-skip(s, skip: (a -> a) * b -> b) =
    rec x(s &lt;+ skip(x) &lt;+ one(x))
</screen>

\subsection{At Least Once}

    Apply s at some positions, but at least one. As soon as one is
    found, searching is stopped, i.e., in the top-down case
    searching in subtrees is stopped, in bottom-up case, searching
    in upper spine is stopped.

    One-pass traversals
    
<screen>
  sometd(s) = rec x(s &lt;+ some(x))
  somebu(s) = rec x(some(x) &lt;+ s)
</screen>

\subsection{Frontier}

    While full traversals visit every node of a tree,
    partial traversals may stop at some point. An
    example is the <code>alltd(s)</code> strategy, which
    stops as soon as it has found a subterm to which
    <code>s</code> can be succesfully applied.

<screen>
  alltd(s) = s &lt;+ all(alltd(s))
</screen>

    If <code>s</code> does not succeed, the strategy is applied
    recursively at all direct subterms. This means that <code>s</code>
    is applied along a frontier of the subject term. This strategy
    is typically used in substitution operations in which subterms
    are replaced by other terms. For example, the strategy
    <code>alltd(?Var(x); !e)</code> replaces all occurrences of
    <code>Var(x)</code> by <code>e</code>.

    Note that <code>alltd(try(s))</code> is not a useful strategy.
    Since <code>try(s)</code> succeeds at the root of the term,
    no travesal is done.

   Local  transformations 

<screen>
transformation =
  alltd(
    trigger-transformation
    ; innermost(A1 &lt;+ ... &lt;+ An) 
  )
</screen>

</para>

<para>

  relatives of <code>alltd</code>

<screen>
alldownup2(s1, s2) = rec x((s1 &lt;+ all(x)); s2)
alltd-fold(s1, s2) = rec x(s1 &lt;+ all(x); s2)
</screen>

\subsection{Leaves}

<screen>
  leaves(s, is-leaf, skip: a * (a -> a) -> a) =
    rec x((is-leaf; s) &lt;+ skip(x) &lt;+ all(x))

  leaves(s, is-leaf) =
    rec x((is-leaf; s) &lt;+ all(x))
</screen>

\subsection{Many}

    Find as many applications as possible, but at least one.

<screen>
  manybu(s) = rec x(some(x); try(s) &lt;+ s)\
  manytd(s) = rec x(s; all(try(x)) &lt;+ some(x))
</screen>

<screen>
  somedownup(s) = rec x(s; all(x); try(s) &lt;+ some(x); try(s))
</screen>

  </para>

</section>

<section>
  <title>Path (*)</title>

<para>

  A spine of a term is a chain of nodes from the root to some
  subterm. <code>spinetd</code> goes down one spine and applies
  <code>s</code> along the way to each node on the spine. The
  traversal stops when <code>s</code> fails for all children of a
  node.

<screen>
spinetd(s)  = s; try(one(spinetd(s)))
spinebu(s)  = try(one(spinebu(s))); s
spinetd'(s) = s; (one(spinetd'(s)) + all(fail))
spinebu'(s) = (one(spinebu'(s)) + all(fail)); s
</screen>

  Apply <code>s</code> everywhere along al spines where <code>s</code>
  applies.

<screen>
somespinetd(s) = rec x(s; try(some(x)))
somespinebu(s) = rec x(try(some(x)); s)
spinetd'(s)    = rec x(s; (one(x) + all(fail)))
spinebu'(s)    = rec x((one(x) + all(fail)); s)
</screen>

  While these strategies define the notion of applying along a spine,
  they are rarely used. In practice one would use more specific
  traversals with that determine which subterm to include in the
  search for a path.

</para>

<para>

  TODO: examples

</para>

</section>

<section>
  <title>Recursive Patterns (*)</title>

<para>

  TODO: format checking 

</para>
  
<para>

  TODO: matching of complex patterns

</para>
  
<para>

  TODO: contextual rules (local traversal)

</para>
  
</section>

<section>
  <title>Dynamic programming (*)</title>

<para>

  TODO (probably move to dynamic rules chapter)

</para>
  
</section>

</section>
