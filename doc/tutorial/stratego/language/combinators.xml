<chapter xml:id="stratego-strategy-combinators"
  xmlns="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2003/XInclude">

  <title>Strategy Combinators (*)</title>

<para>

  We have seen the use of strategies to combine rules into complex
  transformations.

  Rather than providing a fixed set of high-level strategy operators
  such as <code>bottomup</code>, <code>topdown</code>, and
  <code>innermost</code>, Stratego provides a small set of basic
  combinators, that can be used to create a wide variety of
  strategies.
 
   We first consider a set of combinators for sequential programming,
   including sequential composition, deterministic choice, guarded
   choice, test and negation, and recursion.

</para>

<para>
 
  Rules define one-step transformations 

  Program transformations require many one-step transformations and
  selection of rules

  Choice; identity, Failure, and Negation
  
</para>

<section xml:id="identity">
  <title>Identity and Failure</title>

  
<para>
  Syntax: id 

  Always succeed 

  Some laws 
    
</para>

    
<screen>
id ; s = s

s ; id = s

id &lt;+ s  = id

s &lt;+ id /=  s

s1 &lt; id + s2 = s1 &lt;+ s2 
</screen>


    
<para>

Syntax: fail 

Always fail 

Some laws 
    
</para>

    
<screen>
fail &lt;+ s = s

s &lt;+ fail =  s

fail ; s = fail

s ; fail /= fail
</screen>

</section>


<section xml:id="seq">
   <title>Sequential composition</title>
    
<para>
      
  The sequential composition <code>s1 ; s2</code> of the strategies
  <code>s1</code> and <code>s2</code> first applies the strategy
  <code>s1</code> to the subject term and then <code>s2</code> to the
  result of that first application.
    
</para>

<screen>
Plus(Var("a"),Int("3"))
<prompt>stratego></prompt> ?Plus(e1, e2); !Plus(e2, e1)
Plus(Int("3"),Var("a"))
</screen>

<para>
      
  The variable bindings are propagated. The strategy fails if either
  <code>s1</code> or <code>s2</code> fails.

  As an example of the use of sequential composition consider the
  following rewrite rules.

<screen>
  rules
    A : P(Z,x) -> x
    B : P(S(x),y) -> P(x,S(y))
</screen>

  Using the sequential composition \verb|B;A|, the term
  \verb|P(S(Z),Z)| is reduced to \verb|S(Z)|,

</para> 

</section>


<section xml:id="choice">
    <title>Choice</title>

<para>

  choosing between actions

  failure

</para>

<section xml:id="stratego-left-choice">
    <title>Deterministic Choice (Left Choice)</title>
  
<para>
      
  The left choice or deterministic choice s1 &lt;+ s2 chooses one of
  the trans- formations to apply. That is, s1 is first applied, and s2
  is only applied if s2 fails.
    
</para>
  
<para>
      
  A typical application of the deterministic choice operator is to
  declare the priority between rules with overlapping left-hand sides.

  For example, the following rewrite rules define the \verb|Mem|
  function:

<screen>
  rules
    Mem1 : Mem(x,[]) -> False
    Mem2 : Mem(x,[x|xs]) -> True
    Mem3 : Mem(x,[y|ys]) -> Mem(x,ys)
</screen>

  Rules \verb|Mem2| and \verb|Mem3| have overlapping left-hand sides.
  Rule \verb|Mem2| only applies if the first argument is equal to head
  element of the list in the second argument. Rule \verb|Mem3| applies
  always if the list in the second argument is non-empty.  By ordering
  the rules as \verb|Mem2 &lt;+ Mem3|, rule \verb|Mem2| is tried
  before \verb|Mem3|,

</para>

<screen>
PlusAssoc :
  Plus(Plus(e1, e2), e3) -> Plus(e1, Plus(e2, e3))

EvalPlus :
  Plus(Int(i),Int(j)) -> Int(k) where &lt;addS>(i,j) => k
</screen>

<screen>
Plus(Int("14"),Int("3"))
stratego> PlusAssoc
command failed
stratego> PlusAssoc &lt;+ EvalPlus
Int("17")
</screen>

<para>
      
  A useful application of &lt;+ in combination with id is the
  reflexive closure of a strategy s. The strategy try(s) tries to
  apply the strategy s, but if that fails, just succeeds using id.
    
</para>

<screen>try(s) = s &lt;+ id</screen>

<para>
      
  Note that the choice is committed once the left-hand side strategy
  has succeeded, even if the continuation strategy fails.
    
</para>
    
</section>

<section xml:id="stratego-guarded-choice">
  <title>Guarded Choice</title>

<para>

  Sometimes it is not desirable to backtrack to the alternative
  specified in a choice. Rather, after passing a guard, the choice
  should be committed. This can be expressed using the \emph{guarded
  left choice} operator \verb|s1 &lt; s2 + s3|, which is defined as:


  Conditional choice

  Syntax: s1 &lt; s2 + s3 

  First apply s1 if that succeeds apply s2 to the result else
  apply s3 to the original term

  Do not backtrack to s3 if s2 fails!
  
</para>

<screen>
  ?Call( , )    &lt; complex-transformation-for-call
+ ?BinOp( , , ) &lt; transformation-for-binop
+ other-cases
</screen>

</section>

<section xml:id="stratego-if-then-else">
  <title>If Then Else</title>

<para>
      
  If Then Else

  Syntax: if s1 then s2 else s3 end 

  Equivalent to: where(s1) &lt; s2 + s3

</para>

  
<screen>
foo
</screen>

<para>
     
  If-Then

  Syntax: if s1 then s2 end 

  Equivalent to if s1 then s2 else id end
</para>

<screen>
foo
</screen>

</section>

<section xml:id="stratego-switch">
  <title>Switch</title>

<para>

  switch construct

</para>

</section>

<section>
  <title>Non-deterministic Choice</title>

    <para>
      The deterministic choice operator prescribes that the left
      alternative should be tried before the right alternative, and
      that the latter is only used if the first fails. There are
      applications where it is not necessary to define the order of
      the alternatives. In those cases non-deterministic choice can be
      used.
    </para>

    <para>
      The non-deterministic choice operator s1 + s2 chooses one of the
      two strategies s1 or s2 to apply, such that the one it chooses
      succeeds. If both strategies fail, then the choice fails as
      well.
    </para>

    <para>
      Operationally one can imagine the choice operator to first try
      one strategy, and, if that fails, to try the other. The order in
      which this is done is undefined, i.e., arbitrarily chosen by the
      compiler.

        The \texttt{+} operator is needed to model modular composition
        of rewrite rules.

        Rules with the same label

        Explain implications of the \texttt{+} operator for semantics
        and implementation and semantics.

    </para>

</section>

</section>

<section xml:id="negation">
    <title>Negation</title>

<para>

  Sometimes it is useful to test a property of a term, rather than
  transforming it. In these cases the combinators \texttt{test} and
  \texttt{not} can be used. They test whether a strategy $s$ succeeds
  or fails to transform a term.


  Syntax: not(s) 

  Fail if s succeeds, succeed if s fails 

  Equivalent to: s &lt; fail + id

</para>

</section>

<section>
  <title>Recursion</title>

<para>

   Repeated application of a strategy can be achieved with recursion.
   There are two styles for doing this; with a recursive definition or
   using the fixpoint operator \texttt{rec}. A recursive definition is
   a normal strategy definition with a recursive call in its body. For
   example, the following defines the strategy \texttt{repeat}, which
   applies a transformation $s$ until it fails:

<screen>
  strategies
    repeat(s) = s; repeat(s) &lt;+ id
    eval = repeat(A &lt;+ B)
  rules
    A : P(Z,x) -> x
    B : P(S(x),y) -> P(x,S(y))
</screen>

  Note that sequential composition has higher priority than
        choice. Therefore, \texttt{$s_1$; $s_2$ &lt;+ $s_3$} should be
        read as \texttt{($s_1$; $s_2$) &lt;+ $s_3$}.

<screen>
        \tty{P(S(Z),Z)}
        \lstep{\tty{\small repeat(A+B)}}{\tty{S(Z)}}
</screen>

</para>

	
<para>
	  
  Repeated application of a strategy can be achieved with
  recursion. There are two styles for doing this; with a recursive
  definition or using the fixpoint operator rec. A recursive
  definition is a normal strategy definition with a recursive call in
  its body.
	
</para>

<screen>
try(s) = s &lt;+ id

repeat(s) = try(s; repeat(s))

while(c, s) = if c then s; while(c,s) end

do-while(s, c) = s; if c then do-while(s, c) end
</screen>

<screen>
  strategies
    repeat(s) = s; repeat(s) &lt;+ id
    eval = repeat(A &lt;+ B)
  rules
    A : P(Z,x) -> x
    B : P(S(x),y) -> P(x,S(y))
</screen>

  <screen>
map(s) =
  ?[] &lt;+ \ [x | xs] -> [&lt;s> x | &lt;map(s)> xs] \

foldr(s1, s2, f) =
  []; s1 &lt;+ \ [x|xs] -> &lt;s2>(&lt;f> x, &lt;foldr(s1, s2, f)> xs) \

length = foldr(!0, add, !1)
  </screen>


<section xml:id="rec">
  <title>Fixpoint operator (rec)</title>
    
 <para>

   Another way to define recursion is using the fixpoint operator
   <code>rec x(s)</code>, which recurses on applications of
   <code>x</code> within <code>s</code>.
     
 </para>
    
 <para>
    
   Originally, the <code>rec</code> operator was the only way to
   define recursion. It is still in the language in the first place
   because it is widely used in many existing programs, and in the
   second place because it can be a nice concise expression of a
   recursive strategy. An example usage is the definition of repeat
   with <code>rec</code>:
    
  </para>

  <screen>repeat(s) = try(s; repeat(s))</screen>

  <para>

    Iteration Strategies

    Using sequential composition, choice, and recursion a large
    variety of iteration strategies can be defined. The following
    module is part of the Stratego Standard Library:

  </para>

<screen>
  module iteration
  imports conditional
  strategies
    repeat(s, c)       = rec x(s; x &lt;+ c)
    repeat(s)          = repeat(s, id)
    repeat1(s, c)      = rec x(s; (x &lt;+ c))
    repeat1(s)         = repeat1(s, id)
    repeat-until(s, c) = rec x(s; (c &lt;+ x))

    while(c, s)        = rec x(try(c; s; x))
    do-while(s, c)     = rec x(s; try(c; x))
    while-not(c, s)    = rec x(c &lt;+ s; x)

    for(i, c, s)       = i; while-not(c, s)
</screen>

</section>

</section>

<section>
  <title>Summary</title>

<para>

</para>

</section>


</chapter>
