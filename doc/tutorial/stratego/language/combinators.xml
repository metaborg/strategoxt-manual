<chapter xml:id="stratego-strategy-combinators"
  xmlns="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2003/XInclude">

  <title>Strategy Combinators (*)</title>

<para>

  We have seen the use of strategies to combine rules into complex
  transformations.

  Rather than providing a fixed set of high-level strategy operators
  such as <code>bottomup</code>, <code>topdown</code>, and
  <code>innermost</code>, Stratego provides a small set of basic
  combinators, that can be used to create a wide variety of
  strategies.

  In <xref linkend="stratego-strategy-combinators"/> until <xref
  linkend="stratego-type-unifying-strategies"/> we will introduce these
  combinators.

  In this chapter we start with a set of combinators for sequential
  composition and choice of strategies.

</para>

<section xml:id="identity">
  <title>Identity and Failure</title>

<para>

  The most basic operations in Stratego are <code>id</code> and
  <code>fail</code>. 

  The identity strategy <code>id</code> always succeeds and behaves as
  the identity function on terms.

  The failure strategy <code>fail</code> always fails.

  The operations have no side effects.

</para>

</section>

<section xml:id="seq">
   <title>Sequential composition</title>
    
<para>
      
  The sequential composition <code>s1 ; s2</code> of the strategies
  <code>s1</code> and <code>s2</code> first applies the strategy
  <code>s1</code> to the subject term and then <code>s2</code> to the
  result of that first application. The strategy fails if either
  <code>s1</code> or <code>s2</code> fails.
    
</para>

<formalpara>
  <title>Properties</title>

<para>

  Sequential composition is associative.  Identity is a left and right
  unit for sequential composition; since <code>id</code> always
  succeeds and leaves the term alone, it has no additional effect to
  the strategy that it is composed with. Failure is a left zero for
  sequential composition; since <code>fail</code> always fails the
  next strategy will never be reached.

<screen>
(s1; s2) ; s3 = s1; (s2; s3)

id; s = s

s; id = s

fail; s = fail
</screen>

  However, not for all strategies <code>s</code> we have that failure
  is a right zero for sequential composition:

<screen>
s ; fail = fail   (is not a law)
</screen>

  Although the composition <code>s; fail</code> will always fail, the
  execution of <code>s</code> may have side effects that are not
  performed by <code>fail</code>. For example, consider printing a
  term in <code>s</code>.

</para>

</formalpara>

<formalpara>
  <title>Examples</title>

<para>
      
  As an example of the use of sequential composition consider the
  following rewrite rules.

<screen>
<prompt>stratego></prompt> A : P(Z,x) -> x
<prompt>stratego></prompt> B : P(S(x),y) -> P(x,S(y))
</screen>

  The following session shows the effect of first applying
  <code>B</code> and then <code>A</code>:

<screen>
<prompt>stratego></prompt> !P(S(Z()), Z())
P(S(Z),Z)
<prompt>stratego></prompt> B
P(Z,S(Z))
<prompt>stratego></prompt> A
S(Z)
</screen>

  Using the sequential composition of the two rules, this effect can
  be achieved `in one step':

<screen>
<prompt>stratego></prompt> !P(S(Z()),Z())
P(S(Z),Z)
<prompt>stratego></prompt> B; A
S(Z)
</screen>

   The following session shows that the application of a composition
   fails if the second strategy in the composition fails to apply to
   the result of the first:

<screen>
<prompt>stratego></prompt> !P(S(Z()),Z())
P(S(Z),Z)
<prompt>stratego></prompt> B; B
command failed
</screen>

</para> 

</formalpara>

</section>

<section xml:id="choice">
    <title>Choice</title>

<para>

  Choosing between rules to apply is achieved using one of several
  <emphasis>choice</emphasis> combinators, all of which are based on
  the guarded choice combinator. The common approach is that failure
  to apply one strategy leads to backtracking to an alternative
  strategy.

</para>

<section xml:id="stratego-left-choice">
    <title>Deterministic Choice (Left Choice)</title>
  
<para>
      
  The left choice or deterministic choice <code>s1 &lt;+ s2</code>
  tries to apply <code>s1</code> and <code>s2</code> in that
  order. That is, it first tries to apply <code>s1</code>, and if that
  succeeds the choice succeeds. However, if the application of
  <code>s1</code> fails, <code>s2</code> is applied to <emphasis>the
  original term</emphasis>.
    
</para>

<formalpara>
  <title>Properties</title>

<para>

  Left choice is associative. Identity is a left zero for left choice;
  since <code>id</code> always succeeds, the alternative strategy will
  never be tried. Failure is a left and right unit for left choice;
  since <code>fail</code> always fails, the choice will always
  backtrack to the alternative strategy, and use of <code>fail</code>
  as alternative strategy is pointless.

<screen>
(s1 &lt;+ s2) &lt;+ s3 = s1 &lt;+ (s2 &lt;+ s3)

id &lt;+ s  = id

fail &lt;+ s = s

s &lt;+ fail = s
</screen>

  However, identity is not a right zero for left choice. That is, 
  not for all strategies <code>s</code> we have that

<screen>
s &lt;+ id =  s    (is not a law)
</screen>

</para>

</formalpara>

<formalpara>
  <title>Local Backtracking</title>

<para>

  The left choice combinator is a <emphasis>local
  backtracking</emphasis> combinator.  That is, the choice is
  committed once the left-hand side strategy has succeeded, even if
  the continuation strategy fails. This is expressed by the fact that
  the property

<screen>
(s1 &lt;+ s2); s3 = (s1; s3) &lt;+ (s2; s3)    (is not a law)
</screen>

  does <emphasis>not</emphasis> hold for all <code>s1</code>,
  <code>s2</code>, and <code>s3</code>.

  The difference is illustrated by the following applications:

<screen>
<prompt>stratego></prompt> !P(S(Z()),Z())
P(S(Z),Z)
<prompt>stratego></prompt> (B &lt;+ id); B
command failed

<prompt>stratego></prompt> !P(S(Z()),Z())
P(S(Z),Z)
<prompt>stratego></prompt> (B &lt;+ id)
P(Z,S(Z))
<prompt>stratego></prompt> B
command failed

<prompt>stratego></prompt> (B; B) &lt;+ (id; B)
P(Z,S(Z))
</screen>

  In the application of <code>(B &lt;+ id); B</code>, the first
  application of <code>B</code> succeeds after which the choice is
  committed. The subsequent application of <code>B</code> then fails.

  This equivalent to first applying <code>(B &lt;+ id)</code> and then
  applying <code>B</code> to the result.

  The application of <code>(B; B) &lt;+ (id; B)</code>, however, is
  successful; the application of <code>B; B</code> fails, after which
  the choice backtracks to <code>id; B</code>, which succeeds.

</para>

</formalpara>

<formalpara>
  <title>Choosing between Transformations</title>

<para>

  The typical use of left choice is to create a composite strategy
  trying one from several possible transformations. If the strategies
  that are composed are mutually exclusive, that is, don't succeed for
  the same terms, their sum is a transformation that
  (deterministically) covers a larger set of terms. 

  For example, consider the following two rewrite rules:
      
<screen>
<prompt>stratego></prompt> PlusAssoc : Plus(Plus(e1, e2), e3) -> Plus(e1, Plus(e2, e3))
<prompt>stratego></prompt> PlusZero  : Plus(Int("0"),e) -> e
</screen>

  These rules are mutually exclusive, since there is no term that
  matches the left-hand sides of both rules. Combining the rules with
  left choice into <code>PlusAssoc &lt;+ PlusZero</code> creates a
  strategy that transforms terms matching both rules as illustrated by
  the following applications:

<screen>
<prompt>stratego></prompt> !Plus(Int("0"),Int("3"))
Plus(Int("0"),Int("3"))

<prompt>stratego></prompt> PlusAssoc
command failed
<prompt>stratego></prompt> PlusAssoc &lt;+ PlusZero
Int("3")

<prompt>stratego></prompt> !Plus(Plus(Var("x"),Int("42")),Int("3"))
Plus(Plus(Var("x"),Int("42")),Int("3"))

<prompt>stratego></prompt> PlusZero
command failed
<prompt>stratego></prompt> PlusAssoc &lt;+ PlusZero
Plus(Var("x"),Plus(Int("42"),Int("3")))
</screen>

</para>

</formalpara>

<formalpara>
  <title>Ordering Overlapping Rules</title>

<para>

  When two rules or strategies are mutually exlusive the order of
  applying them does not matter. 

  In cases where strategies are overlapping, that is, succeed for the
  same terms, the order becomes crucial to determining the semantics
  of the composition.

  For example, consider the following rewrite rules reducing
  applications of <code>Mem</code>:

<screen>
<prompt>stratego></prompt> Mem1 : Mem(x,[]) -> False()
<prompt>stratego></prompt> Mem2 : Mem(x,[x|xs]) -> True()
<prompt>stratego></prompt> Mem3 : Mem(x,[y|ys]) -> Mem(x,ys)
</screen>

  Rules <code>Mem2</code> and <code>Mem3</code> have overlapping
  left-hand sides.  Rule <code>Mem2</code> only applies if the first
  argument is equal to head element of the list in the second
  argument. Rule <code>Mem3</code> applies always if the list in the
  second argument is non-empty.  

<screen>
<prompt>stratego></prompt> !Mem(1, [1,2,3])
Mem(1, [1,2,3])
<prompt>stratego></prompt> Mem2
True
<prompt>stratego></prompt> !Mem(1, [1,2,3])
Mem(1,[1,2,3])
<prompt>stratego></prompt> Mem3
Mem(1,[2,3])
</screen>

  In such situations, depending on the order of the rules, differents
  results are produced. (The rules form a non-confluent rewriting
  system.)

  By ordering the rules as <code>Mem2 &lt;+ Mem3</code>, rule
  <code>Mem2</code> is tried before <code>Mem3</code>, and we have a
  deterministic transformation strategy.

</para>

</formalpara>

<formalpara>
  <title>Try</title>

<para>
      
  A useful application of <code>&lt;+</code> in combination with
  <code>id</code> is the reflexive closure of a strategy
  <code>s</code>:
    
<screen>
try(s) = s &lt;+ id
</screen>

  The user-defined strategy combinator <code>try</code> tries to apply
  its argument strategy <code>s</code>, but if that fails, just
  succeeds using <code>id</code>.

</para>

</formalpara>
    
</section>


<section xml:id="stratego-guarded-choice">
  <title>Guarded Choice</title>

<para>

  Sometimes it is not desirable to backtrack to the alternative
  specified in a choice. Rather, after passing a guard, the choice
  should be committed. This can be expressed using the
  <emphasis>guarded left choice</emphasis> operator <code>s1 &lt; s2 +
  s3</code>.

  If <code>s1</code> succeeds <code>s2</code> is applied, else
  <code>s3</code> is applied. If <code>s2</code> fails, the complete
  expression fails; no backtracking to <code>s3</code> takes place.

</para>

<formalpara>
  <title>Properties</title>

<para>

  This combinator is a generalization of the left choice combinator
  <code>&lt;+</code>. 

<screen>
s1 &lt;+ s2 = s1 &lt; id + s2
</screen>

  The 

<screen>
id &lt; s2 + s3  = s2

fail &lt; s2 + s3 = s3
</screen>

<screen>
s1 &lt; s2 + fail = s1; s2
</screen>

  guarded choice is not associative

<screen>
(s1 &lt; s2 + s3) &lt; s4 + s5 = s1 &lt; s2 + (s3 &lt; s4 + s5)    (not a law)
</screen>

   however, sequential composition distributes over guarded choice

<screen>
(s1 &lt; s2 + s3) ; s4 = s1 &lt; (s2; s4) + (s3; s4)
</screen>

<screen>
s0; (s1 &lt; s2 + s3) = (s0; s1) &lt; s2 + s3
</screen>

</para>

</formalpara>

<formalpara xml:id="negation">
    <title>Negation</title>

<para>

  Sometimes it is useful to test a property of a term, rather than
  transforming it. In these cases the combinators \texttt{test} and
  \texttt{not} can be used. They test whether a strategy $s$ succeeds
  or fails to transform a term.

<screen>
not(s) = s &lt; fail + id
</screen>

</para>

</formalpara>

<formalpara>
  <title>Examples</title>

<para>

<screen>
  test1 &lt; case1
+ test2 &lt; case2
+ other-cases
</screen>

</para>

</formalpara>


</section>

<section xml:id="stratego-if-then-else">
  <title>If Then Else</title>

<para>
      
  If Then Else

  Syntax: if s1 then s2 else s3 end 

  Equivalent to: where(s1) &lt; s2 + s3

</para>

  
<screen>
foo
</screen>

<para>
     
  If-Then

  Syntax: if s1 then s2 end 

  Equivalent to if s1 then s2 else id end
</para>

<screen>
foo
</screen>

</section>

<section xml:id="stratego-switch">
  <title>Switch</title>

<para>

  switch construct

</para>

</section>

<section>
  <title>Non-deterministic Choice</title>

    
<para>
      
  The deterministic choice operator prescribes that the left
  alternative should be tried before the right alternative, and that
  the latter is only used if the first fails. There are applications
  where it is not necessary to define the order of the
  alternatives. In those cases non-deterministic choice can be used.
    
</para>

<para>
      
  The non-deterministic choice operator s1 + s2 chooses one of the two
  strategies s1 or s2 to apply, such that the one it chooses
  succeeds. If both strategies fail, then the choice fails as well.
    
</para>

<para>
      
  Operationally one can imagine the choice operator to first try one
  strategy, and, if that fails, to try the other. The order in which
  this is done is undefined, i.e., arbitrarily chosen by the compiler.

  The \texttt{+} operator is needed to model modular composition of
  rewrite rules.

  Rules with the same label

  Explain implications of the \texttt{+} operator for semantics and
  implementation and semantics.

</para>

</section>

</section>

<section>
  <title>Recursion</title>

<para>

   Repeated application of a strategy can be achieved with recursion.
   There are two styles for doing this; with a recursive definition or
   using the fixpoint operator \texttt{rec}. A recursive definition is
   a normal strategy definition with a recursive call in its body. For
   example, the following defines the strategy \texttt{repeat}, which
   applies a transformation $s$ until it fails:

<screen>
  strategies
    repeat(s) = s; repeat(s) &lt;+ id
    eval = repeat(A &lt;+ B)
  rules
    A : P(Z,x) -> x
    B : P(S(x),y) -> P(x,S(y))
</screen>

  Note that sequential composition has higher priority than
        choice. Therefore, \texttt{$s_1$; $s_2$ &lt;+ $s_3$} should be
        read as \texttt{($s_1$; $s_2$) &lt;+ $s_3$}.

<screen>
        \tty{P(S(Z),Z)}
        \lstep{\tty{\small repeat(A+B)}}{\tty{S(Z)}}
</screen>

</para>

	
<para>
	  
  Repeated application of a strategy can be achieved with
  recursion. There are two styles for doing this; with a recursive
  definition or using the fixpoint operator rec. A recursive
  definition is a normal strategy definition with a recursive call in
  its body.
	
</para>

<screen>
try(s) = s &lt;+ id

repeat(s) = try(s; repeat(s))

while(c, s) = if c then s; while(c,s) end

do-while(s, c) = s; if c then do-while(s, c) end
</screen>

<screen>
  strategies
    repeat(s) = s; repeat(s) &lt;+ id
    eval = repeat(A &lt;+ B)
  rules
    A : P(Z,x) -> x
    B : P(S(x),y) -> P(x,S(y))
</screen>

  <screen>
map(s) =
  ?[] &lt;+ \ [x | xs] -> [&lt;s> x | &lt;map(s)> xs] \

foldr(s1, s2, f) =
  []; s1 &lt;+ \ [x|xs] -> &lt;s2>(&lt;f> x, &lt;foldr(s1, s2, f)> xs) \

length = foldr(!0, add, !1)
  </screen>


<section xml:id="rec">
  <title>Fixpoint operator (rec)</title>
    
 <para>

   Another way to define recursion is using the fixpoint operator
   <code>rec x(s)</code>, which recurses on applications of
   <code>x</code> within <code>s</code>.
     
 </para>
    
 <para>
    
   Originally, the <code>rec</code> operator was the only way to
   define recursion. It is still in the language in the first place
   because it is widely used in many existing programs, and in the
   second place because it can be a nice concise expression of a
   recursive strategy. An example usage is the definition of repeat
   with <code>rec</code>:
    
  </para>

  <screen>repeat(s) = try(s; repeat(s))</screen>

  <para>

    Iteration Strategies

    Using sequential composition, choice, and recursion a large
    variety of iteration strategies can be defined. The following
    module is part of the Stratego Standard Library:

  </para>

<screen>
  module iteration
  imports conditional
  strategies
    repeat(s, c)       = rec x(s; x &lt;+ c)
    repeat(s)          = repeat(s, id)
    repeat1(s, c)      = rec x(s; (x &lt;+ c))
    repeat1(s)         = repeat1(s, id)
    repeat-until(s, c) = rec x(s; (c &lt;+ x))

    while(c, s)        = rec x(try(c; s; x))
    do-while(s, c)     = rec x(s; try(c; x))
    while-not(c, s)    = rec x(c &lt;+ s; x)

    for(i, c, s)       = i; while-not(c, s)
</screen>

</section>

</section>

<section>
  <title>Summary</title>

<para>

</para>

</section>


</chapter>
