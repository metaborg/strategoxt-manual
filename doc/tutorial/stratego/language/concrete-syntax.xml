<chapter
  xml:id="stratego-concrete-syntax"
  xmlns="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2003/XInclude">

  <title>Concrete Object Syntax (*)</title>

<para>

  Meta-programs analyze, generate, and transform object programs.  In
  this process object programs are structured data; it is common
  practice to use abstract syntax trees rather than the textual
  representation of programs.  Abstract syntax trees are represented
  using the data structuring facilities of the meta-language; records
  (structs) in imperative languages (C), objects in object-oriented
  languages (C++, Java), algebraic data types in functional languages
  (ML, Haskell), and terms in term rewriting systems.

</para>

<para>

  Such representations allow the full capabilities of the meta
  language to be applied in the implementation of meta programs.  In
  particular, when working with high-level languages that support
  symbolic manipulation by means of pattern matching (e.g., ML,
  Haskell) it is easy to compose and decompose abstract syntax trees.
  For meta-programs such as compilers, programming with abstract
  syntax is adequate; only small fragments, i.e., a few constructors
  per pattern, are manipulated at a time.  Often, object programs are
  reduced to a core language that only contains the essential
  constructs. The abstract syntax can then be used as an intermediate
  language, such that multiple languages can be expressed in it, and
  meta-programs can be reused for several source languages.

</para>

<para>

  However, there are many applications of program transformation in
  which the use of abstract syntax is not adequate since the distance
  between the concrete programs that we understand and the abstract
  syntax trees used in specifications is too large.  Even in languages
  that support pattern matching on algebraic data types, the
  construction of large code fragments in a program generator can
  become painful. For example, even the following tiny program pattern
  is easier to read in the concrete variant on the left than the
  abstract variant on the right.

<screen>
let d* 
 in let var x ta := (e1*)
     in e2* end
end
</screen>

<screen>
Let(d*,
    [Let([VarDec(x,ta,Seq(e1*))],
         e2*)])
</screen>

  While abstract syntax is manageable for fragments of this size (and
  sometimes even more concise!), it becomes unpleasant to use when
  larger fragments need to be specified.
	
  Besides the problems of understandability and complexity, there are
  other reasons why the use of abstract syntax may be undesirable.
  Desugaring to a core language is not always possible. For example,
  in the renovation of legacy code the goal is to repair the bugs in a
  program, but leave it intact otherwise.  This entails that a much
  larger abstract syntax needs to be dealt with.  Another occasion
  that calls for the use of concrete syntax is the definition of
  transformation or generation rules by users (programmers) rather
  than by compiler writers (meta-programmers).  For example,
  \cite{PTH01} describes the extension of Haskell with pragmas for
  domain-specific optimization in the form of rewrite rules on program
  expressions.  Other application areas that require concrete syntax
  are application generation and structured document (XML) processing.

  Hence, it is desirable to have a meta-language that lets us write
  object-program fragments in the concrete syntax of the object
  language.  This requires the extension of the meta-language with the
  syntax of the object language $O$ of interest, such that $O$
  expressions are interpreted as terms.  In this chapter it is shown
  how a rewriting language using abstract syntax terms can be extended
  to support the use of concrete object syntax for terms. 

</para>

<section>
  <title>Instrumenting Programs</title>

<para>

  Instrumenting functions for tracing using concrete syntax and
  using abstract syntax

<screen>
  instrument = topdown(try(TraceProcedure + TraceFunction));
               IntroducePrinters; simplify

  TraceProcedure :
    FunDec(f, x*, NoTp, e) ->
    FunDec(f, x*, NoTp,
           Seq([Call(Var("enterfun"),[String(f)]), e,
                Call(Var("exitfun"),[String(f)])]))
  TraceFunction :
    FunDec(f, x*, Tp(tid), e) ->
    FunDec(f, x*, Tp(tid),
           Seq([Call(Var("enterfun"),[String(f)]),
                Let([VarDec(x,Tp(tid),NilExp)],
                    [Assign(Var(x), e),
                     Call(Var("exitfun"),[String(f)]),
                     Var(x)])]))
</screen>

<screen>
  TraceProcedure :
    |[ function f(x*) = e ]| ->
    |[ function f(x*) = (enterfun(s); e; exitfun(s)) ]|
    where !f => s

  TraceFunction :
    |[ function f(x*) : tid = e ]| ->
    |[ function f(x*) : tid =
         (enterfun(s);
          let var x : tid
           in x := e; exitfun(s); x
          end) ]|
    where new => x ; !f => s

  IntroducePrinters :
    e -> |[ let var ind := 0
                function enterfun(name : string) = (
                  ind := +(ind, 1);
                  for i := 2 to ind do print(" ");
                  print(name); print(" entry\\n"))
                function exitfun(name : string) = (
                  for i := 2 to ind do print(" ");
                  ind := -(ind, 1);
                  print(name); print(" exit\\n"))
             in e end ]|

</screen>

</para>

<para>

  To appreciate the need for concrete syntax in meta-programming, it
  is illuminating to constrast the use of concrete syntax with the
  traditional use of abstract syntax in a larger example.  Program
  \emph{instrumentation} is the extension of a program in a systematic
  way in order to obtain measurements during run-time. Instrumentation
  is used, for example, in debugging to get information about the
  run-time behaviour of a program, and in profiling to collect
  statistics about about run-time and call frequency of program
  elements.  Here we consider a simple instrumentation scheme that
  instruments Tiger functions with calls to trace functions.

</para>

<para>

  Figure~\ref{Fig:traceall} shows rewrite rules that instrument a
  function \verb|f| such that it prints \texttt{f entry} on entry of
  the function and \verb|f exit| at the exit. The actual printing is
  delegated to the functions \verb|enterfun| and \verb|exitfun|.
  Functions are instrumented differently than procedures, since the
  body of a function is an expression statement and the return value
  is the value of the expression. It is not possible to just glue a
  print statement or function call at the end of the body. Therefore,
  a let expression is introduced, which introduces a temporary
  variable to which the body expression of the function is assigned.
  The code for the functions \verb|enterfun| and \verb|exitfun| is
  generated by rule \verb|IntroducePrinters| in
  Figure~\ref{Fig:introduce-printers}.

</para>

<para>

  Figure~\ref{Fig:traceall} contrasts the use of concrete syntax (top)
  to the use of abstract syntax (bottom) for the same rewrite
  rules. It is clear that the concrete syntax version is much more
  concise and easier to read. This is partly due to the fact that the
  concrete version is shorter than the abstract version: 225 bytes vs
  320 bytes after eliminating all non-significant whitespace. However,
  the concrete version does not use much fewer lines.  A more
  important reason for the increased understandability is that in
  order to read the concrete version it is not necessary to mentally
  translate the abstract syntax constructors into concrete ones.  The
  implementation of \texttt{Introduce\-Printers} in
  Figure~\ref{Fig:introduce-printers} is only shown in concrete syntax
  since encoding in abstract syntax leads to unreadable code for code
  fragments of this size.

<screen>
  IntroducePrinters :
    e -> |[ let var ind := 0
                function enterfun(name : string) =
                (
                  ind := ind + 1;
                  for i := 2 to ind do
                    print(" ");
                  print(name); print(" entry\\n")
                )
                function exitfun(name : string) =
                (
                  for i := 2 to ind do
                    print(" ");
                  ind := ind - 1;
                  print(name);
                  print(" exit\\n")
                )
             in e end ]|
</screen>

  Note that these rewrite rules cannot be applied as such using simple
  innermost rewriting. After instrumenting a function declaration, it
  is still a function declaration and can thus be instrumented
  again. In other words, the rewrite system is non-terminating. This
  problem will be addressed in Part~\ref{Part:Strategies}.

</para>

<para>
\section{Observations about Concrete Syntax Specifications}

	The example gives rise to several observations. The concrete
	syntax version can be read without knowledge of the abstract
	syntax.  On the other hand, the abstract syntax version makes
	the tree structure of the expressions explicit.  The abstract
	syntax version is much more verbose and is harder to read and
	write. Especially the definition of large code fragments such
	as in rule \verb|IntroducePrinters| is unattractive in
	abstract syntax.

</para>

<para>

	The abstract syntax version \emph{implements} the concrete
	syntax version. The concrete syntax version has all properties
	of the abstract syntax version: pattern matching, term
	structure, can be traversed, etc.. In short, the concrete
	syntax is just sugar for the abstract syntax.

</para>

<para>

 \subsection{Extension of the Meta Language}

	The instrumentation rules make use of the concrete syntax of
	Tiger. However, program transformation should not be
	restricted to transformation of Tiger programs.  Rather we
	would like to be able to handle arbitrary object languages.
	Thus, the object language or object languages that are used in
	a module should be a parameter to the compiler. The
	specification of instrumentation is based on the real syntax
	of Tiger, not on some combinators or infix expressions. This
	entails that the syntax of Stratego should be extended with
	the syntax of Tiger.

</para>

<para>

 \subsection{Meta-Variables}

	The patterns in the transformation rules are not just
	fragments of Tiger programs. Rather some elements of these
	fragments are considered as meta-variables.  For example in
	the term

<screen>
|[ function f(x*) = e ]|
</screen>

	the identifiers \verb|f|, \verb|x*|, and \verb|e| are not
	intended to be Tiger variables, but rather meta-variables,
	i.e., variables at the level of the Stratego specification,
	ranging over identifiers, lists of function arguments, and
	expresssions, respectively.

</para>

<para>

 \subsection{Antiquotation}

	Instead of indicating meta-variables implicitly we could opt
	for an antiquotation mechanism that lets us splice in
	meta-level expressions into a concrete syntax fragment. For
	example, using \verb|~| and \verb|~*| as antiquotation
	operators, a variant of rule \verb|TraceProcedure| becomes:

<screen>
  TraceProcedure :
    |[ function ~f(~* x*) = ~e ]| -> 
    |[ function ~f(~* x*) = 
         (enterfun(~String(f)); ~e; exitfun(~String(f))) ]|
</screen>

	With such antiquotation operators it becomes possible to
	directly embed meta-level computations that produce a
	piece of code within a syntax fragment.

</para>

</section>

<section>
  <title>Implementation</title>

<para>
\section{Implementation}
	\label{Sec:implementation}

	In the previous section we have seen how the extension of
	Stratego with concrete syntax for terms improves the
	readability of meta-programs.  In this section we describe the
	techniques used to achieve this extension.

</para>

<para>

<screen>
 \subsection{Extending the Meta Language}

	\begin{figure}[b]
	\inputsource{xmpl/Stratego-Terms.sdf}
	\caption{Fragment of the syntax of Stratego}
	\label{Fig:StrategoTerm}
	\end{figure}

	\begin{figure}[t]
	\inputsource{xmpl/StrategoTiger.sdf}
	\caption{Combination of syntax definitions of Stratego and Tiger}
	\label{Fig:StrategoTiger}
	\end{figure}

	To embed the syntax of an object language in the meta language
	the syntax definitions of the two languages should be combined
	and the object language sorts should be injected into the
	appropriate meta language sorts. In the Stratego setting this
	is achieved as follows.  The syntax of a Stratego module
	\verb|m| is declared in the \verb|m.meta| file, which declares
	the name of an SDF module. For instance, for modules using
	Tiger concrete syntax, i.e., using the extension of Stratego
	with Tiger, the \verb|.meta| would contain
\begin{verbatim}
  Meta([Syntax("StrategoTiger")])
\end{verbatim}
	thus declaring SDF module \verb|StrategoTiger.sdf| as defining
	the extension.

	The SDF module combines the syntax of Stratego and the syntax
	of the object language(s) by importing the appropriate SDF
	modules.  The syntax definition of Stratego is provided by the
	compiler. The syntax definition of the object language is
	provided by the user. For example,
	Figure~\ref{Fig:StrategoTerm} shows a fragment of the syntax
	of Stratego and Figure~\ref{Fig:StrategoTiger} shows SDF
	module \verb|StrategoTiger|, which defines the extension of
	Stratego with Tiger as object language. The module illustrates
	several remarkable aspects of the embedding of object
	languages in meta languages using SDF.

	A combined syntax definition is created by just importing
	appropriate syntax definitions.  This is possible since SDF is
	a modular syntax definition formalism.  This is a rather
	unique feature of SDF and essential to this kind of language
	extension. Since only the full class of context-free grammars,
	and not any of its subclasses such as LL or LR, are closed
	under composition, modularity of syntax definitions requires
	support from a generalized parsing technique. SDF2 employs
	scannerless generalized-LR parsing~\cite{Vis97.thesis,BSVV02}.

	The syntax definitions for two languages may partially
	overlap, e.g., define the same sorts. SDF2 supports renaming
	of sorts to avoid name clashes and ambiguities resulting from
	them. In Figure~\ref{Fig:StrategoTiger} several sorts from the
	Stratego syntax definition (\verb|Term|, \verb|Id|,
	\verb|Var|, and \verb|StrChar|) are renamed since the Tiger
	definition also defines these names\footnote{In practice,
	instead of doing this renaming for each language extension,
	module \texttt{StrategoRenamed} provides a syntax definition
	of Stratego in which all sorts have been renamed.}

	The embedding of object language expressions in the
	meta-language is implemented by adding appropriate injections
	to the combined syntax definition. For example, the production 
{\small
\begin{verbatim}
    "|[" Exp "]|" -> StrategoTerm {cons("ToTerm"),prefer}
\end{verbatim}
}%
%
	\noindent declares that a Tiger expression (\verb|Exp|)
	between \verb+|[+ and \verb+]|+ can be used everywhere where a
	\verb|StrategoTerm| can be used. Furthermore, abstract syntax
	expressions (including meta-level computations) can be spliced
	into concrete syntax expressions using the \verb|~| splice
	operators. To distinguish a term that should be interpreted as
	a list from a term that should be interpreted as a list
	\emph{element}, the convention is to use a \verb|~*| operator
	for splicing a list.
	
	The declaration of these injections can be automated by
	generating an appropriate production for each sort as a
	transformation on the SDF definition of the object language.
	It is, however, useful that the embedding can be programmed by
	the meta-programmer to have full control over the selection of
	the sorts to be injected, and the syntax used for the
	injections.

 \subsection{Meta-Variables}

	Using the injection of meta-language \verb|StrategoTerm|s into object
	language \verb|Exp|ressions it is possible to distinguish
	meta-variables from object language identifiers. Thus, in the
	term \verb+|[ var ~x := ~e]|+, the expressions \verb|~x| and
	\verb|~e| indicate meta-level terms, and hence \verb|x| and
	\verb|e| are meta-level variables.

	However, it is attractive to write object patterns with as few
	squigles as possible. This can be achieved through another
	feature of SDF, i.e., variable declarations.
	Figure~\ref{Fig:TigerVariables} declares syntax schemata for
	meta variables. According to this declaration \verb|x|,
	\verb|y|, and \verb|g10| are meta-variables for identifiers
	and \verb|e|, \verb|e1|, and \verb|e1023| are meta-variables
	of sort \verb|Exp|. The last three productions declare
	variables over lists using the convention that these are
	distinquished from other variables with an asterisk. Thus,
	\verb|x*| and \verb|x1*| range over lists of function
	arguments.  The prefer attribute ensures that these
	identifiers are preferred over normal Tiger
	identifiers~\cite{BSVV02}.

\begin{figure}[bt]
\begin{boxedminipage}{\hsize}\small
\begin{verbatim}
module Tiger-Variables
exports
  variables
    [s][0-9]*      -> StrConst    {prefer}
    [xyzfgh][0-9]* -> Id          {prefer}
    [e][0-9]*      -> Exp         {prefer}
    "ta"[0-9]*     -> TypeAn      {prefer}
    "x"[0-9]* "*"  -> {FArg ","}+ {prefer}
    "d"[0-9]* "*"  -> Dec+        {prefer}
    "e"[0-9]* "*"  -> {Exp ";"}+  {prefer}
\end{verbatim}
%\verbatimtabinput{\tigerfrontdir/syn/Tiger-Variables.sdf}
\end{boxedminipage}
\caption{Some variable schema declarations for Tiger sorts.}
\label{Fig:TigerVariables}
\end{figure}

 \subsection{Meta-Explode}

	Parsing a module according to the combined syntax and mapping
	the parse tree to abstract syntax results in an abstract
	syntax tree that contains a mixture of meta- and
	object-language abstract syntax.  Since the meta-language
	compiler only deals with meta-language abstract syntax, the
	embedded object-language abstract syntax needs to be expressed
	in terms of meta abstract syntax.  For example, parsing the
	following Stratego rule

\begin{center}
\begin{boxedminipage}{\hsize}\small
\begin{verbatim}
 |[ x := let d* in ~* e* end ]| -> |[ let d* in x := (~* e*) end ]|
\end{verbatim}
\end{boxedminipage}
\end{center}

	\noindent with embedded Tiger expressions, results in the
	abstract syntax tree 

\begin{center}
\begin{boxedminipage}{\hsize}\small
\begin{verbatim}
  Rule(ToTerm(Assign(Var(meta-var("x")),
                     Let(meta-var("d*"),FromTerm(Var("e*"))))),
       ToTerm(Let(meta-var("d*"),
                  [Assign(Var(meta-var("x")),
                          Seq(FromTerm(Var("e*"))))])))
\end{verbatim}
\end{boxedminipage}
\end{center}

	\noindent containing Tiger abstract syntax constructors (e.g.,
	\verb|Let|, \verb|Var|, \verb|Assign|) and meta-variables
	(\verb|meta-var|). The transition from meta language to object
	language is marked by the \verb|ToTerm| constructor, while the
	transition from meta-language to object-language is marked by
	the constructor \verb|FromTerm|.

	Such mixed abstract syntax trees can be normalized by
	`exploding' all embedded abstract syntax to meta-language
	abstract syntax. Thus, the above tree should be exploded
	to the following pure Stratego abstract syntax:

\begin{center}
\begin{boxedminipage}{\hsize}\small
\begin{verbatim}
  Rule(Op("Assign",[Op("Var",[Var("x")]),
                    Op("Let",[Var("d*"),Var("e*")])]),
       Op("Let",[Var("d*"),
                 Op("Cons",[Op("Assign",[Op("Var",[Var("x")]),
                                         Op("Seq",[Var("e*")])]),
                            Op("Nil",[])])]))
\end{verbatim}
\end{boxedminipage}
\end{center}

	\noindent Observe that in this explosion all embedded
	constructor applications have been translated to the form
	\verb|Op(C,[t1,...,tn])|. For example, the Tiger `variable'
	constructor \verb|Var(_)| becomes \verb|Op("Var",[_])|, while
	the Stratego meta-variable \verb|Var("e*")| remains untouched,
	and \verb|meta-var|s become Stratego \verb|Var|s.  Also note
	how the list in the second argument of the second \verb|Let|
	is exploded to a \verb|Cons|/\verb|Nil| list.
	
	The resulting term corresponds to the abstract syntax
	for the rule

\begin{center}
\begin{boxedminipage}{\hsize}\small
\begin{verbatim}
  Assign(Var(x),Let(d*,e*)) -> Let(d*,[Assign(Var(x),Seq(e*))])
\end{verbatim}
\end{boxedminipage}
\end{center}

	\noindent written with abstract syntax notations for terms.

	The explosion of embedded abstract syntax does not depend on
	the object language; it can be expressed generically, provided
	that embeddings are indicated with the \verb|FromTerm|
	constructor. The \emph{complete} implementation of the
	\verb|meta-explode| transformation on \verb|StrategoTerm|
	abstract syntax trees is presented in
	Section~\ref{Sec:metaexplode} at the end of this chapter.  The
	implementation makes use of Stratego features not yet
	treated. But, the details of this transformation are not
	important for understanding the use of concrete syntax. The
	reader can refer back to Section~\ref{Sec:metaexplode} after
	reading Part~\ref{Part:Strategies}.

\section{Generalization}
	\label{Sec:generalization}

	In the previous section we described the embedding of concrete
	syntax for object languages in Stratego.  This approach can be
	generalized to other meta-languages.  In this section we
	outline the ingredients needed to make your favorite language
	into a meta-language.

\subsection{Components}

	Given a (general-purpose) language $M$ to be used as
	meta-language and a language $O$, which may be a data format,
	a programming language, or a domain-specific language, as long
	as it has a formal syntax, we can extend $M$ to a
	meta-language for manipulating $O$
	programs. Figure~\ref{Fig:arch} depicts the architecture of
	this extension and the components that are employed. The large
	box denotes the extension of the $M$ compiler \verb|m-compile|
	with concrete syntax for $O$. From a meta-programmer's point
	of view this is a black box that implements the compiler
	(dashed arrow) \verb|mo-compile|, which consumes source
	meta-programs and produces executable meta-programs. In the
	rest of this section we briefly discuss the components
	involved.

\begin{figure}[p]
\begin{boxedminipage}{\hsize}\small
\begin{center}
  \ifpdftex
	\includegraphics{arch-eps.pdf}
  \else
	\includegraphics{arch.eps}
  \fi
\end{center}
\end{boxedminipage}
\caption{Architecture for meta-programming with concrete object syntax}
\label{Fig:arch}
\end{figure}

\begin{description}

\item[ATerm Library]

	\ \\
	The communication between the various components is achieved
	by exchanging ATerms \cite{BJKO00}, a generic format for
	exchange of structured data.

\item[SDF tools] 
	
	\ \\ The syntax definition formalism SDF is used for parsing
	programs in the combined syntax. The following tools are
	used in the process:
	\begin{itemize}

	\item \verb|pack-sdf|: collection of all imported SDF modules;

	\item \verb|sdf2table|: parser generator for SDF;

	\item \verb|sglr|: scannerless generalized-LR parser reads a
	parse table (\verb|M-O.tbl|) and parses a source file
	according to it;
	
	\item \verb|implode-asfix|: translation from parse trees to abstract
	syntax trees;

	\item Optionally one can use pretty-printer and signature
	generators. 

	\end{itemize}

\item[$M$ as meta-language]
	
	\ \\ To use a certain language $M$ as meta-language the following
	ingredients are needed:
	\begin{itemize}

	\item A syntax definition \verb|M.sdf| of $M$

	\item A model for object program representation in $M$ (e.g., AST
	represented as term)

	\item An API for constructing and analyzing $O$ programs in
	$M$ (e.g., pattern instantiation and matching)
	
	\item \verb|m-explode|: An explosion algorithm for
	transforming $O$ abstract syntax expressions into $M$
	expressions. If the object language program representation is
	generic, i.e., does not depend on a specific $O$, this can be
	implemented generically, as was done for Stratego using
	\texttt{meta\-explode}. This is a transformation on $M$
	programs.

	\end{itemize}

\item[$O$ as object language] 

	\ \\ To use $O$ as object language embedded in $M$ the
	following ingredients are needed: 

	\begin{itemize}

	\item A syntax definition \verb|O.sdf| of $O$

	\item A combined syntax definition \verb|M-O.sdf|, possibly resolving
	name clashes

	\item Meta-variable declarations for $O$

	\item Injection of $O$ expressions into $M$ expressions

		\begin{itemize}

	   	\item Selection of $O$ syntactic categories to
	   	manipulate (e.g., \verb|Exp| and \verb|Dec|)

           	\item Selection of $M$ syntactic categories in which
           	$O$ expressions should be injected (e.g., \verb|StrategoTerm|)

	     	\item Quotation syntax (e.g., \verb+|[...]|+)

		\item Anti quotation syntax (e.g., \verb|~...|)
	
		\end{itemize}

	It is possible to automate this by generating syntax for
	variables, quotations, and antiquotations automatically from
	the syntax definition of $O$, provided that there is a
	standard convention for quotation and antiquotation.

	\end{itemize}

\item[$M$ compiler]

	\ \\ After \verb|m-exploding| meta-programs they can be
	compiled by the usual compiler \verb|m-compile| for $M$. If
	the compiler does not have an option to consume abstract
	syntax trees, but only text, it is necessary to pretty-print
	the program first.

\item[$O$ meta-programs]
	
	\ \\ Finally, we can write a meta-program \verb|MetaProg.mo|
	using concrete syntax and compile it to an executable
	\verb|MetaProg.bin| that manipulates $O$ programs.

\end{description}

\subsection{Implementation}

	The architecture described above is implemented by
	\texttt{parse-cs}, a generic program for parsing programs with
	embedded concrete syntax.  It has been applied in the
	extension of Prolog with concrete syntax~\cite{FV03.retrofit}.

	The program is parameterized with meta-data indicating
	components for various aspects such as parsing, exploding,
	desugaring, and pretty-printing. The meta data can be
	specified in a \texttt{.meta} file specific for a program to
	be parsed, or it can be associated with an extension and
	registered in an XTC repository (See Chapter~\ref{Chap:XTC}).

	For example, the following is the contents of
	\texttt{pl.meta}, the meta-data for Prolog programs with
	embedded syntax. The assumption (in this example) is that
	syntax embeddings use a standard (\texttt{ToTerm}) convention
	for indicating the boundary between meta- and object-syntax.
\begin{verbatim}
  Meta([
    Syntax("Prolog"),
    ParseTable("Prolog.tbl"),
    Explode("prolog-explode"),
    PrettyPrintTable("Prolog-pretty.pp.af")
  ])
\end{verbatim}
	This information can be overridden in a file specific
	\texttt{.meta} file with the same extension. For example, the
	following indicates an embedding of ABIR in Prolog and a
	specific desugaring tool for this format:
\begin{verbatim}
  Meta([
    Syntax("PrologABIR"),
    PostExplodeDesugar("abir-in-prolog-implode")
  ])
\end{verbatim}
	It overrides the syntax component, and adds a desugaring component.

	In order to define such meta-data for a whole class of
	programs, it can be defined in a meta file associated with a
	new extension. For example, the following is the contents
	\texttt{plabir.meta}, which defines all meta-data for
	preprocessing Prolog with embedded ABIR in files with
	extension \texttt{.plabir}.
\begin{verbatim}
  Meta([
    Syntax("PrologABIR"),
    Explode("prolog-explode"),
    PostExplodeDesugar("abir-in-prolog-implode"),
    PrettyPrintTable("Prolog-pretty.pp.af")
  ])
\end{verbatim}


\section{Discussion}

 \subsection{Disambiguating Quotations}

	Sometimes the fragments used within quotations are too small
	for the parser to be able to disambiguate them. In those cases
	it is useful to have alternative versions of the quotation
	operators that make the sort of the fragment explicit. A
	useful, although somewhat verbose, convention is to use the
	sort of the fragment as operator:
{\small
\begin{verbatim}
   "exp" "|[" Exp "]|" -> StrategoTerm {cons("ToTerm")}
\end{verbatim}
}

 \subsection{Other Quotation Conventions}

	The convention of using \texttt{|[...]|} and \verb|~| as
	quotation and anti-quotation delimiters is inspired by the
	notation used in texts about semantics. It really depends on
	the application, the languages involved, and the `audience'
	what kind of delimiters are most appropriate. 
	
	In \cite{Wij03,Bra03} a notation inspired by active web pages
	is developed. For instance, the following quotation
	\verb|%>...&lt;%| and antiquotation \verb|&lt;%...%>| delimiters are
	defined for use of XML in Stratego programs:
\begin{verbatim}
  context-free syntax
    "%>" Content "&lt;%" -> StrategoTerm {cons("ToTerm"),prefer}
    "&lt;%=" StrategoTerm     "%>" -> Content {cons("FromTerm")}
    "&lt;%"  StrategoStrategy "%>" -> Content {cons("FromApp")}
\end{verbatim}

 \subsection{Desugaring Patterns}

	Some meta-programs first desugar a program before transforming
	it further. This reduces the number of constructs and shapes a
	program can have. For example, the Tiger binary operators are
	desugared to prefix form:
%
{\small
\begin{verbatim}
  DefTimes : |[ e1 * e2 ]|  -> |[ *(e1, e2) ]|
  DefPlus  : |[ e1 + e2 ]|  -> |[ +(e1, e2) ]|
\end{verbatim}
}
%
	\noindent 
	or in abstract syntax
%
{\small
\begin{verbatim}
  DefPlus : Plus(e1, e2) -> BinOp(PLUS, e1, e2)
\end{verbatim}
}
%
	\noindent This makes it easy to write generic transformations
	for binary operators. However, all subsequent transformations
	on binary operators should then be done on these prefix forms,
	instead of on the usual infix form.  However,
	users/meta-programmers think in terms of the infix operators
	and would like to write rules such as
%
{\small
\begin{verbatim}
  Simplify : |[ e + 0 ]| -> |[ e ]|
\end{verbatim}
}
%
	\noindent However, this rule will not match since the term to
	which it is applied has been desugared.  Thus, it might be
	desirable to desugar embedded abstract syntax with the same
	rules with which programs are desugared.
	This phenomenon occurs in many forms ranging from removing
	parentheses and generalizing binary operators as above, to
	decorating abstract syntax trees with information resulting
	from static analysis such as type checking. 

\section{Further Reading}

 \subsection{Quotation}

	The problem of concrete object syntax is traditionally
	approached by extending $M$ with a quotation operator that
	lets the meta-programmer indicate object language fragments
	\cite{Aas92,MR94,WC93}.  Antiquotation allows the splicing of
	computed code into these object language fragments.  If $M$
	equals $O$ then the syntax extension is easy; just add quote
	and anitquote operators to $M$. For example, MetaML
	\cite{Tah99}, provides \verb|&lt;...>| for distinghuishing a
	piece of object code and \verb|~...| to splice some computed
	code into another piece of code.

 \subsection{Syntax Definition and Parsing}

	Building a meta-language that supports a different object
	language is a difficult task with traditional parser
	technology. Building a meta-language that allows the user to
	define the object language to use and determine the syntax for
	quotation and antiquotation operators is even harder.  Why is
	this a difficult task?  Traditional parser generators support
	only context-free grammars that are restricted to the LL or LR
	properties.  Since these classes of grammars are not closed
	under composition, it is hard to extend one language with
	another.  For example, combining two YACC grammars will
	usually lead to many conflicts, requiring editing the two
	grammars, probably extensively.  The problem is compounded by
	the fact that lexical syntax is dealt with using a scanner,
	which operates separately from the parser. An embedded object
	language will almost certainly overlap at the lexical level
	with the host language (e.g., syntax of identifiers, literals,
	keywords). Thus, combining the two regular grammars will also
	require extensive editing.

	The usual solution is to require a fixed syntax for quotation
	delimiters and parse the content of quotations in a separate
	pass. This requires quite some infrastructure and makes
	reporting syntax errors to the programmer difficult. The
	technology used to extend a meta-language is usually not
	portable to other languages.

	In this chapter it is shown how the syntax definition
	formalism SDF~\cite{HHKR89,Vis97.thesis} can be employed to
	fit an existing (meta-) programming language with concrete
	syntax notation for object programs.  \emph{The approach does
	not require that either the meta-language or the
	object-language were designed with this application in mind.}
	Rather, the syntax definitions of the meta-language and
	object-language are combined as they are and wedded by
	providing appropriate injections from object language sorts
	into meta language sorts. From the combined syntax definition
	a parser is generated that parses the entire meta-program
	including object code fragments, and thus reports syntactic
	errors immediately. An explosion algorithm that can be
	independent of the object language then maps embedded object
	code abstract syntax trees to appropriate meta language
	representations. 

	SDF \cite{HHKR89} was originally designed for use as a general
	syntax definition formalism. However, through its
	implementation it was closely tied to the algebraic
	specification formalism ASF+SDF \cite{BHK89,DHK96}, which is
	supported by the ASF+SDF Meta-Environment
	\cite{Kli93.meta,MetaEnv01}. Redesign and reimplementation of
	SDF~\cite{Vis97.thesis,BSVV02} has made the language and tools
	available for use outside the Meta-Environment. SDF is also
	distributed as part of the XT bundle of program transformation
	tools \cite{JVV01}.

	Syntax definition in SDF is limited to \emph{context-free
	grammars}.  This is a limitation for languages with
	context-sensitive syntax such as C (type identifiers) and
	Haskell (offside rule). However, in the setting of
	meta-programming with concrete object syntax, in which small
	fragments are used and not all context is always available,
	any parsing technique will have a hard time. This type of
	problem made Cameron and Ito \cite{CI84} suggest that language
	designers should consider meta-programming in designing the
	syntax of a programming language.

	(** Note: does not have to be a problem for use of concrete
	syntax in meta programs **)

\subsection{User-definable Syntax}

	Programming languages with user-definable syntax have been a
	long standing goal of programming language research.  To a
	certain extent programming languages do provide
	domain-specific or user-definable syntax.  The use of infix
	syntax for arithmetic and logical operators is such a standard
	component of programming language syntax, that it is not
	considered a syntactic extension. However, they are clearly
	domain-specific operations, that could just as well be
	expressed using function call syntax.  Indeed a number of
	languages (Prolog, Haskell, ...) allow the user to introduce
	new infix operators and define them just like a normal
	predicate or function.  Other languages, especially in the
	domain of algebraic specification and theorem proving, have
	support for user-defined mixfix operators (e.g., OBJ, ELAN,
	Maude).  This approach is taken to its extreme in the
	algebraic specification formalism ASF+SDF~\cite{BHK89,DHK96}
	in which all expression constructors are defined by the user,
	including the \emph{lexical syntax}.  An ASF+SDF specification
	consists of modules defining syntax and conditional equations
	over terms induced by this syntax. The equations are
	interpreted as term rewrite rules.  The influence of ASF+SDF
	on the work described in this chapter is profound---Stratego
	grew out of experience with ASF+SDF.

	The architecture of JTS \cite{BLS98} is much like the one
	described in this chapter, but the goal is the extension of
	languages with domain-specific constructs. The JTS tools are
	based on less powerful (i.e., lex/yacc) parsing technology.

	Several experiments have been done with dynamically
	(parse-time) extensible syntax \cite{WC93,CMA94,BS02}. In
	these tools the program itself contains declarations of syntax
	extensions. This complicates the parsing process considerably.
	We have chosen to define the syntax in a separate file.  This
	entails that the syntax for an entire module is fixed and
	cannot be extended half way.  This is reasonable for
	meta-programming since the syntactic domain of meta-programs
	is usually a fixed object language or set of object
	languages. Changing the object language on a per module basis
	is fine grained enough.

\subsection{Syntax Macros}
	
	The problem of concrete object syntax is different from
	extending a language with new constructs, for example,
	extending C with syntax for exception handling. This
	application known as syntax macros, syntax extensions, or
	extensible syntax \cite{WC93,CMA94,BS02} can be expressed
	using the same technology as discussed in this chapter. Indeed,
	Stratego itself is an example of a language with syntactic
	extensions that are removed using transformations. For
	example, the following rules define several constructs in
	terms of the more primitive match (\verb|?t|) and build
	(\verb|!t|) constructs \cite{VBT98}.
%
{\small
\begin{verbatim}
  Desugar :
    |[ s => t ]| -> |[ s; ?t ]|
  Desugar :
    Strategy|[ &lt;s> t ]| -> |[ !t; s ]|
  Desugar:
    |[ f(as) : t1 -> t2 where s ]| -> |[ f(as) = ?t1; where(s); !t2 ]|
\end{verbatim}
}

%\newpage
\section{Exercises}

\subsection{}

	Rewrite the simplification rules for arithmetic and Boolean
	expressions of Exercise~5.1 using concrete syntax.

\subsection{}

	For each of the following rules, give the abstract syntax
	before and after meta-exploding

		\begin{enumerate}
		\item  {\small
\begin{verbatim}
  TimesPlus :
    |[ x * (y + z) ]| -> |[ (x * y) + (x * z) ]|
\end{verbatim}
}

		\item {\small
\begin{verbatim}
  RenameFun :
    |[ function f(x*) = e ]| -> 
    |[ function ~&lt;NewFun>f (x*) = e ]|
\end{verbatim}
}

		\end{enumerate}

\subsection{}

	Why is it necessary to rename the sorts from the
	Stratego syntax definition? What would happen if this was
	not done?

\subsection{}
	
	Write a syntax definition for StrategoXML that supports
	writing XML expressions in Stratego rules using 
\verb|%> ... &lt;%| 
	as quotation for XML expressions and 
\verb|&lt;% ... %>| 
	as antiquotation syntax. Then it is possible to write
	rules such as the following: {\small
\begin{verbatim}
   GenHTML : (t, b) ->
     %>
        &lt;html> 
          &lt;head>
            &lt;title> &lt;% t %> &lt;/title>
          &lt;/head>
          &lt;body>
	     &lt;% b %>
          &lt;/body>
        &lt;/html>
     &lt;%
\end{verbatim}
}
	Assume the following toy syntax definition for XML that
	defines the sorts \verb|Element| for a tagged node and
	\verb|Content*| for the arguments of a tagged node. {\small
\begin{verbatim}
module XML
imports Identifiers Text
exports
  context-free syntax
    "&lt;" Id ">" Content* "&lt;" "/" Id ">" -> Element {cons("Elt")}
    Text                               -> Content
    Element                            -> Content
\end{verbatim}
}

	What is the abstract syntax before and after exploding the
	following example:{\small
\begin{verbatim}
   MkAddress : (name, street, city) ->
     %>
        &lt;address> 
          &lt;% name %>
          &lt;% street %> 
          &lt;% city %> 
        &lt;/address> 
     &lt;%
\end{verbatim}
}

%\begin{verbatim}
%FromTerm(Elt(\"address\", [ToTerm(Var(name)), ...
%\end{verbatim}


\subsection{}

	Consider what is needed to extend one (or all) of the
	following languages with concrete object syntax for
	data. Sketch what a program with concrete syntax might look
	like and how it would be translated to the plain language.

		\begin{enumerate}
	
		\item Prolog

		\item Haskell

		\item Java

		\item C

		\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Meta-Explode

\newpage 
\section{Generic Definition of Meta-Explode}
	\label{Sec:metaexplode}

	The strategy \texttt{MetaExplode} uses the generic strategy
	\texttt{alltd} to perform a generic traversal over the
	abstract syntax tree of a Stratego module. Anywhere in this
	tree where it finds a \texttt{ToTerm(\_)}, its argument is
	exploded using \texttt{trm-explode}. This latter strategy is
	composed from a number of rules that recognize special
	cases. The general case is handled by \texttt{TrmOp}, which
	decomposes a term into its constructor \texttt{op} and
	arguments \texttt{ts}, and constructs an abstract syntax term
	\texttt{Op(op,ts')}, where the \texttt{ts'} are the exploded
	arguments. The transformation \texttt{str-explode} is similar
	to \texttt{trm-explode}, but transforms embedded abstract
	syntax into strategy expressions.

	\input{meta-explode.str}

</screen>

</para>

</section>

<section>
  <title>Summary</title>

<para>

</para>

</section>

</chapter>
