<chapter
  xml:id="stratego-concrete-syntax"
  xmlns="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2003/XInclude">

  <title>Concrete Object Syntax (*)</title>

<para>

  Meta-programs analyze, generate, and transform object programs.  In
  this process object programs are structured data; it is common
  practice to use abstract syntax trees rather than the textual
  representation of programs.  Abstract syntax trees are represented
  using the data structuring facilities of the meta-language; records
  (structs) in imperative languages (C), objects in object-oriented
  languages (C++, Java), algebraic data types in functional languages
  (ML, Haskell), and terms in term rewriting systems.

</para>

<para>

  Such representations allow the full capabilities of the meta
  language to be applied in the implementation of meta programs.  In
  particular, when working with high-level languages that support
  symbolic manipulation by means of pattern matching (e.g., ML,
  Haskell) it is easy to compose and decompose abstract syntax trees.
  For meta-programs such as compilers, programming with abstract
  syntax is adequate; only small fragments, i.e., a few constructors
  per pattern, are manipulated at a time.  Often, object programs are
  reduced to a core language that only contains the essential
  constructs. The abstract syntax can then be used as an intermediate
  language, such that multiple languages can be expressed in it, and
  meta-programs can be reused for several source languages.

</para>

<para>

  However, there are many applications of program transformation in
  which the use of abstract syntax is not adequate since the distance
  between the concrete programs that we understand and the abstract
  syntax trees used in specifications is too large.  Even in languages
  that support pattern matching on algebraic data types, the
  construction of large code fragments in a program generator can
  become painful. For example, even the following tiny program pattern
  is easier to read in the concrete variant on the left than the
  abstract variant on the right.

<screen>
let d* 
 in let var x ta := (e1*)
     in e2* end
end
</screen>

<screen>
Let(d*,
    [Let([VarDec(x,ta,Seq(e1*))],
         e2*)])
</screen>

  While abstract syntax is manageable for fragments of this size (and
  sometimes even more concise!), it becomes unpleasant to use when
  larger fragments need to be specified.

</para>

<para>
	
  Besides the problems of understandability and complexity, there are
  other reasons why the use of abstract syntax may be undesirable.
  Desugaring to a core language is not always possible. For example,
  in the renovation of legacy code the goal is to repair the bugs in a
  program, but leave it intact otherwise.  This entails that a much
  larger abstract syntax needs to be dealt with.  Another occasion
  that calls for the use of concrete syntax is the definition of
  transformation or generation rules by users (programmers) rather
  than by compiler writers (meta-programmers).  For example,
  \cite{PTH01} describes the extension of Haskell with pragmas for
  domain-specific optimization in the form of rewrite rules on program
  expressions.  Other application areas that require concrete syntax
  are application generation and structured document (XML) processing.

</para>

<para>

  Hence, it is desirable to have a meta-language that lets us write
  object-program fragments in the concrete syntax of the object
  language.  This requires the extension of the meta-language with the
  syntax of the object language $O$ of interest, such that $O$
  expressions are interpreted as terms.  In this chapter it is shown
  how a rewriting language using abstract syntax terms can be extended
  to support the use of concrete object syntax for terms. 

</para>

<section>
  <title>Instrumenting Programs</title>

<para>

  To appreciate the need for concrete syntax in meta-programming, it
  is illuminating to constrast the use of concrete syntax with the
  traditional use of abstract syntax in a larger example.  Program
  <emphasis>instrumentation</emphasis> is the extension of a program
  in a systematic way in order to obtain measurements during
  run-time. Instrumentation is used, for example, in debugging to get
  information about the run-time behaviour of a program, and in
  profiling to collect statistics about about run-time and call
  frequency of program elements.  Here we consider a simple
  instrumentation scheme that instruments Tiger functions with calls
  to trace functions.

</para>

<para>

  The following Stratego fragment shows rewrite rules that instrument
  a function <code>f</code> such that it prints <code>f entry</code>
  on entry of the function and <code>f exit</code> at the exit. The
  actual printing is delegated to the functions <code>enterfun</code>
  and <code>exitfun</code>.  Functions are instrumented differently
  than procedures, since the body of a function is an expression
  statement and the return value is the value of the expression. It is
  not possible to just glue a print statement or function call at the
  end of the body. Therefore, a let expression is introduced, which
  introduces a temporary variable to which the body expression of the
  function is assigned.  The code for the functions
  <code>enterfun</code> and <code>exitfun</code> is generated by rule
  <code>IntroducePrinters</code>. Note that the declarations of the
  <code>Let</code> generated by that rule have been omitted.

<screen>
instrument = 
  topdown(try(TraceProcedure + TraceFunction))
  ; IntroducePrinters
  ; simplify

TraceProcedure :
  FunDec(f, x*, NoTp, e) ->
  FunDec(f, x*, NoTp,
         Seq([Call(Var("enterfun"),[String(f)]), e,
              Call(Var("exitfun"),[String(f)])]))

TraceFunction :
  FunDec(f, x*, Tp(tid), e) ->
  FunDec(f, x*, Tp(tid),
         Seq([Call(Var("enterfun"),[String(f)]),
              Let([VarDec(x,Tp(tid),NilExp)],
                  [Assign(Var(x), e),
                   Call(Var("exitfun"),[String(f)]),
                   Var(x)])]))

IntroducePrinters : 
  e -> Let(..., e)
</screen>

  The next program program fragment implements the same
  instrumentation transformation, but now it uses <emphasis>concrete
  syntax</emphasis>. 

<screen>
TraceProcedure :
  |[ function f(x*) = e ]| ->
  |[ function f(x*) = (enterfun(s); e; exitfun(s)) ]|
  where !f => s

TraceFunction :
  |[ function f(x*) : tid = e ]| ->
  |[ function f(x*) : tid =
       (enterfun(s);
        let var x : tid
         in x := e; exitfun(s); x
        end) ]|
  where new => x ; !f => s

IntroducePrinters :
  e -> |[ let var ind := 0
              function enterfun(name : string) = (
                ind := +(ind, 1);
                for i := 2 to ind do print(" ");
                print(name); print(" entry\\n"))
              function exitfun(name : string) = (
                for i := 2 to ind do print(" ");
                ind := -(ind, 1);
                print(name); print(" exit\\n"))
           in e end ]|
</screen>

  It is clear that the concrete syntax version is much more concise
  and easier to read. This is partly due to the fact that the concrete
  version is shorter than the abstract version: 225 bytes vs 320 bytes
  after eliminating all non-significant whitespace. However, the
  concrete version does not use much fewer lines.  A more important
  reason for the increased understandability is that in order to read
  the concrete version it is not necessary to mentally translate the
  abstract syntax constructors into concrete ones.  The implementation
  of <code>IntroducePrinters</code> is only shown in concrete syntax
  since its encoding in abstract syntax leads to unreadable code for
  code fragments of this size.

</para>

<para>

  Note that these rewrite rules cannot be applied as such using simple
  innermost rewriting. After instrumenting a function declaration, it
  is still a function declaration and can thus be instrumented
  again. Therefore, we use a single pass topdown strategy for applying
  the rules.

</para>

</section>

<section>
  <title>Observations about Concrete Syntax Specifications</title>

<para>

  The example gives rise to several observations. The concrete syntax
  version can be read without knowledge of the abstract syntax.  On
  the other hand, the abstract syntax version makes the tree structure
  of the expressions explicit.  The abstract syntax version is much
  more verbose and is harder to read and write. Especially the
  definition of large code fragments such as in rule
  <code>IntroducePrinters</code> is unattractive in abstract syntax.

</para>

<para>

  The abstract syntax version <emphasis>implements</emphasis> the
  concrete syntax version. The concrete syntax version has all
  properties of the abstract syntax version: pattern matching, term
  structure, can be traversed, etc.. In short, the concrete syntax is
  just sugar for the abstract syntax.

</para>

<formalpara>
  <title>Extension of the Meta Language</title>

<para>

  The instrumentation rules make use of the concrete syntax of
  Tiger. However, program transformation should not be restricted to
  transformation of Tiger programs.  Rather we would like to be able
  to handle arbitrary object languages.  Thus, the object language or
  object languages that are used in a module should be a parameter to
  the compiler. The specification of instrumentation is based on the
  real syntax of Tiger, not on some combinators or infix
  expressions. This entails that the syntax of Stratego should be
  extended with the syntax of Tiger.

</para>

</formalpara>

<formalpara>
  <title>Meta-Variables</title>

<para>

  The patterns in the transformation rules are not just fragments of
  Tiger programs. Rather some elements of these fragments are
  considered as meta-variables.  For example in the term

<screen>
|[ function f(x*) = e ]|
</screen>

  the identifiers <code>f</code>, <code>x*</code>, and <code>e</code>
  are not intended to be Tiger variables, but rather meta-variables,
  i.e., variables at the level of the Stratego specification, ranging
  over identifiers, lists of function arguments, and expresssions,
  respectively.

</para>

</formalpara>

<formalpara>
  <title>Antiquotation</title>

<para>

  Instead of indicating meta-variables implicitly we could opt for an
  antiquotation mechanism that lets us splice in meta-level
  expressions into a concrete syntax fragment. For example, using
  <code>~</code> and <code>~*</code> as antiquotation operators, a
  variant of rule <code>TraceProcedure</code> becomes:

<screen>
  TraceProcedure :
    |[ function ~f(~* x*) = ~e ]| -> 
    |[ function ~f(~* x*) = 
         (enterfun(~String(f)); ~e; exitfun(~String(f))) ]|
</screen>

	With such antiquotation operators it becomes possible to
	directly embed meta-level computations that produce a
	piece of code within a syntax fragment.

</para>

</formalpara>

</section>

<section>
  <title>Implementation</title>

<para>
	
  In the previous section we have seen how the extension of Stratego
  with concrete syntax for terms improves the readability of
  meta-programs.  In this section we describe the techniques used to
  achieve this extension.

</para>

<section>
  <title>Extending the Meta Language</title>

<para>

  To embed the syntax of an object language in the meta language the
  syntax definitions of the two languages should be combined and the
  object language sorts should be injected into the appropriate meta
  language sorts. In the Stratego setting this is achieved as follows.
  The syntax of a Stratego module <code>m</code> is declared in the
  <code>m.meta</code> file, which declares the name of an SDF
  module. For instance, for modules using Tiger concrete syntax, i.e.,
  using the extension of Stratego with Tiger, the <code>.meta</code>
  would contain

<screen>
Meta([Syntax("StrategoTiger")])
</screen>

  thus declaring SDF module <code>StrategoTiger.sdf</code> as defining
  the extension.

</para>

<para>

  The SDF module combines the syntax of Stratego and the syntax of the
  object language(s) by importing the appropriate SDF modules.  The
  syntax definition of Stratego is provided by the compiler. The
  syntax definition of the object language is provided by the
  user. For example, the following SDF module shows a fragment of the
  syntax of Stratego:

<screen>
module Stratego-Terms
exports
  context-free syntax
    Int                             -> Term {cons("Int")}
    String                          -> Term {cons("Str")}
    Var                             -> Term {cons("Var")}
    Id "(" {Term ","}* ")"          -> Term {cons("Op")}
    Term "->" Term                  -> Rule {cons("RuleNoCond")}
    Term "->" Term "where" Strategy -> Rule {cons("Rule")}
</screen>

	The following SDF module <code>StrategoTiger</code>, defines
	the extension of Stratego with Tiger as object language.

<screen>
module StrategoTiger
imports Stratego [ Term => StrategoTerm
                   Var => StrategoVar
                   Id => StrategoId
                   StrChar => StrategoStrChar ]
imports Tiger Tiger-Variables
exports
  context-free syntax
    "|[" Dec     "]|"    -> StrategoTerm {cons("ToTerm"),prefer}
    "|[" TypeDec "]|"    -> StrategoTerm {cons("ToTerm"),prefer}
    "|[" FunDec  "]|"    -> StrategoTerm {cons("ToTerm"),prefer}
    "|[" Exp     "]|"    -> StrategoTerm {cons("ToTerm"),prefer}
    "~"  StrategoTerm    -> Exp          {cons("FromTerm"),prefer}
    "~*" StrategoTerm    -> {Exp ","}+   {cons("FromTerm")}
    "~*" StrategoTerm    -> {Exp ";"}+   {cons("FromTerm")}
    "~int:" StrategoTerm -> IntConst     {cons("FromTerm")}
</screen>

  The module illustrates several remarkable aspects of the embedding
  of object languages in meta languages using SDF.

</para>

<para>

  A combined syntax definition is created by just importing
  appropriate syntax definitions.  This is possible since SDF is a
  modular syntax definition formalism.  This is a rather unique
  feature of SDF and essential to this kind of language
  extension. Since only the full class of context-free grammars, and
  not any of its subclasses such as LL or LR, are closed under
  composition, modularity of syntax definitions requires support from
  a generalized parsing technique. SDF2 employs scannerless
  generalized-LR parsing.

</para>

<para>

  The syntax definitions for two languages may partially overlap,
  e.g., define the same sorts. SDF2 supports renaming of sorts to
  avoid name clashes and ambiguities resulting from them. In the
  StrategoTiger module several sorts from the Stratego syntax
  definition (<code>Term</code>, <code>Id</code>, <code>Var</code>,
  and <code>StrChar</code>) are renamed since the Tiger definition
  also defines these names. In practice, instead of doing this
  renaming for each language extension, module
  <code>StrategoRenamed</code> provides a syntax definition of
  Stratego in which all sorts have been renamed.

</para>

<para>

  The embedding of object language expressions in the meta-language is
  implemented by adding appropriate injections to the combined syntax
  definition. For example, the production 

<screen>
"|[" Exp "]|" -> StrategoTerm {cons("ToTerm"),prefer}
</screen>

  dweclares that a Tiger expression (<code>Exp</code>) between
  <code>|[</code> and <code>]|</code> can be used everywhere where a
  <code>StrategoTerm</code> can be used. Furthermore, abstract syntax
  expressions (including meta-level computations) can be spliced into
  concrete syntax expressions using the <code>~</code> splice
  operators. To distinguish a term that should be interpreted as a
  list from a term that should be interpreted as a list
  <emphasis>element</emphasis>, the convention is to use a
  <code>~*</code> operator for splicing a list.
	
</para>

<para>
	
  The declaration of these injections can be automated by generating
  an appropriate production for each sort as a transformation on the
  SDF definition of the object language.  It is, however, useful that
  the embedding can be programmed by the meta-programmer to have full
  control over the selection of the sorts to be injected, and the
  syntax used for the injections.

</para>

</section>

<section>
  <title>Meta-Variables</title>

<para>

  Using the injection of meta-language <code>StrategoTerm</code>s into
  object language <code>Exp</code>ressions it is possible to
  distinguish meta-variables from object language identifiers. Thus,
  in the term <code>|[ var ~x := ~e]|</code>, the expressions
  <code>~x</code> and <code>~e</code> indicate meta-level terms, and
  hence <code>x</code> and <code>e</code> are meta-level variables.
	
</para>

<para>

  However, it is attractive to write object patterns with as few
  squigles as possible. This can be achieved through another feature
  of SDF, i.e., variable declarations.
  Figure~\ref{Fig:TigerVariables} declares syntax schemata for meta
  variables. According to this declaration <code>x</code>,
  <code>y</code>, and <code>g10</code> are meta-variables for
  identifiers and <code>e</code>, <code>e1</code>, and
  <code>e1023</code> are meta-variables of sort <code>Exp</code>. The
  last three productions declare variables over lists using the
  convention that these are distinquished from other variables with an
  asterisk. Thus, <code>x*</code> and <code>x1*</code> range over
  lists of function arguments.  The prefer attribute ensures that
  these identifiers are preferred over normal Tiger
  identifiers~\cite{BSVV02}.

<screen>
module Tiger-Variables
exports
  variables
    [s][0-9]*      -> StrConst    {prefer}
    [xyzfgh][0-9]* -> Id          {prefer}
    [e][0-9]*      -> Exp         {prefer}
    "ta"[0-9]*     -> TypeAn      {prefer}
    "x"[0-9]* "*"  -> {FArg ","}+ {prefer}
    "d"[0-9]* "*"  -> Dec+        {prefer}
    "e"[0-9]* "*"  -> {Exp ";"}+  {prefer}
</screen>

</para>

</section>

<section>
  <title>Meta-Explode</title>

<para>

  Parsing a module according to the combined syntax and mapping the
  parse tree to abstract syntax results in an abstract syntax tree
  that contains a mixture of meta- and object-language abstract
  syntax.  Since the meta-language compiler only deals with
  meta-language abstract syntax, the embedded object-language abstract
  syntax needs to be expressed in terms of meta abstract syntax.  For
  example, parsing the following Stratego rule

<screen>
 |[ x := let d* in ~* e* end ]| -> |[ let d* in x := (~* e*) end ]|
</screen>

  with embedded Tiger expressions, results in the abstract syntax tree

<screen>
Rule(ToTerm(Assign(Var(meta-var("x")),
                   Let(meta-var("d*"),FromTerm(Var("e*"))))),
     ToTerm(Let(meta-var("d*"),
                [Assign(Var(meta-var("x")),
                        Seq(FromTerm(Var("e*"))))])))
</screen>

  containing Tiger abstract syntax constructors (e.g.,
  <code>Let</code>, <code>Var</code>, <code>Assign</code>) and
  meta-variables (<code>meta-var</code>). The transition from meta
  language to object language is marked by the <code>ToTerm</code>
  constructor, while the transition from meta-language to
  object-language is marked by the constructor <code>FromTerm</code>.

</para>

<para>

  Such mixed abstract syntax trees can be normalized by `exploding'
  all embedded abstract syntax to meta-language abstract syntax. Thus,
  the above tree should be exploded to the following pure Stratego
  abstract syntax:

<screen>
  Rule(Op("Assign",[Op("Var",[Var("x")]),
                    Op("Let",[Var("d*"),Var("e*")])]),
       Op("Let",[Var("d*"),
                 Op("Cons",[Op("Assign",[Op("Var",[Var("x")]),
                                         Op("Seq",[Var("e*")])]),
                            Op("Nil",[])])]))
</screen>

  Observe that in this explosion all embedded constructor applications
  have been translated to the form <code>Op(C,[t1,...,tn])</code>. For
  example, the Tiger `variable' constructor <code>Var(_)</code>
  becomes <code>Op("Var",[_])</code>, while the Stratego meta-variable
  <code>Var("e*")</code> remains untouched, and <code>meta-var</code>s
  become Stratego <code>Var</code>s.  Also note how the list in the
  second argument of the second <code>Let</code> is exploded to a
  <code>Cons</code>/<code>Nil</code> list.

</para>

<para>
	
  The resulting term corresponds to the abstract syntax for the rule

<screen>
Assign(Var(x),Let(d*,e*)) -> Let(d*,[Assign(Var(x),Seq(e*))])
</screen>

  written with abstract syntax notations for terms.

</para>

<para>
	
  The explosion of embedded abstract syntax does not depend on the
  object language; it can be expressed generically, provided that
  embeddings are indicated with the <code>FromTerm</code>
  constructor. The <emphasis>complete</emphasis> implementation of the
  <code>meta-explode</code> transformation on
  <code>StrategoTerm</code> abstract syntax trees is presented in
  Section~\ref{Sec:metaexplode} at the end of this chapter.  The
  implementation makes use of Stratego features not yet treated. But,
  the details of this transformation are not important for
  understanding the use of concrete syntax. The reader can refer back
  to Section~\ref{Sec:metaexplode} after reading
  Part~\ref{Part:Strategies}.

</para>

</section>

</section>

<section>
  <title>Discussion</title>

<formalpara>
  <title>Disambiguating Quotations</title>
<para>

  Sometimes the fragments used within quotations are too small for the
  parser to be able to disambiguate them. In those cases it is useful
  to have alternative versions of the quotation operators that make
  the sort of the fragment explicit. A useful, although somewhat
  verbose, convention is to use the sort of the fragment as operator:

<screen>
   "exp" "|[" Exp "]|" -> StrategoTerm {cons("ToTerm")}
</screen>

</para>

</formalpara>

<formalpara>
   <title>Other Quotation Conventions</title>

<para>

  The convention of using <code>|[...]|</code> and <code>~</code> as
  quotation and anti-quotation delimiters is inspired by the notation
  used in texts about semantics. It really depends on the application,
  the languages involved, and the `audience' what kind of delimiters
  are most appropriate.
	
</para>

</formalpara>

<para>
	
  In \cite{Wij03,Bra03} a notation inspired by active web pages is
  developed. For instance, the following quotation
  <code>%>...&lt;%</code> and antiquotation <code>&lt;%...%></code>
  delimiters are defined for use of XML in Stratego programs:

<screen>
  context-free syntax
    "%>" Content "&lt;%" -> StrategoTerm {cons("ToTerm"),prefer}
    "&lt;%=" StrategoTerm     "%>" -> Content {cons("FromTerm")}
    "&lt;%"  StrategoStrategy "%>" -> Content {cons("FromApp")}
</screen>

</para>

<formalpara>
   <title>Desugaring Patterns</title>

<para>

	Some meta-programs first desugar a program before transforming
	it further. This reduces the number of constructs and shapes a
	program can have. For example, the Tiger binary operators are
	desugared to prefix form:

<screen>
  DefTimes : |[ e1 * e2 ]|  -> |[ *(e1, e2) ]|
  DefPlus  : |[ e1 + e2 ]|  -> |[ +(e1, e2) ]|
</screen>

	or in abstract syntax

<screen>
  DefPlus : Plus(e1, e2) -> BinOp(PLUS, e1, e2)
</screen>

	This makes it easy to write generic transformations
	for binary operators. However, all subsequent transformations
	on binary operators should then be done on these prefix forms,
	instead of on the usual infix form.  However,
	users/meta-programmers think in terms of the infix operators
	and would like to write rules such as

<screen>
  Simplify : |[ e + 0 ]| -> |[ e ]|
</screen>

	\noindent However, this rule will not match since the term to
	which it is applied has been desugared.  Thus, it might be
	desirable to desugar embedded abstract syntax with the same
	rules with which programs are desugared.
	This phenomenon occurs in many forms ranging from removing
	parentheses and generalizing binary operators as above, to
	decorating abstract syntax trees with information resulting
	from static analysis such as type checking. 

</para>

</section>

<section>
  <title>Summary</title>

<para>

</para>

</section>

</chapter>
