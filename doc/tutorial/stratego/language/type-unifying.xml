<chapter xml:id="stratego-type-unifying-strategies"
  xmlns="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2003/XInclude">

  <title>Type Unifying Strategies (*)</title>

<para>

  The strategies that we have inspected so far are geared to transform
  terms while preserving types
  (<emphasis>rephrasings</emphasis>). There is also a class of
  transformations, in which terms are <emphasis>translated</emphasis>
  to a different type. In this chapter we introduce a
  <emphasis>generic term construction and decomposition</emphasis>
  combinator, which allows us to define generic translation or
  <emphasis>type unifying</emphasis> strategies.

</para>

<section>
   <title>Introduction</title>

<para>

  In <xref linkend="stratego-traversal-strategies"/> we have seen
  combinators for composing <emphasis>type preserving</emphasis>
  strategies. That is, structural transformations in which basic
  transformation rules don't change the type of a term. Such
  strategies are typically applied in transformations, which change
  the structure of a term, but not its type. Examples are
  simplification and optimization.

  In this chapter we consider the class of <emphasis>type
  unifying</emphasis> strategies, in which terms of different types
  are mapped onto one type. The application area for this type of
  strategy is analysis of expresssions with examples such as free
  variables collection and call-graph extraction.

  We will consider the following example problems:
            
  <itemizedlist>
    <listitem>
      <para>
	<code>term-size</code>: Count the number of nodes in a term
      </para>
    </listitem>

    <listitem>
      <para>
	<code>occurrences</code>: Count number of occurrences of a
	subterm in a term
      </para>
    </listitem>

    <listitem>
      <para>
	<code>collect-vars</code>: Collect all variables in expression
      </para>
    </listitem>

    <listitem>
      <para>
	<code>free-vars</code>: Collect all <emphasis>free</emphasis>
	variables in expression
      </para>
    </listitem>
  </itemizedlist>

</para>

</section>

<section>
   <title>Type Unifying List Transformations</title>

<para>

  We start by considering type-unifying operations on lists.

  Size (Number of Nodes) Replacing Nil by s1 and Cons by s2 

<screen>
foldr(s1, s2) = 
  []; s1 &lt;+ \ [y|ys] -> &lt;s2>(y, &lt;foldr(s1, s2)> ys) \ 
</screen>

  Add the elements of a list of integers 

<screen>
sum = foldr(!0, add) 
</screen>

  Fold and apply f to the elements of the list 

<screen>
foldr(s1, s2, f) = 
  []; s1 &lt;+ \ [y|ys] -> &lt;s2>(&lt;f>y,&lt;foldr(s1,s2,f)>ys) \ 
</screen>

  Length of a list 

<screen>
length = foldr(!0, add, !1)
</screen>

  Number of occurrences in a list 

<screen>
list-occurrences(s) = foldr(!0, add, s &lt; !1 + !0)
</screen>

  Number of variables in a list 

<screen>
list-occurrences(?Var(id))
</screen>

</para>

<para>
     
  Collect Terms 

  Filter elements in a list for which s succeeds 

<screen>
filter(s) = [] + [s | filter(s)] &lt;+ ?[ |&lt;filter(s)>]
</screen> 

  Collect variables in a list 

<screen>
filter(Var(id)) 
</screen>

  Collect variables in first list, exclude elements in second list 

<screen>
(filter(Var(id)),id); diff
</screen>

</para>

</section>

<section>
   <title>Extending Fold to Expressions</title>

<para>

  Generalize folding of lists to arbitrary terms 
  
  Example: Tiger expressions 

<screen>
fold-exp(binop, assign, if, ...) = 
  rec f( 
    \ BinOp(op, e1, e2) -> &lt;binop>(op,&lt;f>e1, &lt;f>e2) \ 
  + \ Assign(e1, e2) -> &lt;assign>(&lt;f>e1, &lt;f>e2) \ 
  + \ If(e1, e2, e3) -> &lt;if>(&lt;f>e1, &lt;f>e2, &lt;f>e3) \ 
  + ... 
  )
</screen>

  Term-Size with Fold 

<screen>
term-size = 
  fold-exp(BinOpSize, AssignSize, IfSize, ...)

BinOpSize : 
  BinOp(op, e1, e2) -> &lt;add>(1, &lt;add>(e1, e2)) 

AssignSize : 
  Assign(e1, e2) -> &lt;add>(e1, e2)) 

// etc.
</screen>

</para>

<para>

  Definining folds in this manner has several limitations.  In the
  definition of fold, one parameter for each constructor is provided
  and traversal is defined explicitly for each constructor.
  Furthermore, in the instantiation of fold one rule for each
  constructor is needed, and the default behaviour is not generically
  specified.

  Limitations of Fold 

  Definition of fold 
  
  One parameter for each constructor 
  
  Define traversal for each constructor 
  
  Instantiation of fold 
  
  One rule for each constructor 

  Default behaviour not generically specified

</para>

<para>

  One solution would be to use the generic traversal strategy
  <code>bottomup</code> to deal with fold:


  Defining Fold with Generic Traversal 
  
  Fold is bottomup traversal: 

<screen>
fold-exp(s)= 
  bottomup(s) 

term-size = 
  fold-exp(BinOpSize &lt;+ AssignSize &lt;+ IfSize &lt;+ ...) 
</screen>

  Definition of fold 

  Recursive application to subterms defined generically 
  
  One parameter: rules combined with choice

  Instantiation: default behaviour not generically specified

  Although the recursive application to subterms is now defined
  generically , one still has to specify rules for the default
  behaviour.

</para>

</section>

<section>
  <title>Generic Term Deconstruction</title>
  
<para>

  Instead of having folding rules that are specific to a data type,
  such as

  Generic Term Deconstruction 

  (1) Specific definitions 

<screen>
BinOpSize : 
  BinOp(op, e1, e2) -> &lt;add>(1, &lt;add>(e1, e2)) 

AssignSize : 
  Assign(e1, e2) -> &lt;add>(1, &lt;add>(e1, e2)) 
</screen>

  Generic definition

<screen>
CSize : 
  c(e1, e2, ...) -> &lt;add>(e1, &lt;add>(e2, ...)) 
</screen>

  Requires generic decomposition of constructor application

  This requires generic decomposition of a constructor application
  into its constructor and the list with children. This can be done
  using the <code>#</code> operator. The match strategy
  <code>?p1#(p2)</code> decomposes a constructor application into its
  onstructor name and the list of direct subterms. Matching such a
  pattern against a term of the form <code>C(t1,...,tn)</code> results
  in a match of <code>"C"</code> against <code>p1</code> and a match
  of <code>[t1,...,tn]</code> against <code>p2</code>.


  Generic Term Deconstruction Syntax: ?p1#(p2) 

  Semantics: when applied to a term c(t1,...,tn) matches 

  "c" against p1 

  [t1,...,tn] against p2 

  Decompose constructor application into its constructor name and list
  of direct subterms

<screen>
Plus(Int("1"), Var("2")) 
stratego> ?c#(xs)
stratego> :binding c
variable c bound to "Plus" 
stratego> :binding xs 
variable xs bound to [Int("1"), Var("2")]
</screen>

</para>

<para>

  Reduce a constructor application by folding the list of subterms.

  Definition of Crush 

<screen>
crush(nul, sum, s) : 
  #(xs) -> &lt;foldr(nul, sum, s)> xs
</screen>

   Now we can define all kinds of operations generically

   Applications of Crush 

<screen>
node-size = 
  crush(!0, add, !1) 

term-size = 
  crush(!1, add, term-size) 

om-occurrences(s) = 
  s &lt; !1 + crush(!0, add, om-occurrences(s))

occurrences(s) = 
  &lt;add>(&lt;s &lt; !1 + !0>, &lt;crush(!0, add, occurrences(s))>)
</screen>

  Collect Collect all (outermost) sub-terms for which s succeeds 

<screen>
collect(s) = 
  ![&lt;s>] &lt;+ crush(![], union, collect(s)) 

Collect all sub-terms for whichs succeeds 

collect-all(s) = 
  ![&lt;s> | &lt;crush(![], union, collect(s))>] 
  &lt;+ crush(![], union, collect(s))
</screen>

  Application 

  Collect all variables in an expression

<screen>
get-vars = 
  collect(Var(id))
</screen>

  Free Variables 

  Collect all free variables 
  
  Collect variables 
  
  Remove bound variables 
  
  Example 

<screen>
x + let var y := x + 1 in f(y, a + x + b) end 
</screen>

  free variables: {x, a, b}

<screen>
function f(x : int) = let var y := h(x) in x + g(z) * y end 
</screen>

  free variables: {z}

</para>

<para>

  Collect all free variables from a Tiger expression 

<screen>
free-vars = 
  ExpVars 
  &lt;+FreeVars(free-vars) 
  &lt;+ crush(![], union, free-vars) 

ExpVars : 
  Var(x) -> []

FreeVars(fv) : 
  Let([VarDec(x, t, e1)], e2) -> 
  &lt;union>(&lt;fv> e1, &lt;diff>(&lt;fv> e2, [x])) 

FreeVars(fv) : 
  Let([FunctionDec(fdecs)], e2) -> 
  &lt;diff>(&lt;union>(&lt;fv> fdecs, &lt;fv>e2), fs) 
  where &lt;map( FunDec(f, , , )-> f )> fdecs => fs 

FreeVars(fv) : 
  FunDec(f, xs, t, e) -> &lt;diff>(&lt;fv>e, xs) 
  where &lt;map(Fst)> xs => xs
</screen>
   
</para>

<para>

  A generic collection algorithm 

<screen>
collect-exc(base, special : a * (a -> b) -> b) = 
  rec coll( 
    base 
    &lt;+ special(coll) 
    &lt;+ crush(![], union, coll) 
  ) 
</screen>

  Instantiation 

<screen>
free-vars = collect-exc(ExpVars, FreeVars)
</screen>

</para>

</section>

<section>
   <title>Generic Term Construction</title>

<para>

  It can also be useful to <emphasis>construct</emphasis> terms
  generically. For example, in parse tree implosion, application nodes
  should be reduced to constructor applications. Hence build operators
  can also use the <code>#</code> operator. In a strategy
  <code>!p1#(p2)</code>, the current subject term is replaced by a
  constructor application, where the constructor name is provided by
  <code>p1</code> and the list of subterms by <code>p2</code>. So, if
  <code>p1</code> evaluates to <code>"C"</code> and <code>p2</code>
  evaluates to <code>[t1,...,tn]</code>, the expression
  <code>!p1#(p2)</code> build the term <code>C(t1,...,tn)</code>.

</para>

<formalpara>
  <title>Imploding Parse Trees</title>
<para>

  Parse tree format 

<screen>
appl(prod(sorts, sort, attrs([cons("C")])),[t1,...,tn]) 
</screen>

  Abstract syntax tree format C(t1,...,tn) 

  Implosion strategy 

<screen>
implode = 
  appl(id, map(implode)); Implode 

Implode : 
  appl(prod(sorts, sort, attrs([cons(c)])), ts) -> c#(ts) 
</screen>

  See implode-asfix for full strategy  

</para>

</formalpara>

</section>

<section>
  <title>Summary</title>

<para>

  Generic term construction and deconstruction support the definition
  of generic analysis and generic translation problems

</para>

</section>

</chapter>
