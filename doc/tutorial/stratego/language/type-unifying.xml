<chapter xml:id="stratego-type-unifying-strategies"
  xmlns="http://docbook.org/ns/docbook"
  xmlns:xi="http://www.w3.org/2003/XInclude">

  <title>Type Unifying Strategies (*)</title>

<para>

  In <xref linkend="stratego-traversal-strategies"/> we have seen
  combinators for composing <emphasis>type preserving</emphasis>
  strategies. That is, structural transformations in which basic
  transformation rules don't change the type of a term. Such
  strategies are typically applied in transformations, which change
  the structure of a term, but not its type. Examples are
  simplification and optimization.

  In this chapter we consider the class of <emphasis>type
  unifying</emphasis> strategies, in which terms of different types
  are mapped onto one type. The application area for this type of
  strategy is analysis of expresssions with examples such as free
  variables collection and call-graph extraction.

</para>

<para>

  We consider the following example problems:
            
  <itemizedlist>
    <listitem>
      <para>
	<code>term-size</code>: Count the number of nodes in a term
      </para>
    </listitem>

    <listitem>
      <para>
	<code>occurrences</code>: Count number of occurrences of a
	subterm in a term
      </para>
    </listitem>

    <listitem>
      <para>
	<code>collect-vars</code>: Collect all variables in expression
      </para>
    </listitem>

    <listitem>
      <para>
	<code>free-vars</code>: Collect all <emphasis>free</emphasis>
	variables in expression
      </para>
    </listitem>
  </itemizedlist>

  These problems have in common that they reduce a structure to a
  single value or to a collection of derived values. The structure of
  the original term is usually lost.

</para>

<para>

  We start with examining these problems in the context of lists, and
  then generalize the solutions we find there to arbitrary terms using
  generic term deconstruction, which allows concise implementation of
  generic type unifying strategies, similarly to the generic traversal
  strategies of <xref linkend="stratego-traversal-strategies"/>.

</para>

<section>
   <title>Type Unifying List Transformations</title>

<para>

  We start with considering type-unifying operations on lists.

</para>

<formalpara>
  <title>Fold</title>

<para>

  Reducing a list to a value can be conveniently expressed by means of
  a fold, which has as parameters operations for reducing the list
  constructors.

  The <code>foldr/2</code> strategy reduces a list by replacing each
  <code>Cons</code> by an application of <code>s2</code>, and the
  empty list by <code>s1</code>.

<screen>
foldr(s1, s2) = 
  []; s1 &lt;+ \ [y|ys] -> &lt;s2>(y, &lt;foldr(s1, s2)> ys) \ 
</screen>

  Thus, when applied to a list with three terms the result is

<screen>
&lt;foldr(s1,s2)> [t1,t2,t3] => &lt;s2>(t1, &lt;s2>(t2, &lt;s2>(t3, &lt;s1> [])))
</screen>

</para>

</formalpara>

<para>

  A typical application of <code>foldr/2</code> is <code>sum</code>,
  which reduces a list to the sum of its elements.  It sums the
  elements of a list of integers, using <code>0</code> for the empty
  list and <code>add</code> to combine the head of a list and the
  result of folding the tail.

<screen>
sum = foldr(!0, add)
</screen>
 
  The effect of <code>sum</code> is illustrated by the following
  application:

<screen>
&lt;foldr(!0,add)> [1,2,3] => &lt;add>(1, &lt;add>(2, &lt;add>(3, &lt;!0> []))) => 6
</screen>

  Note the build operator for replacing the empty list with
  <code>0</code>; writing <code>foldr(0, add)</code> would be wrong,
  since <code>0</code> by itself is a congruence operator, which
  basically <emphasis>matches</emphasis> the subject term with the
  term <code>0</code> (rather than replacing it).

</para>

<formalpara>
  <title>Fold with Map</title>

<para>

  The <code>foldr/2</code> strategy does not touch the elements of a
  list.  The <code>foldr/3</code> strategy is a combination of fold
  and map that extends <code>foldr/2</code> with a strategy that is
  applied to the elements of the list.

<screen>
foldr(s1, s2, f) = 
  []; s1 &lt;+ \ [y|ys] -> &lt;s2>(&lt;f>y, &lt;foldr(s1,s2,f)>ys) \ 
</screen>

  Thus, when applying it to a list with three elements, we get:

<screen>
&lt;foldr(s1,s2)> [t1,t2,t3] => &lt;s2>(&lt;f>t1, &lt;s2>(&lt;f>t2, &lt;s2>(&lt;f>t3, &lt;s1> [])))
</screen>

</para>

</formalpara>

<para>

  The length of a list is the sum of the list with the elements
  replaced by <code>1</code>.

<screen>
length = foldr(!0, add, !1)
</screen>

</para>

<formalpara>
  <title>Number of Occurrences</title>

<para>

  The number of occurrences in a list of terms that satisfy some
  predicate, entails only counting those elements in the list for
  which the predicate succeeds. (Where a predicate is expressed as the
  succes or failure of applying a strategy.) 

  This follows the same pattern as counting the length of a list, but
  includes a test for the predicate:

<screen>
list-occurrences(s) = foldr(!0, add, s &lt; !1 + !0)
</screen>

  Number of variables in a list 

<screen>
list-occurrences(?Var(id))
</screen>

</para>

</formalpara>

<formalpara>
  <title>Collect</title>

<para>
     
  Collect Terms 

  Filter elements in a list for which s succeeds 

<screen>
filter(s) = [] + [s | filter(s)] &lt;+ ?[ |&lt;filter(s)>]
</screen> 

  Collect variables in a list 

<screen>
filter(Var(id)) 
</screen>

  Collect variables in first list, exclude elements in second list 

<screen>
(filter(Var(id)),id); diff
</screen>

</para>

</formalpara>

</section>

<section>
   <title>Extending Fold to Expressions</title>

<para>

  Generalize folding of lists to arbitrary terms 
  
  Example: Tiger expressions 

<screen>
fold-exp(binop, assign, if, ...) = 
  rec f( 
    \ BinOp(op, e1, e2) -> &lt;binop>(op,&lt;f>e1, &lt;f>e2) \ 
  + \ Assign(e1, e2) -> &lt;assign>(&lt;f>e1, &lt;f>e2) \ 
  + \ If(e1, e2, e3) -> &lt;if>(&lt;f>e1, &lt;f>e2, &lt;f>e3) \ 
  + ... 
  )
</screen>

  Term-Size with Fold 

<screen>
term-size = 
  fold-exp(BinOpSize, AssignSize, IfSize, ...)

BinOpSize : 
  BinOp(op, e1, e2) -> &lt;add>(1, &lt;add>(e1, e2)) 

AssignSize : 
  Assign(e1, e2) -> &lt;add>(e1, e2)) 

// etc.
</screen>

</para>

<para>

  Definining folds in this manner has several limitations.  In the
  definition of fold, one parameter for each constructor is provided
  and traversal is defined explicitly for each constructor.
  Furthermore, in the instantiation of fold one rule for each
  constructor is needed, and the default behaviour is not generically
  specified.

  Limitations of Fold 

  Definition of fold 
  
  One parameter for each constructor 
  
  Define traversal for each constructor 
  
  Instantiation of fold 
  
  One rule for each constructor 

  Default behaviour not generically specified

</para>

<para>

  One solution would be to use the generic traversal strategy
  <code>bottomup</code> to deal with fold:


  Defining Fold with Generic Traversal 
  
  Fold is bottomup traversal: 

<screen>
fold-exp(s)= 
  bottomup(s) 

term-size = 
  fold-exp(BinOpSize &lt;+ AssignSize &lt;+ IfSize &lt;+ ...) 
</screen>

  Definition of fold 

  Recursive application to subterms defined generically 
  
  One parameter: rules combined with choice

  Instantiation: default behaviour not generically specified

  Although the recursive application to subterms is now defined
  generically , one still has to specify rules for the default
  behaviour.

</para>

</section>

<section>
  <title>Generic Term Deconstruction</title>
  
<para>

  Instead of having folding rules that are specific to a data type,
  such as

  Generic Term Deconstruction 

  (1) Specific definitions 

<screen>
BinOpSize : 
  BinOp(op, e1, e2) -> &lt;add>(1, &lt;add>(e1, e2)) 

AssignSize : 
  Assign(e1, e2) -> &lt;add>(1, &lt;add>(e1, e2)) 
</screen>

  Generic definition

<screen>
CSize : 
  c(e1, e2, ...) -> &lt;add>(e1, &lt;add>(e2, ...)) 
</screen>

  Requires generic decomposition of constructor application

  This requires generic decomposition of a constructor application
  into its constructor and the list with children. This can be done
  using the <code>#</code> operator. The match strategy
  <code>?p1#(p2)</code> decomposes a constructor application into its
  onstructor name and the list of direct subterms. Matching such a
  pattern against a term of the form <code>C(t1,...,tn)</code> results
  in a match of <code>"C"</code> against <code>p1</code> and a match
  of <code>[t1,...,tn]</code> against <code>p2</code>.


  Generic Term Deconstruction Syntax: ?p1#(p2) 

  Semantics: when applied to a term c(t1,...,tn) matches 

  "c" against p1 

  [t1,...,tn] against p2 

  Decompose constructor application into its constructor name and list
  of direct subterms

<screen>
Plus(Int("1"), Var("2")) 
stratego> ?c#(xs)
stratego> :binding c
variable c bound to "Plus" 
stratego> :binding xs 
variable xs bound to [Int("1"), Var("2")]
</screen>

</para>

<para>

  Reduce a constructor application by folding the list of subterms.

  Definition of Crush 

<screen>
crush(nul, sum, s) : 
  #(xs) -> &lt;foldr(nul, sum, s)> xs
</screen>

   Now we can define all kinds of operations generically

   Applications of Crush 

<screen>
node-size = 
  crush(!0, add, !1) 

term-size = 
  crush(!1, add, term-size) 

om-occurrences(s) = 
  s &lt; !1 + crush(!0, add, om-occurrences(s))

occurrences(s) = 
  &lt;add>(&lt;s &lt; !1 + !0>, &lt;crush(!0, add, occurrences(s))>)
</screen>

  Collect Collect all (outermost) sub-terms for which s succeeds 

<screen>
collect(s) = 
  ![&lt;s>] &lt;+ crush(![], union, collect(s)) 

Collect all sub-terms for whichs succeeds 

collect-all(s) = 
  ![&lt;s> | &lt;crush(![], union, collect(s))>] 
  &lt;+ crush(![], union, collect(s))
</screen>

  Application 

  Collect all variables in an expression

<screen>
get-vars = 
  collect(Var(id))
</screen>

  Free Variables 

  Collect all free variables 
  
  Collect variables 
  
  Remove bound variables 
  
  Example 

<screen>
x + let var y := x + 1 in f(y, a + x + b) end 
</screen>

  free variables: {x, a, b}

<screen>
function f(x : int) = let var y := h(x) in x + g(z) * y end 
</screen>

  free variables: {z}

</para>

<para>

  Collect all free variables from a Tiger expression 

<screen>
free-vars = 
  ExpVars 
  &lt;+FreeVars(free-vars) 
  &lt;+ crush(![], union, free-vars) 

ExpVars : 
  Var(x) -> []

FreeVars(fv) : 
  Let([VarDec(x, t, e1)], e2) -> 
  &lt;union>(&lt;fv> e1, &lt;diff>(&lt;fv> e2, [x])) 

FreeVars(fv) : 
  Let([FunctionDec(fdecs)], e2) -> 
  &lt;diff>(&lt;union>(&lt;fv> fdecs, &lt;fv>e2), fs) 
  where &lt;map( FunDec(f, , , )-> f )> fdecs => fs 

FreeVars(fv) : 
  FunDec(f, xs, t, e) -> &lt;diff>(&lt;fv>e, xs) 
  where &lt;map(Fst)> xs => xs
</screen>
   
</para>

<para>

  A generic collection algorithm 

<screen>
collect-exc(base, special : a * (a -> b) -> b) = 
  rec coll( 
    base 
    &lt;+ special(coll) 
    &lt;+ crush(![], union, coll) 
  ) 
</screen>

  Instantiation 

<screen>
free-vars = collect-exc(ExpVars, FreeVars)
</screen>

</para>

</section>

<section>
   <title>Generic Term Construction</title>

<para>

  It can also be useful to <emphasis>construct</emphasis> terms
  generically. For example, in parse tree implosion, application nodes
  should be reduced to constructor applications. Hence build operators
  can also use the <code>#</code> operator. In a strategy
  <code>!p1#(p2)</code>, the current subject term is replaced by a
  constructor application, where the constructor name is provided by
  <code>p1</code> and the list of subterms by <code>p2</code>. So, if
  <code>p1</code> evaluates to <code>"C"</code> and <code>p2</code>
  evaluates to <code>[t1,...,tn]</code>, the expression
  <code>!p1#(p2)</code> build the term <code>C(t1,...,tn)</code>.

</para>

<formalpara>
  <title>Imploding Parse Trees</title>
<para>

  Parse tree format 

<screen>
appl(prod(sorts, sort, attrs([cons("C")])),[t1,...,tn]) 
</screen>

  Abstract syntax tree format C(t1,...,tn) 

  Implosion strategy 

<screen>
implode = 
  appl(id, map(implode)); Implode 

Implode : 
  appl(prod(sorts, sort, attrs([cons(c)])), ts) -> c#(ts) 
</screen>

  See implode-asfix for full strategy  

</para>

</formalpara>

</section>

<section>
  <title>Summary</title>

<para>

  Generic term construction and deconstruction support the definition
  of generic analysis and generic translation problems

</para>

</section>

</chapter>
