<refentry lang="en" id="ref-rtg2typematch">
  <refnamediv>
    <refname>rtg2typematch</refname>
    <refpurpose>generates a set of Stratego strategies for typechecking terms against a regular tree grammar (RTG)</refpurpose>
  </refnamediv>

  <refsynopsisdiv>
    <cmdsynopsis>
      <command>rtg2typematch</command>
      <arg>-i <replaceable>file</replaceable> | --input <replaceable>file</replaceable></arg>
      <arg>-o <replaceable>file</replaceable> | --output <replaceable>file</replaceable></arg>
      <arg>-b</arg>
      <arg>-S | --silent</arg>
      <arg>--verbose <replaceable>level</replaceable></arg>
      <arg>-k <replaceable>level</replaceable> | --keep <replaceable>level</replaceable></arg>
      <arg>-h | -? | --help</arg>
      <arg>--about</arg>
      <arg>--version</arg>      
    </cmdsynopsis>
  </refsynopsisdiv>

  <refsection>
    <title>Description</title>

    <para>
      The <command>rtg2typematch</command> utility is used to generate a collection 
      of Stratego strategies with can be used to typecheck terms against a regular
      tree grammar. 
    </para>
    
    <para>
      The regular tree grammar is derived from the syntax definition, so the 
      strategies generated by <command>rtg2typematch</command> are used to check
      a term for well-formedness against a particular SDF grammar. 
    </para>
    
  </refsection>

  <refsection>
    <title>Options</title>
 
    <include href="common-io-options.xml" xmlns="http://www.w3.org/2003/XInclude"/>
    <include href="common-debugging-options.xml" xmlns="http://www.w3.org/2003/XInclude"/>
  </refsection>

  <refsection>
    <title>Example</title>
    
    <para>
      Consider the regular tree grammar given below (the exciting part 
      about how we created this from an SDF definition can be gleaned
      from the example for <link linkend="ref-sdf2rtg">sdf2rtg</link>):
    </para>
    
<programlisting>
regular tree grammar
start Exp
productions
  Exp      -> Minus(Exp,Exp)
  Exp      -> Plus(Exp,Exp)
  Exp      -> Mod(Exp,Exp)
  Exp      -> Div(Exp,Exp)
  Exp      -> Mul(Exp,Exp)
  Exp      -> Int(IntConst)
  Exp      -> Var(Id)
  IntConst -> &lt;string>
  Id       -> &lt;string>
</programlisting>    

    <para>
      We run <command>rtg2typematch</command> as shown below, to obtain the
      following Stratego module. Assume the regular tree grammar above is
      stored in <filename>Exp.rtg</filename>.  
    </para>
    
    <screen><prompt>$ </prompt>rtg2typematch -i Exp.rtg -o Exp-typematch.rtg</screen>
    
<programlisting>
module Exp-typematch
strategies
  is-Exp =
    ?Minus(_, _)
    + ?Plus(_, _)
      + ?Mod(_, _)
        + ?Div(_, _)
          + ?Mul(_, _)
            + ?Int(_)
              + ?Var(_)

  is-IntConst =
    is-string

  is-Id =
    is-string
</programlisting>
    
    <para>
      From inspecting the generated code, we see that <function>is-Exp</function> can be used
      to check whether a term is of sort <function>Exp</function>. Notice that the generated
      code only looks at the name of the constructor. If the same constructor can be used to
      produce different sorts, the typematch strategy of all these sort will accept a term
      that is an application of this constructor.
    </para>  

  </refsection>
  
  

  <include href="reporting-bugs.xml" xmlns="http://www.w3.org/2003/XInclude"/>
  <include href="lgpl-copyright.xml" xmlns="http://www.w3.org/2003/XInclude"/>
</refentry>
