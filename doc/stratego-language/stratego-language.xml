<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">

<chapter id="stratego-language">
  
  <title>Language</title>

  <include href="terms.xml" xmlns="http://www.w3.org/2003/XInclude"/>

  <include href="currentterm.xml" xmlns="http://www.w3.org/2003/XInclude"/>


  <section>
    <title>Building and matching terms</title>
    
    <para>
      The atomic actions of program transformation in Stratego are
      building terms from patterns and matching terms against
      patterns.
    </para>

    <include href="build.xml" xpointer="xpointer(id('build'))" xmlns="http://www.w3.org/2003/XInclude"/>

    <include href="match.xml" xpointer="xpointer(id('match'))" xmlns="http://www.w3.org/2003/XInclude"/>

  </section>
    
    <section>
      <title>Rewrite rules</title>

      <para>
	Basic transformations are combinations of match and build

	Combination requires

	Sequential composition of transformations

	Restricting the scope of term variables

	Syntactic abstractions (sugar) for typical combinations

	Rewrite rules

	Apply and match

	Build and apply

	Where

	Conditional rewrite rules

      </para>

      <include href="seq.xml" xpointer="xpointer(id('seq'))" xmlns="http://www.w3.org/2003/XInclude"/>

      <section>
	<title>Apply and match</title>
	
	<para>
	  Apply and match
	</para>
      </section>
      
      <section>
	<title>Build and apply</title>
	
	<para>
	  Build and apply
	</para>
      </section>
      
      <section>
	<title>Term variable scope</title>
	
	<para>
	  Term variable scope
	</para>
      </section>

      <section>
	<title></title>
	
	<para>
	  Anonymous rewrite rule
	</para>
      </section>
      
      <section>
	<title>Where</title>
	
	<para>
	  Where
	</para>
      </section>
      
      <section>
	<title>Conditional rewrite rule</title>
	
	<para>
	  Conditional rewrite rule
	</para>
      </section>
    </section>

    <section>
      <title>Stategy definitions</title>

      <para>
	Reuse of transformation requires definitions
      </para>

      <section>
	<title>Named strategy expressions</title>

	<para>
	  Named strategy expressions
	</para>
      </section>

      <section>
	<title>Named rewrite rules</title>

	<para>
	  Named rewrite rules
	</para>
      </section>

      <section>
	<title>Modules</title>

	<para>
	  Modules
	</para>
      </section>

      <section>
	<title>Parameterized and recursive definitions</title>

	<para>
	  Parameterized and Recursive Definitions
	</para>

	<para>
	  Repeated application of a strategy can be achieved with
	  recursion. There are two styles for doing this; with a
	  recursive definition or using the fixpoint operator rec. A
	  recursive definition is a normal strategy definition with a
	  recursive call in its body.
	</para>

	<section>
	  <title>Fixpoint operator</title>
	  <para>
	    Another way to define recursion is using the fixpoint
	    operator rec x(s), which recurses on applications of x
	    within s.
	  </para>

	  <para>
	    Originally, the rec operator was the only way to define
	    recursion. It is still in the language in the first place
	    because it is widely used in many existing programs, and
	    in the second place because it can be a nice concise
	    expression of a recursive strategy. An example usage is
	    the definition of repeat with rec:
	  </para>

	</section>

      </section>
    </section>

    <section>
      <title>Composition of transformation strategies</title>

      <para>
	Rules define one-step transformations 

	Program transformations require many one-step transformations
	and selection of rules
      </para>

      <include href="leftchoice.xml" 
               xpointer="xpointer(id('leftchoice'))" 
               xmlns="http://www.w3.org/2003/XInclude"/>

      <include href="choice.xml" 
               xpointer="xpointer(id('choice'))" 
	       xmlns="http://www.w3.org/2003/XInclude"/>

      <include href="conditionalchoice.xml" 
               xpointer="xpointer(id('conditionalchoice'))" 
	       xmlns="http://www.w3.org/2003/XInclude"/>

      <include href="identity.xml" 
               xpointer="xpointer(id('identity'))" 
	       xmlns="http://www.w3.org/2003/XInclude"/>
      
      <include href="failure.xml" 
               xpointer="xpointer(id('failure'))" 
	       xmlns="http://www.w3.org/2003/XInclude"/>

      <include href="negation.xml" 
               xpointer="xpointer(id('negation'))" 
	       xmlns="http://www.w3.org/2003/XInclude"/>

    </section>

    <section>
      <title>Combinators for term traversal</title>

      <para>
	Match, build, sequential composition, and choice only apply
	transformations to the root of a term

	Complete transformations require term traversal
      </para>

      <include href="congruence.xml" xmlns="http://www.w3.org/2003/XInclude"/>

      <include href="traversal.xml" xmlns="http://www.w3.org/2003/XInclude"/>

      <section>
	<title>Generic term deconstruction</title>

	<para>
	  Generic term deconstruction
	</para>
      </section>

    </section>

    <include href="dynamic-rules.xml" xmlns="http://www.w3.org/2003/XInclude"/>
    <include href="concrete-syntax.xml" xmlns="http://www.w3.org/2003/XInclude"/>


  </chapter>
