<chapter id="stratego-language">
  
  <title>The Stratego Language</title>

  <section>
     <title>Compiler and Interpreter</title>

     <para>

       usage of compiler and interpreter

       interpreter: just for trying out language

       file extensions

       libraries?

       seperate compilation

     </para>
  </section>

  <section>
     <title>Structure of a Stratego Program</title>

     <para>
        
        module

     </para>

  </section>

  <includexml file="terms.xml" />
  <includexml file="currentterm.xml" />


  <section>
    <title>Building and matching terms</title>
    
    <para>
      The atomic actions of program transformation in Stratego are
      building terms from patterns and matching terms against
      patterns.
    </para>

    <include href="build.xml" 
	     xpointer="xpointer(id('build'))" 
	     xmlns="http://www.w3.org/2003/XInclude"/>

    <include href="match.xml" 
	     xpointer="xpointer(id('match'))" 
	     xmlns="http://www.w3.org/2003/XInclude"/>

  </section>
    
    <section>
      <title>Rewrite rules</title>

      <para>
	Basic transformations are combinations of match and build

	Combination requires

	Sequential composition of transformations

	Restricting the scope of term variables

	Syntactic abstractions (sugar) for typical combinations

	Rewrite rules

	Apply and match

	Build and apply

	Where

	Conditional rewrite rules

      </para>

      <include href="seq.xml" 
	       xpointer="xpointer(id('seq'))" 
	       xmlns="http://www.w3.org/2003/XInclude"/>

      <include href="applymatch.xml" 
	       xpointer="xpointer(id('applymatch'))" 
	       xmlns="http://www.w3.org/2003/XInclude"/>

      <include href="buildapply.xml" 
	       xpointer="xpointer(id('buildapply'))" 
	       xmlns="http://www.w3.org/2003/XInclude"/>

      <section>
	<title>Term variable scope</title>
	
	<para>
	  Term variable scope
	</para>
      </section>

      <section>
	<title></title>
	
	<para>
	  Anonymous rewrite rule
	</para>
      </section>
      
      <section>
	<title>Where</title>
	
	<para>
	  Where
	</para>
      </section>
      
      <section>
	<title>Conditional rewrite rule</title>
	
	<para>
	  Conditional rewrite rule
	</para>
      </section>
    </section>

    <section>
      <title>Stategy definitions</title>

      <para>
	Reuse of transformation requires definitions
      </para>


      <section>
	<title>Named rewrite rules</title>

	<para>
	  Named rewrite rules
	</para>
      </section>

      <section>
	<title>Modules</title>

	<para>
	  Modules
	</para>
      </section>

      <section>
	<title>Parameterized and recursive definitions</title>

	<para>
	  Parameterized and Recursive Definitions
	</para>

	<para>
	  Repeated application of a strategy can be achieved with
	  recursion. There are two styles for doing this; with a
	  recursive definition or using the fixpoint operator rec. A
	  recursive definition is a normal strategy definition with a
	  recursive call in its body.
	</para>


	<include href="rec.xml" 
		 xpointer="xpointer(id('rec'))" 
		 xmlns="http://www.w3.org/2003/XInclude"/>

      </section>

    </section>

    <section>
      <title>Composition of transformation strategies</title>

      <para>
	Rules define one-step transformations 

	Program transformations require many one-step transformations
	and selection of rules
      </para>

      <include href="leftchoice.xml" 
               xpointer="xpointer(id('leftchoice'))" 
               xmlns="http://www.w3.org/2003/XInclude"/>

      <include href="choice.xml" 
               xpointer="xpointer(id('choice'))" 
	       xmlns="http://www.w3.org/2003/XInclude"/>

      <include href="conditionalchoice.xml" 
               xpointer="xpointer(id('conditionalchoice'))" 
	       xmlns="http://www.w3.org/2003/XInclude"/>

      <include href="identity.xml" 
               xpointer="xpointer(id('identity'))" 
	       xmlns="http://www.w3.org/2003/XInclude"/>
      
      <include href="failure.xml" 
               xpointer="xpointer(id('failure'))" 
	       xmlns="http://www.w3.org/2003/XInclude"/>

      <include href="negation.xml" 
               xpointer="xpointer(id('negation'))" 
	       xmlns="http://www.w3.org/2003/XInclude"/>

    </section>

    <section>
      <title>Combinators for term traversal</title>

      <para>
	Match, build, sequential composition, and choice only apply
	transformations to the root of a term

	Complete transformations require term traversal
      </para>

      <include href="congruence.xml" 
	       xmlns="http://www.w3.org/2003/XInclude"/>

      <include href="traversal.xml" 
	       xmlns="http://www.w3.org/2003/XInclude"/>

      <section>
	<title>Generic term deconstruction</title>

	<para>
	  Generic term deconstruction
	</para>
      </section>

    </section>

    <include href="dynamic-rules.xml" 
	     xmlns="http://www.w3.org/2003/XInclude"/>
    <include href="concrete-syntax.xml" 
	     xmlns="http://www.w3.org/2003/XInclude"/>


  </chapter>
