<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">

<chapter>
  
  <title>Language</title>

  <section>
    <title>Terms</title>

    <para>
      ATerms (Annotated Terms) are the values of Stratego. The ATerm
      format provides a set of construct for representing trees,
      comparable to XML or abstract data types in functional
      programming languages. In Stratego, an ATerm (from now just
      called term) usually is the abstract syntax tree of some source
      code.
    </para>

    <para>
      For example, the code <code>4 + f(5 * x)</code> might be
      represented in a term as:
    </para>

    <programlisting>Plus(Int("4"), Call("f", [Mul(Int("5"), Var("x"))]))</programlisting>

    <para>
      We can add some layout to the term to make the structure of the
      term more clear:
    </para>

    <programlisting>
Plus(
  Int("4")
, Call(
    "f"
  , [ Mul(Int("5"), Var("x")) ]
  )
)</programlisting>

    <para>
      The format has a few constructs:
    </para>

    <variablelist>
      <varlistentry>
	<term>Integer</term>
	<listitem>
	  <para/>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>String</term>
	<listitem>
	  <para/>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Application</term>
	<listitem>
	  <para/>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>List</term>
	<listitem>
	  <para/>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Tuple</term>
	<listitem>
	  <para/>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Annotation</term>
	<listitem>
	  <para/>
	</listitem>
      </varlistentry>
    </variablelist>
  </section>

  <section>
    <title>Strategies and the Current Term</title>

    <para>
      Strategies are the statements and functions of the Stratego
      language. A strategy transforms a term into a new term, or
      fails. The term to which a strategy is applied, is called the
      <emphasis>current term</emphasis>. In the Stratego Shell you can
      see the current term with <command>:show</command>.
    </para>

    <screen>
<prompt>stratego></prompt> :show
()
<prompt>stratego></prompt></screen>

    <para>
      So, the current term is the empty tuple if you have just started
      the Stratego Shell. At the prompt of the shell you can enter
      strategies. If the strategy succeeds, then the shell will show
      the transformed term, which is now the new current term.
    </para>

    <screen>
<replaceable>current term</replaceable>
<prompt>stratego></prompt> <replaceable>strategy expression</replaceable>
<replaceable>transformed current</replaceable>
<prompt>stratego></prompt></screen>

    <para>
      Strategies can also fail. In that case, the shell will print a
      message and leave the current term untouched:
    </para>

    <screen>
<replaceable>current term</replaceable>
<prompt>stratego></prompt> <replaceable>strategy expression</replaceable>
command failed
<prompt>stratego></prompt> :show
<replaceable>current term</replaceable></screen>
  </section>

  <section>
    <title>Building and matching terms</title>
    
    <para>
      The atomic actions of program transformation in Stratego are
      building terms from patterns and matching terms against
      patterns.
    </para>

    <include href="build.xml" xpointer="xpointer(id('build'))" xmlns="http://www.w3.org/2003/XInclude"/>

    <include href="match.xml" xpointer="xpointer(id('match'))" xmlns="http://www.w3.org/2003/XInclude"/>

  </section>
    
    <section>
      <title>Rewrite rules</title>

      <para>
	Basic transformations are combinations of match and build

	Combination requires

	Sequential composition of transformations

	Restricting the scope of term variables

	Syntactic abstractions (sugar) for typical combinations

	Rewrite rules

	Apply and match

	Build and apply

	Where

	Conditional rewrite rules

      </para>

      <section>
	<title>Sequential composition</title>

	<para>
	  The sequential composition s1; s2 of the strategies s1 and
	  s2 first applies the strategy s1 to the subject term and
	  then s2 to the result of that first application.
	</para>
      </section>

      <section>
	<title>Apply and match</title>
	
	<para>
	  Apply and match
	</para>
      </section>
      
      <section>
	<title>Build and apply</title>
	
	<para>
	  Build and apply
	</para>
      </section>
      
      <section>
	<title>Term variable scope</title>
	
	<para>
	  Term variable scope
	</para>
      </section>

      <section>
	<title></title>
	
	<para>
	  Anonymous rewrite rule
	</para>
      </section>
      
      <section>
	<title>Where</title>
	
	<para>
	  Where
	</para>
      </section>
      
      <section>
	<title>Conditional rewrite rule</title>
	
	<para>
	  Conditional rewrite rule
	</para>
      </section>
    </section>

    <section>
      <title>Stategy definitions</title>

      <para>
	Reuse of transformation requires definitions
      </para>

      <section>
	<title>Named strategy expressions</title>

	<para>
	  Named strategy expressions
	</para>
      </section>

      <section>
	<title>Named rewrite rules</title>

	<para>
	  Named rewrite rules
	</para>
      </section>

      <section>
	<title>Modules</title>

	<para>
	  Modules
	</para>
      </section>

      <section>
	<title>Parameterized and recursive definitions</title>

	<para>
	  Parameterized and Recursive Definitions
	</para>

	<para>
	  Repeated application of a strategy can be achieved with
	  recursion. There are two styles for doing this; with a
	  recursive definition or using the fixpoint operator rec. A
	  recursive definition is a normal strategy definition with a
	  recursive call in its body.
	</para>

	<section>
	  <title>Fixpoint operator</title>
	  <para>
	    Another way to define recursion is using the fixpoint
	    operator rec x(s), which recurses on applications of x
	    within s.
	  </para>

	  <para>
	    Originally, the rec operator was the only way to define
	    recursion. It is still in the language in the first place
	    because it is widely used in many existing programs, and
	    in the second place because it can be a nice concise
	    expression of a recursive strategy. An example usage is
	    the definition of repeat with rec:
	  </para>

	  <screen>
strategies
  repeat(s) = rec x(s; x &lt;+ id)
</screen>

	</section>

      </section>
    </section>

    <section>
      <title>Composition of transformation strategies</title>

      <para>
	Rules define one-step transformations 

	Program transformations require many one-step transformations
	and selection of rules
      </para>

      <section>
	<title>Deterministic choice (left choice)</title>

	<para>
	  The left choice or deterministic choice s1 &lt;+ s2 chooses one
	  of the trans- formations to apply. That is, s1 is first
	  applied, and s2 is only applied if s2 fails. Formally, the
	  left choice operator is defined as:
	</para>

	<para>
	  A typical application of the deterministic choice operator
	  is to declare the priority between rules with overlapping
	  left-hand sides.
	</para>

	<para>
	  A useful application of &lt;+ in combination with id is the
	  reflexive closure of a strategy s. The strategy try(s) tries
	  to apply the strategy s, but if that fails, just succeeds
	  using id.
	</para>

	<screen><include href="xmpl/try.str" parse="text" xmlns="http://www.w3.org/2003/XInclude"/></screen>

      <para>
	Note that the choice is committed once the left-hand side
	strategy has succeeded, even if the continuation strategy
	fails.
      </para>

      </section>

      <section>
	<title>Choice</title>

	<para>
	  The deterministic choice operator prescribes that the left
	  alternative should be tried before the right alternative,
	  and that the latter is only used if the first fails. There
	  are applications where it is not necessary to define the
	  order of the alternatives. In those cases non-deterministic
	  choice can be used.
	</para>

	<para>
	  The non-deterministic choice operator s1 + s2 chooses one of
	  the two strategies s1 or s2 to apply, such that the one it
	  chooses succeeds. If both strategies fail, then the choice
	  fails as well.
	</para>

	<para>
	  Operationally one can imagine the choice operator to first
	  try one strategy, and, if that fails, to try the other. The
	  order in which this is done is undefined, i.e., arbitrarily
	  chosen by the compiler.
	</para>

      </section>

      <section>
	<title>Conditional choice</title>

	<para>
	  Conditional choice
	</para>

	<include href="ifthenelse.xml" xmlns="http://www.w3.org/2003/XInclude"/>
	<include href="ifthen.xml" xpointer="xpointer(id('ifthen'))" xmlns="http://www.w3.org/2003/XInclude"/>

      </section>

      <section>
	<title>Identity</title>

	<para>
	  Identity
	</para>
      </section>

      <section>
	<title>Failure</title>

	<para>
	  Failure
	</para>
      </section>

      <section>
	<title>Negation</title>

	<para>
	  Negation
	</para>
      </section>

    </section>

    <section>
      <title>Combinators for term traversal</title>

      <para>
	Match, build, sequential composition, and choice only apply
	transformations to the root of a term

	Complete transformations require term traversal
      </para>

      <section>
	<title>Congruence operators</title>

	<para>
	  Congruence operators
	</para>
      </section>

      <section>
	<title>Generic traversal operators</title>

	<para>
	  Generic traversal operators
	</para>

	<section>
	  <title>All</title>

	  <para>
	    all
	  </para>
	</section>

	<section>
	  <title>One</title>

	  <para>
	    one
	  </para>
	</section>

	<section>
	  <title>Some</title>

	  <para>
	    some
	  </para>
	</section>
      </section>

      <section>
	<title>Generic term deconstruction</title>

	<para>
	  Generic term deconstruction
	</para>
      </section>

    </section>

  </chapter>
