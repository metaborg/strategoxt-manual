<chapter id="stratego-language">
  <title>The Stratego Language</title>

  <includexml file="introduction.xml" />
  <includexml file="compiler-interpreter.xml" />
  <includexml file="terms.xml" />
  <includexml file="currentterm.xml" />

  <section>
    <title>Building and matching terms</title>
    
    <para>
      The atomic actions of program transformation in Stratego are
      building terms from patterns and matching terms against
      patterns.
    </para>

    <includexml file="build.xml" />
    <includexml file="match.xml" />

  </section>
    
  <section>
     <title></title>
     <para>
     </para>
  </section>

  <section>
      <title>Rewrite rules</title>

      <para>
	Basic transformations are combinations of match and build

	Combination requires

	Sequential composition of transformations

	Restricting the scope of term variables

	Syntactic abstractions (sugar) for typical combinations

	Rewrite rules

	Apply and match

	Build and apply

	Where

	Conditional rewrite rules

      </para>

      <includexml file="seq.xml"/>

      <includexml file="applymatch.xml"/>

      <includexml file="buildapply.xml"/>

      <section>
	<title>Term variable scope</title>
	
	<para>
	  Term variable scope
	</para>
      </section>

      <section>
	<title></title>
	
	<para>
	  Anonymous rewrite rule
	</para>
      </section>
      
      <section>
	<title>Where</title>
	
	<para>
	  Where
	</para>
      </section>
      
      <section>
	<title>Conditional rewrite rule</title>
	
	<para>
	  Conditional rewrite rule
	</para>
      </section>
    </section>

    <section>
      <title>Stategy definitions</title>

      <para>
	Reuse of transformation requires definitions
      </para>


      <section>
	<title>Named rewrite rules</title>

	<para>
	  Named rewrite rules
	</para>
      </section>

      <section>
	<title>Modules</title>

	<para>
	  Modules
	</para>
      </section>

      <section>
	<title>Parameterized and recursive definitions</title>

	<para>
	  Parameterized and Recursive Definitions
	</para>

	<para>
	  Repeated application of a strategy can be achieved with
	  recursion. There are two styles for doing this; with a
	  recursive definition or using the fixpoint operator rec. A
	  recursive definition is a normal strategy definition with a
	  recursive call in its body.
	</para>


	<includexml file="rec.xml"/>

      </section>

    </section>

    <section>
      <title>Composition of transformation strategies</title>

      <para>
	Rules define one-step transformations 

	Program transformations require many one-step transformations
	and selection of rules
      </para>

      <includexml file="leftchoice.xml" />

      <includexml file="choice.xml" 
               xpointer="xpointer(id('choice'))" />

      <includexml file="conditionalchoice.xml" />

      <includexml file="identity.xml" />
      
      <includexml file="failure.xml" />

      <includexml file="negation.xml" />

    </section>

    <section>
      <title>Combinators for term traversal</title>

      <para>
	Match, build, sequential composition, and choice only apply
	transformations to the root of a term

	Complete transformations require term traversal
      </para>

      <includexml file="congruence.xml" />

      <includexml file="traversal.xml" />

      <section>
	<title>Generic term deconstruction</title>

	<para>
	  Generic term deconstruction
	</para>
      </section>

    </section>

    <includexml file="dynamic-rules.xml"/>
    <includexml file="concrete-syntax.xml" />


  </chapter>
