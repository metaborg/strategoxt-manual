<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">

<chapter>
  <title>Syntax Definition and Pretty-Printing</title>

<sect1>
  <title>TIL: a Tiny Imperative Language</title>

  <para>

    This chapter shows how to define a syntax definition in SDF and
    how to derive a number of artifacts from such a definition, i.e.,
    a parser, a pretty-printer, and a Stratego signature. The chapter
    also introduces TIL, a Tiny Imperative Language, which is used in
    many of the examples.

  </para>

  <para>

     TIL is a tiny imperative language designed for the demonstration
     of language and transformation definition formalisms. The
     language has two data-types, integers and strings. A TIL program
     consists of a list of statements, which can be variable
     declarations, assignments, I/O instructions, and control-flow
     statements. Statements can use expressions to compute values from
     integer and string constants, and the values of variables.

  </para>

  <para>
   
     The following example gives an impression of the language. 

  </para>

  <includefile id="ref-til-xmpl-test1.til" root="../../src" file="til/xmpl/test1.til" />

</sect1>

<sect1>
  <title>Syntax Definition</title>

  <para>

     This section shows a modular definition of the syntax of TIL, the
     generation of a parse table from that definition, and its use for
     parsing program texts into abstract syntax trees.

  </para>

<sect2>
  <title>Modules</title>

  <para>

    The following files define the syntax of TIL in the syntax
    definition formalism SDF. SDF is a modular formalism that supports
    the definition of lexical and context-free syntax. Modularity
    entails that a syntax definition can be composed from multiple
    modules, and that such modules can be reused in multiple syntax
    definitions. Also, syntax definitions of different languages can
    be combined.

  </para>

  <sect3>
     <title>Layout</title>

  <para>

     Module <code>TIL-layout</code> defines the syntax of
     <code>LAYOUT</code>, the symbols that occur between every two
     context-free non-terminals. This is the way to introduce the
     whitespace and comments for a language. The definition uses <link
     linkend="ref-sdf-character-classes">character classes</link> to
     indicate classes of characters. For instance, whitespace consists
     of spaces, tabs, newlines, and carriage returns. Likewise,
     comments consist of two slashes followed by zero or more
     characters which are not newlines or carriage returns. The <link
     linkend="ref-sdf-follow-restriction">follow restriction</link>
     prevents ambiguities in parsing layout.
   
  </para>

  <includefile 
    id="ref-til-syn-TIL-layout.sdf" 
    root="../../src"
    file="til/syn/TIL-layout.sdf" />
  
  </sect3>

  <sect3>
    <title>Literals</title>
  <para>

     Module <code>TIL-literals</code> defines the syntax of
     identifiers, integer constants, and string literals. Note again
     the use of <link linkend="ref-sdf-character-classes">character
     classes</link> to indicate collections of characters and <link
     linkend="ref-sdf-regular-expressions">regular expressions</link> to
     indicate lists of zero or more (<code>*</code>), or one or more
     (<code>+</code>) elements. String characters
     (<code>StrChar</code>) are any characters other than double
     quote, backslash, or newline, and escaped versions of these
     characters.
   
  </para>

  <includefile 
    id="ref-til-syn-TIL-literals.sdf" 
    root="../../src"
    file="til/syn/TIL-literals.sdf" />
  
  </sect3>

  <sect3>
    <title>Expressions</title>

  <para>
   
     Module <code>TIL-expressions</code> defines the syntax of
     expressions that compute a value. Basic expressions are
     identifiers (variables), integer constants, and string literals.
     More complex expressions are obtained by the arithmetic and
     relational operators.

     The constructor attributes of productions (e.g.,
     <code>cons("Add")</code>) indicates the constructor to be used in
     the construction of an abstract syntax tree from a parse tree.

     Ambiguities of and between productions are solved by means of
     <link linkend="ref-sdf-associativity">associativity</link> and <link
     linkend="ref-sdf-priority">priority</link> declarations.

  </para>

  <includefile 
    id="ref-til-syn-TIL-expressions.sdf" 
    root="../../src"
    file="til/syn/TIL-expressions.sdf" />

  </sect3>

  <sect3>
    <title>Statements</title>

  <para>
   
     Module <code>TIL-statements</code> defines the syntax of
     statements, i.e., instructions to be executed. The assignment
     statement assigns the value of the right-hand side expression to
     the variable in the left-hand side. The <code>read</code> and
     <code>write</code> statements read a value from standard input or
     write a value to standard output. The control-flow constructs use
     lists of statements.

  </para>

  <includefile 
    id="ref-til-syn-TIL-statements.sdf" 
    root="../../src"
    file="til/syn/TIL-statements.sdf" />
  
  </sect3>

  <sect3>
    <title>Programs</title>

  <para>
   
     Module <code>TIL</code> (<xref linkend="ref-til-syn-TIL.sdf"/>)
     defines the syntax of the complete language by importing the
     modules above, and defining a <code>Program</code> as a list of
     statements. In addition, the module introduces a
     <code>start-symbol</code>. This is the sort that a parser will
     start parsing with. There may be multiple start symbols.

  </para>
  
  <includefile id="ref-til-syn-TIL.sdf" root="../../src" file="til/syn/TIL.sdf" />

  </sect3>
</sect2>


<sect2>
  <title>Parse Table Generation</title>

  <para>

     The following <code>maak</code> script first collects the modules
     of the syntax definition and then generates a parse table. 

     The result of <xref linkend="ref-pack-sdf"/> is a `definition'
     file (as opposed to a single module file, as we saw above) that
     contains all modules imported by the main module,
     <code>TIL.sdf</code> in this case (<xref
     linkend="ref-TIL.def"/>).

     The parser generator <xref linkend="ref-sdf2table"/> creates a
     parse table from a syntax definition. Note the use of the
     <code>-m</code> flag to indicate the main module from which to
     generate the table. The parse table (<code>TIL.tbl</code>) is a
     file in ATerm format, that is interpreted by the <xref
     linkend="ref-sglri"/> tool to parse text files.

  </para>

  <includefile id="ref-til-syn-maak" root="../../src" file="til/syn/maak" />

  <includefile id="ref-TIL.def" root="../../src" file="til/syn/TIL.def" />

</sect2>

<sect2 id="sdf-parsing-programs">
  <title>Parsing Programs</title>

  <para>

     The <xref linkend="ref-sglri"/> tool parses a text file given a
     parse table generated by <xref linkend="ref-sdf2table"/>. The
     result is an abstract syntax term in the ATerm format. In order
     to inspect this term it is useful to `pretty-print' it using the
     <xref linkend="ref-pp-aterm"/> tool. Compare the resulting
     term with the program in <xref linkend="ref-til-xmpl-test1.til" />.

  </para>

  <includefile 
    id="ref-til-xmpl-parse-test" 
    root="../../src" 
    file="til/xmpl/parse-test" />

  <includefile 
    id="ref-til-xmpl-test1.atil" 
    root="../../src" 
    file="til/xmpl/test1.atil" />

</sect2>

</sect1>

<sect1>
  <title>Term Format</title>

  <para>

     The result of parsing a text is an abstract syntax tree
     represented by means of an <link
     linkend="ref-aterms">ATerm</link>. When produced by a parser, one
     can be sure that an ATerm has the right format, since it was
     derived directly from a parse tree. However, terms can also be
     produced by other components, e.g., be the result of a
     transformation. In those cases it may worthwhile to check that
     the term is well-formed according to some schema. In Stratego/XT
     tree schemas are described by Regular Tree Grammars
     (RTGs). Stratego signatures are used within Stratego programs to
     verify some aspects of Stratego programs. RTGs and signatures can
     be derived automatically from a syntax definition in SDF.

  </para>

  <para>
 
     The following <code>maak</code> scripts derives from a syntax
     definition first an RTG, and from the RTG a Stratego signature.

  </para>

  <includefile 
    id="ref-til-sig-maak" 
    root="../../src" 
    file="til/sig/maak" />

<sect2>
  <title>Regular Tree Grammars</title>

  <para>

     Regular tree grammar generated from syntax definition

  </para>

  <includefile 
    id="ref-til-sig-TIL.rtg" 
    root="../../src" 
    file="til/sig/TIL.rtg" />

</sect2>

<sect2>
  <title>Signatures</title>
  
  <para>

     Stratego signature generated from regular tree grammar

  </para>

  <includefile 
    id="ref-til-sig-TIL.str" 
    root="../../src" 
    file="til/sig/TIL.str" />

</sect2>

<sect2>
  <title>Format Checking</title>

  <para>

     Check format of term using regular tree grammar

  </para>

  <includefile 
    id="ref-til-xmpl-fc-test1" 
    root="../../src" 
    file="til/xmpl/fc-test1" />

  <includefile 
    id="ref-til-xmpl-test1.atil.fc" 
    root="../../src" 
    file="til/xmpl/test1.atil.fc" />

  <includefile 
    id="ref-til-xmpl-fc-test2" 
    root="../../src" 
    file="til/xmpl/fc-test1" />

  <includefile 
    id="ref-til-xmpl-test1-wrong.atil" 
    root="../../src" 
    file="til/xmpl/test1-wrong.atil" />

  <includefile 
    id="ref-til-xmpl-test1-wrong.atil.fc" 
    root="../../src" 
    file="til/xmpl/test1-wrong.atil.fc" />

</sect2>

</sect1>

<sect1>
  <title>Pretty-Printing</title>

  <screen>file: til/pp/maak</screen>
  <screen><include parse="text"
  href="../../src/til/pp/maak"
  xmlns="http://www.w3.org/2003/XInclude"/></screen>

  <para>

     Generated pretty-print table

  </para>

  <screen>file: til/pp/TIL.pp</screen>
  <screen><include parse="text"
  href="../../src/til/pp/TIL.pp"
  xmlns="http://www.w3.org/2003/XInclude"/></screen>

  <para>

     Applying pretty-print table

     <xref linkend="ref-ast2text" /> translates an abstract syntax
     term to text given a pretty-print table

     In fact ast2text is a composition of
     <xref linkend="ref-ast2abox" />
     and <xref linkend="ref-abox2text" />

  </para>


  <screen>file: til/xmpl/pp-test1</screen>
  <screen><include parse="text"
  href="../../src/til/xmpl/pp-test1"
  xmlns="http://www.w3.org/2003/XInclude"/></screen>

  <para>

     The result 

  </para>

  <screen>file: til/xmpl/test1.txt1</screen>
  <screen><include parse="text"
  href="../../src/til/xmpl/test1.txt1"
  xmlns="http://www.w3.org/2003/XInclude"/></screen>

<sect2>
  <title>Adapting the Pretty-Print Table</title>

  <screen>file: til/pp/TIL-pretty.pp</screen>
  <screen><include parse="text"
  href="../../src/til/pp/TIL-pretty.pp"
  xmlns="http://www.w3.org/2003/XInclude"/></screen>

  <screen>file: til/xmpl/pp-test2</screen>
  <screen><include parse="text"
  href="../../src/til/xmpl/pp-test2"
  xmlns="http://www.w3.org/2003/XInclude"/></screen>

  <para>

     The result 

  </para>

  <screen>file: til/xmpl/test1.txt2</screen>
  <screen><include parse="text"
  href="../../src/til/xmpl/test1.txt2"
  xmlns="http://www.w3.org/2003/XInclude"/></screen>

</sect2>


<sect2>
  <title>Restoring Parentheses</title>

  <screen>file: til/pp/til-parenthesize.str</screen>
  <screen><include parse="text"
  href="../../src/til/pp/til-parenthesize.str"
  xmlns="http://www.w3.org/2003/XInclude"/></screen>

  <para>

     pretty-printing with parenthesizing

  </para>

</sect2>

</sect1>

<sect1>
  <title>A Complete Pipeline</title>

  <para>

     a complete parse-transform-pretty-print pipeline

  </para>

  <para>

     a complete parse-transform-pretty-print pipeline

  </para>

  <para>

     a complete parse-transform-pretty-print pipeline

  </para>


</sect1>

    
</chapter>
