<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">

  <chapter>

    <title>Java Transformations</title>

    <para>
    </para>

    <sect1>
      <title>Getting started with java-front</title>

      <para>
	JavaFront is a package that adds support for transforming Java
	programs to StrategoXT. The main things you need to know if
	you want to use JavaFront for StrategoXT are,

	<itemizedlist>
	  <listitem>
	    <para>
	       Stratego
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	       Knowledge of the SDF Syntax Definition Formalism is useful
	    </para>
	  </listitem>
	</itemizedlist>

      </para>

      <sect2>
	<title>Basics</title>
	<para>
	  A basic Java to Java transformation will be a pipeline:
	</para>
	
	<screen>
   $ parse-java -i Foo.java | ./your-transformation | pp-java</screen>

	<para>
	  Your transformation operates on the abstract syntax of Java,
	  represented in the ATerm format. The pp-aterm tool (part of
	  StrategoXT) can be used to inspect this representation:
	</para>

	<screen>
   $ parse-java -i Foo.java | pp-aterm</screen>

	<para>
	  The parse-java tool will parse the input with a parser for
	  Java version 1.5 (aka J2SE 5.0).
	</para>
      </sect2>

      <sect2>
	<title>Example: Add Blocks</title>
	<para>
	  Let's have a look at a real transformation on Java
	  implemented in Stratego and using Java Front. This example
	  will show how to implement a basic transformation in
	  Stratego with concrete or abstract syntax.
	</para>

	<para>
	  The following program does not use blocks in the if and else
	  branch of the if-else construct. I'm rather fundamentalistic
	  about using blocks in these constructs, so I'm going to
	  implement a transformation that adds blocks at the places
	  where they belong.
	</para>

	<screen>
  public class Foo
  {
    public static void main(String[] ps)
    {
      if(ps.length == 0)
        System.err.println("No arguments");
      else
        System.err.println(ps.length + " arguments");
    }
  }
</screen>

	<sect3>
	  <title>Getting Used to Stratego</title>

	  <para>
	    Before we really start with the interesting stuff, let's
	    make sure that we can compile a transformation tool that
	    does nothing at all. First, this tool reads input from
	    stdin or a file specified with the -i option, next it does
	    nothing with the abstract syntax tree, and last it writes
	    the program to stdout or a file specified with -o. The
	    Stratego library contains a strategy that does all thus:
	    io-wrap. It takes a strategy argument that will be applied
	    to the term that has been read from the input. The 'do
	    nothing' strategy in Stratego is called id, so we provide
	    this strategy for now. The resulting module is:
	  </para>
	  <screen>
  module add-block
  imports options
  strategies
    main =
      io-wrap(id)
</screen>
	  <para>
	    Save this module in a file add-block.str and compile it
	    with the Stratego compiler:
	  </para>
	  <screen>
  $ strc -i add-block.str</screen>
	  <para>
	    The result is an executable file add-block. We can use
	    this executable to setup our first pipeline:
	  </para>
	  <screen>
  $ parse-java -i Foo.java | ./add-block | pp-java</screen>
	  <para>
	    This pipeline first parses the Java file Foo.java to an
	    abstract syntax tree, then it applies our add-block tool
	    (which does nothing) and last it pretty-prints the
	    abstract syntax tree to ordinary Java syntax.
	  </para>

	</sect3>
	<sect3>
	  <title>The Real Job</title>

	  <para>
	    Now it's about time to do something useful in our
	    transformation tool. We need to implement a rewrite rule
	    that wraps a statements of an if-then construct in a
	    block, but only if it is itself not a block. Of course we
	    also have to handle the if-then-else construct, but that
	    is more of the same.
	  </para>

	  <para>
	    First we need to know how the if is represented in
	    abstract syntax. We don't want to dive in the syntax
	    definition yet, so let's just parse a simple Java class:
	  </para>
	  <screen>
  class Foo
  {
    static
    {
      if(x) 
        foo();

      if(x)
      {
        foo();
      }
    }
  }
</screen>

	  <para>
	    You can get a nice, structured view of the abstract syntax
	    tree by passing the output of parse-java to the pp-aterm
	    tool:
	  </para>
	  <screen>
  $ parse-java -i Test.java | pp-aterm</screen>

	  <para>
	    This reveals that the body of the static initializer is
	    represented as:
	  </para>
	  <screen>
  [ If(
      ExprName(Id("x"))
    , ExprStm(Invoke(Method(MethodName(Id("foo"))), []))
    )
  , If(
      ExprName(Id("x"))
    , Block(
        [ExprStm(Invoke(Method(MethodName(Id("foo"))), []))]
      )
    )
  ]
</screen>

	  <para>
	    As you can see, a block is represented as a Block (how
	    surprising!). Now we can implement a rewrite rule that
	    applies the puts a block in the then branch of an if-then
	    construct:
	  </para>
	  <screen>
   AddBlock:
     If(c, stm) -> If(c, Block([stm]))
</screen>

	  <para>
	    This rewrite rule still needs to be applied. We can do
	    this with a simple topdown traversal, where we try to
	    apply this rule at every node in the abstract syntax
	    tree. The topdown strategy is readily available in the
	    Stratego Library module simple-traversal. We also need to
	    import the module that defines the Stratego language. This
	    module, called Java-15, is available in your installation
	    of JavaFront. You should instruct the compiler to look for
	    modules in this directory. The complete implementation is:
	  </para>
	  <screen>
  module add-block
  imports
    options
    simple-traversal
    Java-15

  strategies

    main =
      io-wrap(add-block)

    add-block = 
      topdown(try(AddBlock))

  rules
  
    AddBlock:
      If(c, stm) -> If(c, Block([stm]))
</screen>

	  <para>
	    Compile the module with the following command, where you
	    should replace prefix with the location of you JavaFront
	    installation.
	  </para>
	  <screen>
  $ strc -i add-block.str -I prefix/share/java-front/</screen>

	  <para>
	    Now apply the program to the test program we have used
	    before:
	  </para>
	  <screen>
  class Foo
  {
    static
    {
      if(x) 
        foo();

      if(x)
      {
        foo();
      }
    }
  }
</screen>

	  <para>
	    The result is:
	  </para>
	  <screen>
  class Foo
  {
    static
    {
      if(x)
      {
        foo();
      }
      if(x)
      {
        {
          foo();
        }
      }
    }
  }
</screen>

	  <para>
	    But ... that's not what we intended to achieve with our
	    tool! The second block is now in yet another block, which
	    is rather ugly. So, we need to extend our tool to skip if
	    statements that already use a block. To this end, we add a
	    condition to the rewrite rule that checks if the stm is
	    not yet a block. The new rule is:
	  </para>
	  <screen>
  AddBlock:
    If(c, stm) -> If(c, Block([stm]))
      where &lt;not(?Block(_))> stm
</screen>

	  <para>
	    If you compile and run your new program, then you'll see
	    that the results is exactly what we want to have.
	  </para>


	</sect3>
	<sect3>
	  <title>Conclusion</title>

	  <para>
	    In this tiny example you have learned how to implement a
	    very basic Java transformation in Stratego with abstract
	    syntax. At this point, it might be a useful exercise to
	    add support for different statements, such as the
	    if-then-else, switch and for. I'm sure you can think of
	    many more Java transformations to do next. Have a lot of
	    fun!
	  </para>
	</sect3>
      </sect2>

      <sect2>
	<title>Example: Java Generation with Concrete Syntax</title>

	<para>
	  In this example I will show how to use concrete syntax for
	  Java inside your Stratego programs. Moreover, you will learn
	  how to use concrete object syntax in general, since using
	  concrete syntax for object languages is a basic feature of
	  StrategoXT.
	</para>

	<para>
	  So, what's the point of using concrete syntax? If you have
	  already implemented some Java transformations using abstract
	  syntax, then you will have noticed this yourself: using
	  abstract syntax requires in-depth knowledge of this
	  representation. Also, the abstract syntax fragments can be
	  quite verbose and don't show clearly what the code actually
	  stands for.
	</para>

	<para>
	  Fortunately, I have fooled you by letting you implement your
	  transformations in abstract syntax first. Stratego allows
	  you to embed the concrete syntax of the object language. Why
	  then did I show you the abstract syntax based
	  implementations first? Well, it is important to realize what
	  the underlying mechanism of the transformation is. If you
	  are only using concrete syntax, then you might think that
	  your are not transforming a structured representation of
	  your Java program. However, this is actually still the case
	  when you are using concrete syntax.
	</para>

	<sect3>
	  <title>Basic Concrete Syntax Skills</title>

	  <para>
	    In this first example we will implement a hello
	    generator. The generator takes the name of a person and
	    generates a Java program that welcomes this person. But,
	    let's start with the basic Stratego compilation skills by
	    generating a just static hello world program. The
	    following program shows the implementation. The concrete
	    syntax for Java is denoted between the |[ and ]|
	    symbols. Usually we specify the kind of syntax that is
	    produced, in this case a compilation unit, before the
	    quotation. Not doing this might result in ambiguities. For
	    example, the Java fragment in this program could be parsed
	    as a complete compilation unit or just a class
	    declaration.
	  </para>

	  <screen>
	  </screen>

	  <para>
	  </para>

	  <screen>
	  </screen>

	  <para>
	  </para>

	  <screen>
	  </screen>

	  <para>
	  </para>

	  <screen>
	  </screen>

	  <para>
	  </para>


	</sect3>

	<sect3>
	  <title>The Structure is Out There</title>

	  <para>
	  </para>
	</sect3>

	<sect3>
	  <title>Using Anti-Quotation</title>

	  <para>
	  </para>
	</sect3>

	<sect3>
	  <title>More Variability</title>

	  <para>
	  </para>
	</sect3>

	<sect3>
	  <title>Using Meta Variables</title>

	  <para>
	  </para>
	</sect3>


      </sect2>

      <sect2>
	<title>Example: Add Blocks with Concrete Syntax</title>

	<para>
	</para>

      </sect2>

      <sect2>
	<title>More Examples</title>

	<para>
	</para>

      </sect2>

    </sect1>

  </chapter>

