<chapter id="manual-intro">
  <title>Introduction (*)</title>

<section>
  <title>Software Transformation</title>

  <para>

    Program source code is the raw material produced by the software
    industry. Rather than being an end product, this material requires
    further processing to turn it into useful products. Compilation,
    the translation of a program to machine code in order to make it
    executable, is the standard processing technique applied. But much
    more can be done. There are many other kinds of processes that can
    be applied to programs. For example, programs can be synthesized
    from high-level specifications; programs can be optimized using
    knowledge of the application domain; documentation for
    understanding a program can be automatically derived from its
    sources; programs can be specialized to known inputs; application
    programs can be generated from domain-specific languages;
    low-level programs can be reverse engineered into high-level
    programs.

  </para>

  <para>

    All these processes require the manipulation of program source
    code.  In fact, all such manipulations can be viewed as
    transformations of a program to a derived program. (Here the
    notion of `program' is interpreted broadly, and includes all kinds
    of artifacts used in the composition of software systems,
    including configuration and data files, as long as there contents
    conform to some formal language.) Hence, program transformation is
    the unifying notion underlying automatic program processing.

  </para>

  <para>

    To reach a higher level of automation in software engineering, the
    use of automatic program transformation is indispensable.
    However, the realization of program transformation systems is
    hard.  Parts of the process, such as parsing, are supported by
    generative techniques, but most aspects require hard work.  The
    effective implementation of program transformation systems is a
    barrier for the wide adoption of program transformation in
    software engineering.  Most transformation techniques used in
    practice are based on textual generation and manipulation, which
    poses limitations on what can be done and is error-prone.

  </para>

  <para>

    Many systems for program transformation exist that are often
    specialized for a specific object language and/or kind of
    transformation.  All these systems share many ideas about program
    transformation and use similar techniques, but are often ad-hoc in
    many respects.  The ultimate goal is to achieve a specification
    language or family of specification languages for the high-level,
    declarative specification of program transformation systems in
    which generic, language independent schemas of transformation can
    be captured, and which admits efficient implementation of those
    transformations that can scale up to large programs.

  </para>

  <para>

    Stratego/XT is a framework for the implementation of
    transformation systems based on structural representations of
    programs.

    The framework aims at better productivity in the development of
    transformation systems through the use of high-level
    representations, domain-specific languages, and generative
    programming for various aspects of transformation systems: ATerms
    for program representation, SDF for syntax definition and parsing,
    GPP for pretty-printing, Stratego for transformation, XTC for
    transformation tool composition, and the XT tools for the
    generation of intermediate products needed in the construction of
    transformation systems.

  </para>

  <para>

    This book provides a manual to program transformation with
    Stratego/XT 


    This book is complementary to the Stratego/XT tutorial, a book
    that presents several large examples of Stratego/XT programs.

  </para>

  <para>

    This chapter gives an overview of the manual. 

  </para>

</section>

<section>
  <title>Applications (*)</title>

  <para>

    sketch application area

  </para>

  <screen>
Compilers 
- translation   
- desugaring  
- instruction selection 
  - maximal munch
  - burg-style dynamic programming
- optimization 
  - data-flow optimizations
  - vectorization
  - ghc-style simplification
  - deforestation
  - domain-specific optimization (codeboost)
  - partial evaluation   
- typechecking   
- specialization of dynamic typing

Program generators
- pretty-printer and signature generation from syntax definitions
- application generation from DSL (Java, C++) 

Program migration
- grammar conversion (yacc to sdf, ...)

Program understanding
- documentation generation 

Document generation/transformation 
- Web/XML programming (server-side  scripts )
  </screen>

</section>

<section>
  <title>Architecture of Transformation Systems (*)</title>

  <para>
    sketch how transformation systems are composed and how the various
    languages and tools fit in this architecture
  </para>

  <para>

    A program transformation system is usually organized as a simple
    pipeline of transformation steps. At the source of the pipeline, a
    parser reads the text of the input program and turns it into a
    parse tree or abstract syntax tree. Subsequently, one or several
    transformations components modify the tree. At the sink of the
    pipeline, a pretty-printer turns the output tree into program
    text.

  </para>

  <para>

  </para>

</section>

<section>
  <title>Outline (*)</title>

  <para>
    ATerms, The Stratego Language, The Syntax Definition Formalism
    SDF, The XT Transformation Tools, Stratego/XT Development,
    Reference Manual
  </para>

  <para>
        
    Programmers write programs as texts, which is a suitable
    representation for people. It is not, however, a useful
    representation for direct manipulation by an automatic program
    transformation system.  

    Part I treats the representation of programs as terms using the
    ATerm annotated term format.  

    Part II covers the syntax definition formalism SDF and the
    conversion from textual program representations to term
    representations.

    by means of parsing and pretty-printing.

    The construction of parsers and pretty-printers can be done
    automatically if a declarative definition of the syntax of the
    programming language is available. 

    The syntax definition formalism SDF is used to define the syntax
    of languages.

    The Box language is used to specify
    pretty-printers independently from the output format.

  </para>

  <para>

  </para>

  <para>

  </para>

</section>

</chapter>
